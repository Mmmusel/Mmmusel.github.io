<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-SQL-数据库作业2（lr班）</title>
      <link href="/2024/07/05/SQL-hw1/"/>
      <url>/2024/07/05/SQL-hw1/</url>
      
        <content type="html"><![CDATA[<h1 id="第二次数据库作业"><a href="#第二次数据库作业" class="headerlink" title="第二次数据库作业"></a>第二次数据库作业</h1><h2 id="一、安装数据库"><a href="#一、安装数据库" class="headerlink" title="一、安装数据库"></a>一、安装数据库</h2><h3 id="1-在计算机上安装一个DBMS软件"><a href="#1-在计算机上安装一个DBMS软件" class="headerlink" title="1.在计算机上安装一个DBMS软件"></a>1.在计算机上安装一个DBMS软件</h3><h4 id="1-1-基本环境"><a href="#1-1-基本环境" class="headerlink" title="1.1 基本环境"></a>1.1 基本环境</h4><ul><li><p>环境：windows11 + mysql-8.0.28-winx64 命令行工具</p></li><li><p>下载链接：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p></li><li><p>mysql-8.0.28-winx64目录下创建配置文件<code>my.ini</code>。</p></li></ul><pre><code class="plain">[mysqld]# portport=3306# set basedir to your installation pathbasedir=D:\\SOFTWARE\\mysql\\mysql-8.0.28-winx64# set datadir to the location of your data directorydatadir=D:\\SOFTWARE\\mysql\\mysql-8.0.28-winx64\\data# 以下设置utf8字符集[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]character-set-server=utf8# 以下设置允许加载本地文件数据至数据库[mysqld]local_infile = 1</code></pre><h4 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h4><ul><li>ctrl+X 启动 powershell(管理员模式)，进入bin目录<pre><code>cd D:\SOFTWARE\mysql\mysql-8.0.28-winx64\bin</code></pre></li><li>初始化，创建data文件夹<pre><code>.\mysqld.exe --initialize-insecure</code></pre></li><li>制作服务，此处命名为mysql157<pre><code>.\mysqld.exe --install mysql157</code></pre></li></ul><h4 id="1-3-每次启动数据库服务"><a href="#1-3-每次启动数据库服务" class="headerlink" title="1.3 每次启动数据库服务"></a>1.3 每次启动数据库服务</h4><ul><li>ctrl+X 启动 powershell(管理员模式)，进入bin目录</li></ul><pre><code>cd D:\SOFTWARE\mysql\mysql-8.0.28-winx64\bin</code></pre><ul><li>启动服务</li></ul><pre><code>net start mysql157</code></pre><blockquote><p>注：</p><ol><li>如果此处出现无服务报错，任务管理器中打开【详细信息】，把’mysqld.exe’进程关闭。</li><li>关闭sql的时候一定记得net stop mysql57!!!不能直接关闭powershell</li></ol></blockquote><ul><li>连接：此处也可以不加<code>--local-infile</code>，需要向数据库导入本地文件数据时需要添加<code>--local-infile</code>参数。<blockquote><p>初始化时，先设置密码再进行连接：</p><ol><li><code>D:\SOFTWARE\mysql\mysql-8.0.28-winx64\bin</code>添加到path环境变量。重启后生效。初始化的时候暂时先不重启。<ul><li>如果环境变量配置成功，可以直接 <code>mysqld xxx命令</code>。否则直接在bin目录下<code>.\mysqld.exe xxx命令</code>。<code>mysql</code>同理。</li></ul></li><li><code>.\mysqld.exe --skip-grant-tables</code>，用于稍后跳过密码输入</li><li><code>.\mysql.exe -h 127.0.0.1 -P 3306 -u root -p --local-infile</code>输入密码直接回车跳过即可</li><li><code>set password = &#39;123456&#39;;</code> 设置密码</li><li>检查连接成功：<code>show databases; </code> 需要分号</li><li>改字符集为utf8：<code>set names utf8;</code></li></ol></blockquote></li></ul><p>连接指令：</p><pre><code>mysql -h 127.0.0.1 -P 3306 -u root -p --local-infile</code></pre><h4 id="1-4-每次需要手动关闭数据库服务，否则可能出现端口占用问题"><a href="#1-4-每次需要手动关闭数据库服务，否则可能出现端口占用问题" class="headerlink" title="1.4 每次需要手动关闭数据库服务，否则可能出现端口占用问题"></a>1.4 每次需要手动关闭数据库服务，否则可能出现端口占用问题</h4><ul><li><p>连接后，会进入<code>&gt;mysql</code>，使用<code>exit;</code>停止</p></li><li><p><code>net stop mysql57</code>终止服务</p></li><li><p>关闭powershell即可</p></li><li><p>注：如果忘记<code>net stop mysql57</code>，可能start的时候会出现无服务报错，需要任务管理器中把’mysqld.exe’进程关闭。</p></li></ul><h3 id="2-默认数据库用途"><a href="#2-默认数据库用途" class="headerlink" title="2.默认数据库用途"></a>2.默认数据库用途</h3><pre><code class="sql">mysql&gt; show databases;</code></pre><pre><code class="sql">mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.01 sec)</code></pre><ul><li><p>mysql 数据库</p><p>存储了 MySQL 服务器正常运行所需的各种系统信息，包含了关于数据库对象元数据的数据字典表和系统表等。从 MySQL 8.0 开始，mysql 系统表和数据字典表使用 InnoDB 存储引擎，存储在 MySQL 数据目录下的 mysql.ibd 表空间文件中。</p></li><li><p>information_schema 信息数据库<br>INFORMATION_SCHEMA 数据库提供了访问数据库元数据的各种视图，包括数据库、表、字段类型以及访问权限等。这些信息有时候也被称为数据字典（data dictionary ）或者系统目录（system catalog），主要来源就是 mysql 系统数据库中的数据字典表。INFORMATION_SCHEMA 中的表实际上都是只读的视图，只能执行查询操作，不能执行 DML 语句。</p></li><li><p>performance_schema 性能数据<br>performance_schema 性能数据库为 MySQL 服务器的运行时状态提供了一个底层的监控功能。<br>MySQL 默认启动了性能数据库，也可以在启动服务时通过参数 performance_schema 指定是否启用。</p></li><li><p>sys 数据库<br>MySQL 5.7.7 引入了 sys 数据库，其中包含了一系列的视图，可以方便 DBA 和开发人员解释 performance_schema 性能数据库中收集的数据。sys 数据库中的对象主要用于性能调优和诊断，包括：</p><ul><li>视图，将性能数据库中的数据进行汇总，以更加容易理解的形式进行展示。</li><li>存储过程，配置性能数据库以及生成诊断报告等操作。</li><li>存储函数，用于查询性能数据库的配置和格式化服务。</li></ul></li></ul><h3 id="3-字符集和排序规则"><a href="#3-字符集和排序规则" class="headerlink" title="3.字符集和排序规则"></a>3.字符集和排序规则</h3><ul><li>查看字符集<pre><code class="sql">mysql&gt; show variables like &#39;character%&#39;;</code></pre></li></ul><ol><li><p>字符集的设置可以在MySQL实例、数据库、表、列四个级别。未显示设置时会继承字符集和排序规则。</p></li><li><p>查看当前MySQL支持的<strong>字符集</strong>的方式有两种，一种是通过查看information_schema.character_set系统表，一种是通过命令<code>show character set</code>查看</p></li><li><p>每个指定的字符集都会有一个或多个支持的<strong>排序规则</strong>，可以通过两种方式查看，一种是查看information_schema.collations表，另一种是通过show collation命令查看</p></li><li><p>每个字符集可以对应多个排序规则，但每个排序规则只能对应一个字符集</p></li><li><p>排序规则的命令通常是以对应的字符集的名字为开头，并以自己的特定属性结尾，比如排序规则utf8_general_ci和latin1_swedish_ci就分别是对应utf8和latin1字符集的排序规则。mysql8默认情况下的字符集是utf8mb4</p></li></ol><blockquote><p>部分字符集为gbk，会出现中文属性乱码等问题，需要设置成utf8。修改<code>my.ini</code>配置文件重启并<code>set names utf8;</code>即可<br>mysql：&gt;=5.5.49的版本，字符集是utf-8下，char(10)和varchar(10)存储的汉字和英文的数量都是10个</p></blockquote><h3 id="4-从其他同学的电脑上访问刚刚安装的数据库"><a href="#4-从其他同学的电脑上访问刚刚安装的数据库" class="headerlink" title="4.从其他同学的电脑上访问刚刚安装的数据库"></a>4.从其他同学的电脑上访问刚刚安装的数据库</h3><ul><li>如果my.ini配置文件中有<code>bind-address 127.0.0.1</code>，注释掉此行，允许数据库被非本地ip访问</li><li>进入mysql数据库</li></ul><pre><code class="mysql">use mysql</code></pre><ul><li>授权来自任何ip可以以用户名root登录数据库<pre><code class="mysql">update user set host=&#39;%&#39; where user=&#39;root&#39;;flush privileges;</code></pre></li><li>（mysql8.0对于设置数据库允许远程操作的命令有更新）先创建用户，此处建议使用自己数据库的密码<pre><code class="mysql">create user root@&#39;%&#39; identified by &#39;123456&#39;;flush privileges;</code></pre>如果遇到以下报错：应该是之前创建，执行删除的时候没有删除干净。此时重新进行删除<blockquote><p>ERROR 1396 (HY000): Operation CREATE USER failed for ‘root‘@‘%’</p></blockquote></li></ul><p>如果报错执行以下命令，再尝试创建用户。</p><pre><code class="mysql">drop user root@&#39;%&#39;;flush privileges;</code></pre><ul><li><p>成功创建用户后，给用户授权</p><pre><code class="mysql">grant all privileges on *.* to &#39;root&#39;@&#39;%&#39;;flush privileges;</code></pre></li><li><p>测试远程访问：</p></li></ul><p>由于之前启动服务均使用的本地ip：<code>mysql -h 127.0.0.1 -P 3306 -u root -p </code></p><p>所以测试远程访问时，查到自己电脑的ip，我的为<code>10.24.167.173</code>。使用<code>mysql -h 127.0.0.1 -P 3306 -u root -p</code>即可成功使用预设密码访问。</p><p>注：此处使用自己电脑测试，但是使用非本地ip，即可达到测试效果。如果使用别人电脑，需要保证两个电脑处在相同局域网下，保证ip可以互相ping通。</p><p>测试结果如下：</p><img src="/2024/07/05/SQL-hw1/image-20221005115355290.png" class="" title="banner"><h2 id="二、在school数据库中完成以下练习"><a href="#二、在school数据库中完成以下练习" class="headerlink" title="二、在school数据库中完成以下练习"></a>二、在school数据库中完成以下练习</h2><ul><li>创建数据库<pre><code>mysql&gt; create database school;</code></pre></li><li>进入数据库：<pre><code>mysql&gt; use school;</code></pre></li></ul><h4 id="2-1-创建上述表，并定义相应的完整性约束。"><a href="#2-1-创建上述表，并定义相应的完整性约束。" class="headerlink" title="2.1  创建上述表，并定义相应的完整性约束。"></a>2.1  创建上述表，并定义相应的完整性约束。</h4><h6 id="2-1-1-一些针对可能出现的数据库版本标准不同的补充说明：-在mysql8-0-28下"><a href="#2-1-1-一些针对可能出现的数据库版本标准不同的补充说明：-在mysql8-0-28下" class="headerlink" title="2.1.1 一些针对可能出现的数据库版本标准不同的补充说明：(在mysql8.0.28下)"></a>2.1.1 一些针对可能出现的数据库版本标准不同的补充说明：(在mysql8.0.28下)</h6><ul><li><p>mysql&gt;=5.5.49的版本，字符集是utf-8下，char(10)和varchar(10)存储的汉字和英文的数量都是10个</p></li><li><p>mysql8.0，默认属性的设置可以不使用枚举，使用check约束：<code>check ((性别 = &#39;男&#39;) or (性别 = &#39;女&#39;))</code></p></li></ul><h6 id="2-1-2-建表："><a href="#2-1-2-建表：" class="headerlink" title="2.1.2 建表："></a>2.1.2 建表：</h6><p>由于存在外码依赖，建表顺序为：系表-&gt;课程表-&gt;学生表-&gt;选课表。</p><blockquote><p>系表（系号，系名，系主任），其中系号是主码，系名不能有重复的。</p></blockquote><pre><code class="sql">create table 系表(系号 int not null,系名 varchar(10) unique,系主任 varchar(3),primary key(系号));</code></pre><blockquote><p>课程表（课程号，课程名，先修课，学分），课程号是主码，课程名必须唯一，学分必须大于0小于5。</p></blockquote><pre><code class="sql">create table 课程表(课程号 char(3) not null,课程名 varchar(8) unique,先修课 char(3),学分 int,primary key(课程号),check (学分 &gt; 0 and 学分 &lt; 5));</code></pre><p>对于课程表建表的说明：</p><ul><li><code>check (学分 &gt; 0 and 学分 &lt; 5)</code>使用check约束时可以不命名，数据库会自动为check约束命名。但是后续修改约束时不方便。详见题目2.7的说明。</li><li>mysql8.0也可以建表时为约束命名，使用<code>constraint</code>关键字，例如<code>constraint 学分约束 check (学分 &gt; 0 and 学分 &lt; 5)</code>，<code>学分约束</code>为对此check约束的命名。</li><li>为避免中文属性乱码等问题，字符集设置成utf8。已在修改<code>my.ini</code>配置文件修改。</li></ul><blockquote><p>学生表（学号，姓名，性别，年龄，入学年份，籍贯，系号，班长学号），学号是主码，系号和班长学号是外部码，手机号码必须唯一，学生的年龄不得小于10岁和大于50岁，性别必须是’男’或者’女’。</p></blockquote><pre><code class="sql">create table 学生表(学号 varchar(4) not null,姓名 varchar(3),性别 char(1),年龄 int,入学年份 varchar(4),籍贯 char(2),系号 int,班长学号 varchar(4),手机号码 char(11),primary key(学号),foreign key (系号) references 系表(系号),unique(手机号码),check (年龄 &gt;=10 and 年龄 &lt;=50),check ((性别 = &#39;男&#39;) or (性别 = &#39;女&#39;)));</code></pre><p>对于学生表建表的说明：</p><ul><li><p>学号和入学年份设置<code>varchar</code>因为后续题目需要插入其他长度的数据。也可以此处设置为var定长，后续需要使用变长时再使用<code>alter table 学生表 modify column 学号 varchar(4);</code>语句，修改类型为<code>varchar</code>。</p></li><li><p>由于后续导入数据时，发现对于**”学生表”<strong>和</strong>“系表”<strong>中，对 <strong>‘系号’</strong> 的前导零处理不一致。如果把</strong>‘系号’**设置为varchar类型，无法把’6’和’06’识别为同系，导致导入数据时，大量数据会违背系号的外码约束<code>foreign key (系号) references 系表(系号)</code>而不被导入。所以此处系号选择<code>int</code>类型。</p></li><li><p>unique约束  <code>unique(手机号码)</code>  需要数据表中存在<code>手机号码</code>属性，故加入属性<code>手机号码 char(11)</code>。</p></li><li><p>此处建表时，舍去设置**’班长学号’**的外码约束<code>foreign key (班长学号)references 学生表(学号)</code>：</p><ul><li>此处为导入数据时，发现如果建表时，预先设置此**’班长学号’**外码约束，会出现对按行导入数据时，数据的先后顺序要求。（如果学生A的班长B在学生A的数据之后出现，则在导入学生A时，其违背了外码约束（班长B的数据还尚未被导入，未在学生表的主码中出现），故数据A不会被导入，发生错误。</li><li>原因是**’班长学号’<strong>和其主码</strong>‘学号’<strong>都在</strong>“学生表”**数据表中。</li><li>解决方案是，对于主码外码在一个表里的情况，先建表，并导入数据，导入数据之后再使用<code>alter table 学生表  add constraint  学生班长外码约束 foreign key (班长学号) references 学生表(学号);</code>添加外码约束。</li></ul></li><li><p>mysql8.0，默认属性的设置可以不使用枚举，使用check约束：<code>check ((性别 = &#39;男&#39;) or (性别 = &#39;女&#39;))</code></p></li></ul><blockquote><p>选课表（学号，课程号，成绩），（学号，课程号）是主码，学号和课程号是外部码，成绩不能小于0分和大于100分</p></blockquote><pre><code class="mysql">create table 选课表(学号 varchar(6) not null,课程号 char(3) not null,成绩 numeric(4,1),primary key (学号,课程号),foreign key (学号) references 学生表(学号),foreign key (课程号) references 课程表(课程号),check (成绩 &lt;= 100 and 成绩 &gt;= 0));</code></pre><ul><li>numeric(4,1)是3位整数,精确到一位小数,最多4位,四舍五入</li></ul><h5 id="2-2-导入数据与对错误数据的分析"><a href="#2-2-导入数据与对错误数据的分析" class="headerlink" title="2.2  导入数据与对错误数据的分析"></a>2.2  导入数据与对错误数据的分析</h5><h6 id="2-2-1-一种导入数据的方法"><a href="#2-2-1-一种导入数据的方法" class="headerlink" title="2.2.1 一种导入数据的方法"></a>2.2.1 一种导入数据的方法</h6><ul><li><p>把excel的多个sheet分别另存为<code>.csv</code>格式。（此时.csv内字符串的前导0均不显示，如果使用txt打开可正常显示前导0，说明没有问题。否则可能是在csv内对源数据进行了改动，需要把源数据重新复制进.csv）</p></li><li><p>把.csv的第一行属性名删除。（或者稍后的sql导入语句添加<code>ignore 1 lines</code>，忽略第一行属性名的导入）</p></li><li><p>把.csv使用txt打开，把其ANSI格式另存为utf8格式。（注：每次对.csv使用excel视图修改后，均需要转换为utf8格式）。</p></li><li><p>保证启动数据库时使用<code>--local-infile</code>参数：<code>mysql -h 127.0.0.1 -P 3306 -u root -p --local-infile</code>。</p><blockquote><p>否则导入本地数据可能出现报错：</p><p>ERROR 3948 (42000): Loading local data is disabled; this must be enabled on both the client and server sides</p></blockquote></li><li><p>导入命令：</p><pre><code class="sql">load data local infile &#39;C:\\Users\\Musel\\Desktop\\xueshengbiao.csv&#39; into table 学生表 fields terminated by &#39;,&#39; ;# 如果没有在.csv内删除第一行属性名，需要加入 ignore 1 lines# 此处可以不加行分隔符&#39;\n&#39;的命令，也可以正常识别换行并导入</code></pre></li></ul><h6 id="2-2-2-对错误数据的分析"><a href="#2-2-2-对错误数据的分析" class="headerlink" title="2.2.2 对错误数据的分析"></a>2.2.2 对错误数据的分析</h6><p>第一次使用上述命令导入学生表等数据后，发现<code>skipped</code>了大量数据，没有合法数据被加进学生表。选课表也存在一定问题。</p><p>使用<code>show warnings;</code>查看warnings提示。</p><p>发现的错误数据的类型如下：</p><ul><li><p>导入数据时，发现对于**”学生表”<strong>和</strong>“系表”<strong>中，对 <strong>‘系号’</strong> 的前导零处理不一致。如果把</strong>‘系号’**设置为varchar类型，无法把’6’和’06’识别为同系，导致导入数据时，大量数据会违背系号的外码约束<code>foreign key (系号) references 系表(系号)</code>而不被导入。所以此处系号选择<code>int</code>类型。</p></li><li><p>导入数据时，发现如果建表时，预先设置此**’班长学号’**外码约束，会出现对按行导入数据时，数据的先后顺序要求。（如果学生A的班长B在学生A的数据之后出现，则在导入学生A时，其违背了外码约束（班长B的数据还尚未被导入，未在学生表的主码中出现），故数据A不会被导入，发生错误。</p><ul><li>原因是**’班长学号’<strong>和其主码</strong>‘学号’<strong>都在</strong>“学生表”**数据表中。</li><li>解决方案是，对于主码外码在一个表里的情况，先建表，并导入数据，导入数据之后再使用<code>alter table 学生表  add constraint  学生班长外码约束 foreign key (班长学号) references 学生表(学号);</code>添加外码约束。</li></ul></li><li><p>修改上面两个问题后，可以成功导入所有学生表数据。</p><ul><li><p>如果使用<code>alter table 学生表  add constraint  学生班长外码约束 foreign key (班长学号) references 学生表(学号);</code>添加外码约束时，发现报错：</p><blockquote><p>ERROR: Cannot add or update a child row: a foreign key constraint fails…</p></blockquote></li><li><p>原因：使用<code>select * from 学生表</code>，发现**’班长学号’**列，存在空字符串””。空字符串和NULL并不是相等的。外码允许NULL，但是主码中没有””空字符串的学号。</p><p>使用<code>update 学生表 set 班长学号=NULL where 学号=&#39;0202&#39;;</code>命令把0202，0301，0402三个空字符串都改成NULL值，就可以使用<code>alter table 学生表  add constraint  学生班长外码约束 foreign key (班长学号) references 学生表(学号);</code>添加外码约束了。</p></li></ul></li><li><p>对于选课表，有四条数据主键重复，只导入了各自重复主键的第一条数据。数据库跳过重复主键，未报错。</p></li><li><p>有两条数据的学号外码在学生表中不存在，数据库跳过这两条数据，未报错。</p></li></ul><h5 id="2-3-在学生表中插入学号为26，姓名为’李四’，性别为’女’，年龄为20，入学年份为2008，籍贯为’广东’，手机号码为10010001000，班长学号为10的一条记录"><a href="#2-3-在学生表中插入学号为26，姓名为’李四’，性别为’女’，年龄为20，入学年份为2008，籍贯为’广东’，手机号码为10010001000，班长学号为10的一条记录" class="headerlink" title="2.3 在学生表中插入学号为26，姓名为’李四’，性别为’女’，年龄为20，入学年份为2008，籍贯为’广东’，手机号码为10010001000，班长学号为10的一条记录"></a>2.3 在学生表中插入学号为26，姓名为’李四’，性别为’女’，年龄为20，入学年份为2008，籍贯为’广东’，手机号码为10010001000，班长学号为10的一条记录</h5><ul><li>没有学号10的班长，所以添加：<code>insert into 学生表(学号) values(&#39;10&#39;);</code></li><li>如果char类型不是变长，<code>alter table 学生表 modify column 学号 varchar(4);</code></li><li>如果没有手机号列，添加：<code>alter table 学生表 add 手机号码 char(11);</code></li></ul><pre><code class="sql">insert into 学生表 (学号,姓名,性别,年龄,入学年份,籍贯,班长学号,手机号码) values(&#39;26&#39;,&#39;李四&#39;,&#39;女&#39;,20,&#39;2008&#39;,&#39;广东&#39;,&#39;10&#39;,&#39;10010001000&#39;);</code></pre><h5 id="2-4-删除上述记录"><a href="#2-4-删除上述记录" class="headerlink" title="2.4 删除上述记录"></a>2.4 删除上述记录</h5><pre><code class="sql">delete from 学生表 where 学号=&#39;26&#39;;</code></pre><h5 id="2-5-将学生表中的姓名字段的长度改为6个汉字"><a href="#2-5-将学生表中的姓名字段的长度改为6个汉字" class="headerlink" title="2.5 将学生表中的姓名字段的长度改为6个汉字"></a>2.5 将学生表中的姓名字段的长度改为6个汉字</h5><pre><code class="sql">alter table 学生表 modify column 姓名 varchar(6);</code></pre><h5 id="2-6-为学生表增加一个字段电子邮件，20个字符"><a href="#2-6-为学生表增加一个字段电子邮件，20个字符" class="headerlink" title="2.6 为学生表增加一个字段电子邮件，20个字符"></a>2.6 为学生表增加一个字段电子邮件，20个字符</h5><pre><code class="sql">alter table 学生表 add 电子邮件 varchar(20);</code></pre><h5 id="2-7-对课程表的学分字段上的完整性约束进行修改，使其在0到6之间取值"><a href="#2-7-对课程表的学分字段上的完整性约束进行修改，使其在0到6之间取值" class="headerlink" title="2.7 对课程表的学分字段上的完整性约束进行修改，使其在0到6之间取值"></a>2.7 对课程表的学分字段上的完整性约束进行修改，使其在0到6之间取值</h5><pre><code class="sql"># 先删除旧约束。再添加新约束# 由于初始化建表时没有对check约束显式命名，mysql默认为其命名# 所以需要先获取约束的默认名字insert into 课程表 values(&#39;c09&#39;,&#39;xx&#39;,&#39;c01&#39;,9);&gt; ERROR 3819 (HY000): Check constraint &#39;课程表_chk_1&#39; is violated.# 删除约束alter table 课程表 drop constraint 课程表_chk_1; # 添加新约束alter table 课程表 add constraint 课程学分check check(学分&gt;0 and 学分&lt;6);</code></pre><h5 id="2-8-为学生表在学号列上创建cluster索引"><a href="#2-8-为学生表在学号列上创建cluster索引" class="headerlink" title="2.8 为学生表在学号列上创建cluster索引"></a>2.8 为学生表在学号列上创建cluster索引</h5><p>mysql默认为主键建立聚簇索引，使用<code>show index</code>查看</p><pre><code class="sql">show index from 学生表;</code></pre><p>或者创建：</p><pre><code class="mysql">create index cluster on 学生表(学号);</code></pre><img src="/2024/07/05/SQL-hw1/image-20221002000616195.png" class="" title="banner"><h5 id="2-9-创建一个视图，计算每门课的最高分"><a href="#2-9-创建一个视图，计算每门课的最高分" class="headerlink" title="2.9 创建一个视图，计算每门课的最高分"></a>2.9 创建一个视图，计算每门课的最高分</h5><pre><code class="sql">create view 课程最高分 as select 课程号,max(成绩) as 最高分 from 选课表group by 课程号;</code></pre><h5 id="2-10-查找每个学生的学号、姓名、总成绩和平均分"><a href="#2-10-查找每个学生的学号、姓名、总成绩和平均分" class="headerlink" title="2.10 查找每个学生的学号、姓名、总成绩和平均分"></a>2.10 查找每个学生的学号、姓名、总成绩和平均分</h5><pre><code class="sql">select 学生表.学号,姓名,sum(成绩) as 总成绩,avg(成绩) as 平均分from 学生表,选课表where 学生表.学号=选课表.学号group by 学生表.学号;</code></pre><h5 id="2-11-将6系所有学生的年龄，改为7系学生的平均年龄"><a href="#2-11-将6系所有学生的年龄，改为7系学生的平均年龄" class="headerlink" title="2.11 将6系所有学生的年龄，改为7系学生的平均年龄"></a>2.11 将6系所有学生的年龄，改为7系学生的平均年龄</h5><ul><li>没有7系学生? null了</li></ul><pre><code class="sql"># 错误写法：update 学生表 set 年龄 = (select avg(年龄) from 学生表 where 系号=7 ) where 系号=6;&gt; &quot;You can&#39;t specify target table &#39;学生表&#39; for update in FROM clause&quot;# 如果修改数据，需要为查询结果建立子表update 学生表 set 年龄 = (select tmp.平均年龄     from(        select avg(年龄) as 平均年龄 from 学生表 where 系号 = 7     )tmp ) where 系号=6;</code></pre><h5 id="2-12-将’曹洪’同学操作系统课程的成绩改为62分"><a href="#2-12-将’曹洪’同学操作系统课程的成绩改为62分" class="headerlink" title="2.12 将’曹洪’同学操作系统课程的成绩改为62分"></a>2.12 将’曹洪’同学操作系统课程的成绩改为62分</h5><pre><code class="sql">update 选课表 set 成绩=62where (学号=(select 学号 from 学生表 where 姓名=&#39;曹洪&#39;) and 课程号=(select 课程号 from 课程表 where 课程名=&#39;操作系统&#39;));</code></pre><h5 id="2-13-查找所有学生的姓名、入学年份和籍贯"><a href="#2-13-查找所有学生的姓名、入学年份和籍贯" class="headerlink" title="2.13 查找所有学生的姓名、入学年份和籍贯"></a>2.13 查找所有学生的姓名、入学年份和籍贯</h5><pre><code class="sql">select 姓名,入学年份,籍贯 from 学生表;</code></pre><h5 id="2-14-列出籍贯为’山东’的同学的所有属性"><a href="#2-14-列出籍贯为’山东’的同学的所有属性" class="headerlink" title="2.14 列出籍贯为’山东’的同学的所有属性"></a>2.14 列出籍贯为’山东’的同学的所有属性</h5><pre><code class="sql">select * from 学生表 where 籍贯=&#39;山东&#39;;</code></pre><h5 id="2-15-查找年龄最小的学生的学号和姓名"><a href="#2-15-查找年龄最小的学生的学号和姓名" class="headerlink" title="2.15 查找年龄最小的学生的学号和姓名"></a>2.15 查找年龄最小的学生的学号和姓名</h5><pre><code class="sql">select 学号,姓名 from 学生表 where 年龄 = (select min(年龄) from 学生表);</code></pre><h5 id="2-16-查找选修了’数据库’的学生的学号"><a href="#2-16-查找选修了’数据库’的学生的学号" class="headerlink" title="2.16 查找选修了’数据库’的学生的学号"></a>2.16 查找选修了’数据库’的学生的学号</h5><pre><code class="sql">select 学号 from 选课表 where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;数据库&#39;);</code></pre><ul><li>因为课程名可能不唯一，所以可能select到多个同名课程号，应该用in<h5 id="2-17-查找选修了’编译技术’的女学生的学号和姓名"><a href="#2-17-查找选修了’编译技术’的女学生的学号和姓名" class="headerlink" title="2.17 查找选修了’编译技术’的女学生的学号和姓名"></a>2.17 查找选修了’编译技术’的女学生的学号和姓名</h5><pre><code class="sql">select 学号,姓名 from 学生表 where 性别 = &#39;女&#39; and 学号 in   (select 学号 from 选课表   where 课程号 in       (select 课程号 from 课程表 where 课程名=&#39;编译技术&#39;)); </code></pre></li></ul><h5 id="2-18-查找’典韦’同学的班长所选修的课程的课程号"><a href="#2-18-查找’典韦’同学的班长所选修的课程的课程号" class="headerlink" title="2.18 查找’典韦’同学的班长所选修的课程的课程号"></a>2.18 查找’典韦’同学的班长所选修的课程的课程号</h5><pre><code class="sql">select 课程号 from 选课表where 学号 in (select 班长学号 from 学生表 where 姓名 = &#39;典韦&#39;) ;</code></pre><h5 id="2-19-查找名字中倒数第二字为’侯’的学生的学号、姓名和所在系的系名"><a href="#2-19-查找名字中倒数第二字为’侯’的学生的学号、姓名和所在系的系名" class="headerlink" title="2.19 查找名字中倒数第二字为’侯’的学生的学号、姓名和所在系的系名"></a>2.19 查找名字中倒数第二字为’侯’的学生的学号、姓名和所在系的系名</h5><pre><code class="sql">select 学号,姓名,系名 from 学生表,系表where 姓名 like &#39;%侯_&#39;and 系表.系号 = 学生表.系号;# 或者正则：select 学号,姓名,系名 from 学生表,系表where 姓名 REGEXP &#39;侯[:alpha:]&#123;1&#125;$&#39;and 系表.系号 = 学生表.系号;</code></pre><h5 id="2-20-查找名字以P打头，倒数第三字为L的课程的名字"><a href="#2-20-查找名字以P打头，倒数第三字为L的课程的名字" class="headerlink" title="2.20 查找名字以P打头，倒数第三字为L的课程的名字"></a>2.20 查找名字以P打头，倒数第三字为L的课程的名字</h5><pre><code class="sql">select 课程名 from 课程表where 课程名 REGEXP &#39;P[:alpha:]*L[:alpha:]&#123;2&#125;&#39;;</code></pre><h5 id="2-21-查找’甘宁’同学所有选修课程的总分"><a href="#2-21-查找’甘宁’同学所有选修课程的总分" class="headerlink" title="2.21 查找’甘宁’同学所有选修课程的总分"></a>2.21 查找’甘宁’同学所有选修课程的总分</h5><pre><code class="sql">select sum(成绩) from 选课表where 学号 in (select 学号 from 学生表 where 姓名=&#39;甘宁&#39;);</code></pre><h5 id="2-22-查找既选修了’数据库’，也选修了’操作系统’的同学"><a href="#2-22-查找既选修了’数据库’，也选修了’操作系统’的同学" class="headerlink" title="2.22 查找既选修了’数据库’，也选修了’操作系统’的同学"></a>2.22 查找既选修了’数据库’，也选修了’操作系统’的同学</h5><pre><code class="sql">select * from 学生表where 学号 in ( select 学号 from 选课表    where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;操作系统&#39;)and 学号 in (select 学号 from 选课表     where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;数据库&#39;)));</code></pre><h5 id="2-23-查找没有选修’数据库’课程的学生的学号和姓名"><a href="#2-23-查找没有选修’数据库’课程的学生的学号和姓名" class="headerlink" title="2.23 查找没有选修’数据库’课程的学生的学号和姓名"></a>2.23 查找没有选修’数据库’课程的学生的学号和姓名</h5><pre><code class="sql">select 学号,姓名 from 学生表where not exists    (select * from 选课表         where 学号 = 学生表.学号         and 课程号 = (select 课程号 from 课程表 where 课程名=&#39;数据库&#39;));</code></pre><h5 id="2-24-查找’数据库’课程及格了，但’编译技术’没有及格的学生的学号和姓名"><a href="#2-24-查找’数据库’课程及格了，但’编译技术’没有及格的学生的学号和姓名" class="headerlink" title="2.24 查找’数据库’课程及格了，但’编译技术’没有及格的学生的学号和姓名"></a>2.24 查找’数据库’课程及格了，但’编译技术’没有及格的学生的学号和姓名</h5><pre><code class="sql">select 学号,姓名 from 学生表where 学号 in (select 学号 from 选课表    where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;数据库&#39;)    and 成绩&gt;=60    and 学号 in (select 学号 from 选课表         where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;编译技术&#39;)         and 成绩&lt;60    ));</code></pre><h5 id="2-25-查找数据库成绩低于数据库课平均成绩的同学的学号和姓名"><a href="#2-25-查找数据库成绩低于数据库课平均成绩的同学的学号和姓名" class="headerlink" title="2.25 查找数据库成绩低于数据库课平均成绩的同学的学号和姓名"></a>2.25 查找数据库成绩低于数据库课平均成绩的同学的学号和姓名</h5><pre><code class="sql">select 学号,姓名 from 学生表where 学号 in (select 学号 from 选课表    where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;数据库&#39;)    and 成绩 &lt; (select avg(成绩) from 选课表        where 课程号 in (select 课程号 from 课程表 where 课程名=&#39;数据库&#39;)));</code></pre><h5 id="2-26-查找与’貂蝉’同学选修课程完全相同的学生的学号和姓名（不能多选也不能少选）"><a href="#2-26-查找与’貂蝉’同学选修课程完全相同的学生的学号和姓名（不能多选也不能少选）" class="headerlink" title="2.26 查找与’貂蝉’同学选修课程完全相同的学生的学号和姓名（不能多选也不能少选）"></a>2.26 查找与’貂蝉’同学选修课程完全相同的学生的学号和姓名（不能多选也不能少选）</h5><pre><code class="sql"># ==Select 学号,姓名 From 学生表    Where Not Exists     # 这个select语句的返回值：对于每个貂蝉选的课程，如果返回值为真，把这个课程作为select返回的集合里的课程        (Select * from             (select * from 课程表 where 课程号 in                 (select 课程号 from 选课表 where 学号=                    (select 学号 from 学生表 where 姓名=&#39;貂蝉&#39;)))             as tmp            # 对于（学号，课程号）的元组，选课表里有不存在的值。            # 等价于：            # 以下语句的返回值：是否找到【（这个学生）没选的（貂蝉课表里有的课）】这样的元组            Where Not Exists                (Select * from 选课表                    Where 学号=学生表.学号                     And 课程号=tmp.课程号)            )    and Not Exists     # 这个select语句的返回值：对于每个貂蝉 没 选的课程，如果返回值为真，把这个课程作为select返回的集合里的课程        (Select * from             (select * from 课程表 where not exists                (select 课程号 from 选课表 where (课程号 = 课程表.课程号)                    and 学号= (select 学号 from 学生表 where 姓名=&#39;貂蝉&#39;)))            as tmp2            # 对于（学号，课程号）的元组，选课表里有 存在 的值。            # 等价于：            # 以下语句的返回值：是否找到【（这个学生）选的（貂蝉课表里 没有 的课）】这样的元组            Where Exists                (Select * from 选课表                    Where 学号=学生表.学号                     And 课程号=tmp2.课程号)            );</code></pre><h5 id="2-27-查找不仅选修了’貂蝉’同学选修的课程，而且还选修了其他课程的同学"><a href="#2-27-查找不仅选修了’貂蝉’同学选修的课程，而且还选修了其他课程的同学" class="headerlink" title="2.27 查找不仅选修了’貂蝉’同学选修的课程，而且还选修了其他课程的同学"></a>2.27 查找不仅选修了’貂蝉’同学选修的课程，而且还选修了其他课程的同学</h5><pre><code class="sql"># &gt;=Select 学号,姓名 From 学生表    Where Not Exists     # 这个select语句的返回值：对于每个貂蝉选的课程，如果返回值为真，把这个课程作为select返回的集合里的课程        (Select * from             (select * from 课程表 where 课程号 in                 (select 课程号 from 选课表 where 学号=                    (select 学号 from 学生表 where 姓名=&#39;貂蝉&#39;)))             as tmp            # 对于（学号，课程号）的元组，选课表里有不存在的值。            # 等价于：            # 以下语句的返回值：是否找到【（这个学生）没选的（貂蝉课表里有的课）】这样的元组            Where Not Exists                (Select * from 选课表                    Where 学号=学生表.学号                     And 课程号=tmp.课程号)            )    and Exists     # 这个select语句的返回值：对于每个貂蝉 没 选的课程，如果返回值为真，把这个课程作为select返回的集合里的课程        (Select * from             (select * from 课程表 where not exists                (select 课程号 from 选课表 where (课程号 = 课程表.课程号)                    and 学号= (select 学号 from 学生表 where 姓名=&#39;貂蝉&#39;)))              as tmp2            # 对于（学号，课程号）的元组，选课表里有 存在 的值。            # 等价于：            # 以下语句的返回值：是否找到【（这个学生）选的（貂蝉课表里 没有 的课）】这样的元组            Where Exists                (Select * from 选课表                    Where 学号=学生表.学号                     And 课程号=tmp2.课程号)            );</code></pre><h5 id="2-28-查找’高等数学’平均成绩最高的系的系名"><a href="#2-28-查找’高等数学’平均成绩最高的系的系名" class="headerlink" title="2.28 查找’高等数学’平均成绩最高的系的系名"></a>2.28 查找’高等数学’平均成绩最高的系的系名</h5><ul><li>没有高等数学，只有数学？<br>```sql<h1 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h1><h1 id="先建立-平均分，系号-视图"><a href="#先建立-平均分，系号-视图" class="headerlink" title="先建立(平均分，系号)视图"></a>先建立(平均分，系号)视图</h1>create view 系平均分视图 as<br>select avg(成绩) as 平均分,系号 from 选课表,学生表<br>where 课程号 in (select 课程号 from 课程表 where 课程名 = ‘数学’)<br>and 选课表.学号=学生表.学号<br>group by 系号</li></ul><h1 id="再从视图上找最高分对应的系"><a href="#再从视图上找最高分对应的系" class="headerlink" title="再从视图上找最高分对应的系"></a>再从视图上找最高分对应的系</h1><p>select 系名 from 系表<br>where 系号 =<br>    (select 系号 from 系平均分视图<br>    where 平均分 = (select max(平均分) from 系平均分视图);</p><h1 id="方法二：写在一条语句，不过方法一的视图需要作为子表tmp，并且创建两次"><a href="#方法二：写在一条语句，不过方法一的视图需要作为子表tmp，并且创建两次" class="headerlink" title="方法二：写在一条语句，不过方法一的视图需要作为子表tmp，并且创建两次"></a>方法二：写在一条语句，不过方法一的视图需要作为子表tmp，并且创建两次</h1><p>select 系名 from 系表<br>where 系号=<br>    (select 系号 from<br>        # 第一次创建子表tmp(平均分，系号)<br>        (select avg(成绩) as 平均分,系号 from 选课表,学生表<br>        where 课程号 in (select 课程号 from 课程表 where 课程名 = ‘数学’)<br>        and 选课表.学号=学生表.学号<br>        group by 系号) as tmp</p><pre><code>where 平均分 =     (select max(平均分) from         # 第二次创建子表tmp(平均分，系号)        (select avg(成绩) as 平均分,系号 from 选课表,学生表         where 课程号 in (select 课程号 from 课程表 where 课程名 = &#39;数学&#39;)         and 选课表.学号=学生表.学号        group by 系号) as tmp));</code></pre><pre><code>##### 2.29 查找至少有一个籍贯为&#39;四川&#39;同学所选修课程的课程名- 没有四川人?```sqlselect distinct 课程名 from 课程表,选课表where 学号 in(select 学号 from 学生表 where 籍贯 = &#39;四川&#39;)and 课程表.课程号 = 选课表.课程号;# 或者select distinct 课程名 from 课程表,选课表where exists(select * from 学生表 where 籍贯 = &#39;安徽&#39; and 学生表.学号 = 选课表.学号)and 课程表.课程号 = 选课表.课程号;# 一开始写的exists语句忘了写两个表格的学号约束，错误地返回了所有数据# select distinct 课程名 from 课程表,选课表# where exists# (select * from 学生表 where 籍贯 = &#39;安徽&#39;)# and 课程表.课程号 = 选课表.课程号;</code></pre><h5 id="2-30-查询选修了’数据库’课程的学生的学号和获得的学分"><a href="#2-30-查询选修了’数据库’课程的学生的学号和获得的学分" class="headerlink" title="2.30 查询选修了’数据库’课程的学生的学号和获得的学分"></a>2.30 查询选修了’数据库’课程的学生的学号和获得的学分</h5><pre><code class="sql">select 学号,学分 from 选课表,课程表where 选课表.课程号 = (select 课程号 from 课程表 where 课程名 = &#39;数据库&#39;)and 选课表.课程号=课程表.课程号;# 记得写表名  选课表.课程号# 记得写连接约束</code></pre><h2 id="三、回答问题"><a href="#三、回答问题" class="headerlink" title="三、回答问题"></a>三、回答问题</h2><h5 id="3-1-SQL语言的特点"><a href="#3-1-SQL语言的特点" class="headerlink" title="3.1 SQL语言的特点"></a>3.1 SQL语言的特点</h5><ol><li>综合统一：集数据定义，数据操纵，数据查询和数据控制于一体。单一的结构——关系，带来了数据操作符的统一。</li><li>高度非过程化：用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径。</li><li>面向集合的操作方式：操作的对象和操作的结果均为集合。</li><li>以同一种语法结构提供两种使用方式：SQL既是自含式语言，又是嵌入式语言</li><li>语言简捷，易学易用：类似于英语自然语言</li></ol><h5 id="3-2-完整性约束"><a href="#3-2-完整性约束" class="headerlink" title="3.2 完整性约束"></a>3.2 完整性约束</h5><ol><li>NOT NULL：非空约束：字段的值不能为空</li><li>UNIQUE：唯一约束：指所有记录中字段的值不能重复出现</li><li>PRIMARY KEY：主码约束，唯一约束 + 非空约束</li><li>FOREIGN KEY：外码约束：用于限制两个表的关系，保证从表该字段的值必须来自于主表相关联的字段的值</li><li>CHECK：mysql8.0新特性，约束表中的某个字段或者一些字段必须满足某个条件。</li></ol><h5 id="3-3-自然连接和等值连接有什么差别"><a href="#3-3-自然连接和等值连接有什么差别" class="headerlink" title="3.3 自然连接和等值连接有什么差别"></a>3.3 自然连接和等值连接有什么差别</h5><ul><li>等值连接是WHERE子句中用来连接两个表的连接条件的连接符是=。连接条件的各连接字段类型必须可比。</li><li>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。</li></ul><p><a href="https://developer.aliyun.com/article/879135">https://developer.aliyun.com/article/879135</a></p><h5 id="3-4-子查询分为哪几种？它们之间有什么区别"><a href="#3-4-子查询分为哪几种？它们之间有什么区别" class="headerlink" title="3.4 子查询分为哪几种？它们之间有什么区别"></a>3.4 子查询分为哪几种？它们之间有什么区别</h5><ul><li><p>不相关子查询<br>不相关子查询的执行顺序是由内向外，即每个子查询在上一级查询处理前求解，子查询的结果集合作为其外部查询的检索条件的条件值。</p></li><li><p>相关子查询<br>相关子查询的查询条件引用了其外部查询的某个属性值，从而其执行依赖于其外部查询。</p></li><li><p>区别：子查询的查询条件是否依赖父查询。</p></li></ul><h5 id="3-5-索引有什么作用和缺点"><a href="#3-5-索引有什么作用和缺点" class="headerlink" title="3.5 索引有什么作用和缺点"></a>3.5 索引有什么作用和缺点</h5><p>作用：加快查询速度，提供多种存取路径。</p><p>缺点：占用一定存储空间。基本表更新时，索引要进行维护。</p><h5 id="3-6-基本表和视图有什么区别？视图有什么优点？什么样的视图是可以更新的？"><a href="#3-6-基本表和视图有什么区别？视图有什么优点？什么样的视图是可以更新的？" class="headerlink" title="3.6 基本表和视图有什么区别？视图有什么优点？什么样的视图是可以更新的？"></a>3.6 基本表和视图有什么区别？视图有什么优点？什么样的视图是可以更新的？</h5><ul><li><p>视图是从一个表或者几个基本表（视图）中导出的表。与基本表不同，是一个虚表。数据库只存放视图的定义，不存放视图对应的数据。基本表的数据发生变化，视图查询出的数据随之改变。</p></li><li><p>视图的优点：</p><ul><li>简化用户的操作</li><li>以多种角度看待同一数据</li><li>对重构数据库提供了一定程度的逻辑独立性</li><li>对机密数据提供安全保护</li></ul></li><li><p>行列子集视图可以更新。行列子视图：从单个基本表导出的视图，并且只是去掉了基本表的某些行和某些列，但保留了主码。</p></li></ul><h5 id="3-7-请针对第三章SQL语言讲义中的除法例子，给出其他两种除法的实现方法"><a href="#3-7-请针对第三章SQL语言讲义中的除法例子，给出其他两种除法的实现方法" class="headerlink" title="3.7 请针对第三章SQL语言讲义中的除法例子，给出其他两种除法的实现方法"></a>3.7 请针对第三章SQL语言讲义中的除法例子，给出其他两种除法的实现方法</h5><img src="/2024/07/05/SQL-hw1/image-20221003092905898.png" class="" title="banner"><ul><li><p>第三章讲义的除法例子：查询选修了全部课程的学生姓名</p><p>关系代数运算：$\prod _{Sno,Cno}(SC)÷\prod _{Cno}(COURSE)\bowtie\prod _{Sno,SName}(STUDENT)$</p></li><li><p>方法一：双<code>not exists</code>法</p><pre><code class="sql">Select Sname From STUDENT    Where Not Exists           (Select * from COURSE              Where Not Exists                  (Select * from SC                     Where Sno=STUDENT.Sno                           And Cno=COURSE.Cno));</code></pre></li></ul><blockquote><p>方法二和三的注释中，对于定义中的<code>设关系R（X，Y）与关系S（Z），其中Y和Z具有相同的属性数，且对应属性出自相同域</code>，</p><p>称域X为被除表的独有属性</p><p>域Y为被除表的共有属性</p><p>域Z为除表的共有属性</p></blockquote><ul><li><p>方法二：<code>Count(*)</code>法</p><p>count(*)做除法的条件：被除表的共有属性 与 除表的共有属性，应当是外部码关系，或者至少二者可以满足构成外部码的约束。</p><p>也就是对于定义<code>设关系R（X，Y）与关系S（Z），其中Y和Z具有相同的属性数，且对应属性出自相同域</code>，要保证$Y\subseteq  Z$</p></li></ul><pre><code class="sql">Select Sname From STUDENTwhere Sno in (    Select Sno from SC group by Sno    having count(Sno) = ( select count(*) from COURSE ));</code></pre><ul><li><p>方法三：定义法</p><blockquote><p>定义：设关系R（X，Y）与关系S（Z），其中Y和Z具有相同的属性数，且对应属性出自相同域。关系R除以关系S所得的商关系是关系R在属性X上投影的一个子集，该子集和 S（Z）的笛卡儿积必须包含在R（X，Y）中。<br>记为：$R÷S={t;|;t \in {x}(R) ;;\wedge;;s \in S ;;\wedge;; &lt;t,s&gt; \in R }$</p></blockquote><p>域X和域Z 做广义笛卡尔积，如果新乘出来得到的新元组值在原来的关系集合R里，这个值保留进除法得到的结果里。</p></li></ul><pre><code class="sql"># 与学生表做连接，得到姓名Select Sname From STUDENTwhere Sno in (# select出 被除表中 做除法剩下的 独有属性select Sno From SCwhere Sno not in(    # select出 被除表中 应该被除掉的 独有属性    select Sno from    # 【被除表的独有属性】投影 与 【除表的共有属性】投影 做广义笛卡尔积    # 得到子表 b1    (select Sno from SC as a1    cross join    select Cno from COURSE as a2) as b1    # 对于每个广义笛卡尔积表的独有属性和共有属性，检查被除表中是否存在这个元组（由做笛卡尔积的过程知，独有属性从被除表得到，所以一定存在。检查共有属性即可），返回【共有属性不在被除表里存在】的元组的独有属性    where b1.Cno not in (select Cno from SC where SC.Sno = b1.Sno)));</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adobe Pr 2020 经验记录帖</title>
      <link href="/2022/08/24/PR-summary/"/>
      <url>/2022/08/24/PR-summary/</url>
      
        <content type="html"><![CDATA[<p>如果在py暑期课小组里，你会剪视频<br>那你也可以跟组员这样说：随便录，不怕错，我来剪[doge]<br>纯新手记录帖 没有技术 算是给暑假肝的好多<del>打工</del>视频做一些留念。</p><span id="more"></span><h3 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h3><p><strong>第一个好习惯：在时间轴导入第一个素材也就是创建了序列以后，就手动修改序列的大小。</strong></p><p>【序列-序列设置】一般选择16:9，1920：1080。</p><blockquote><p>如果是自己剪自己的素材，手机视频的比例都一样。如果是收集很多人提交的视频素材剪视频，一定记得导入第一个人的素材就改序列大小。大家的视频素材大小都不一样，很容易出现拼接问题。</p><ul><li><p>收集体录制视频剪辑记得提醒：名字首字母命名+.mp4格式，16:9；手机的视频不要通过微信传到电脑；电脑传视频也不要直接拖到微信，用zip打包/邮箱/云盘。</p></li><li><p>收集体录屏剪辑记得提醒：不要用Obs；导出mp4格式。说错可以重说，最好保证<strong>画面不要有很大的变动</strong>。</p></li></ul></blockquote><h3 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h3><blockquote><p>如何选择我想调整的图层，修改它的大小？</p></blockquote><ul><li><strong>把其他所有图层都关上</strong>，不允许修改。</li><li>在<strong>时间轴</strong>上双击要缩放大小的素材，确保你选中了这个素材。</li><li>再双击预览窗上的这个素材，就可以选中缩放了。</li></ul><blockquote><p> 复制粘贴不到想要的轨道？</p></blockquote><ul><li>点击”V1””V2”等图标，保证你想要的轨道的图标是<strong>蓝色</strong>的，并且是<strong>从小数到大的第一个蓝色</strong>的。</li><li>或者把其他所有的轨道都变成<strong>不允许修改</strong>，也能粘到你想要的轨道</li></ul><blockquote><p> 剪完视频无法导出？</p></blockquote><ul><li>把<strong>预览光标</strong>拖到<strong>起点</strong>。</li></ul><blockquote><p>自己新建的字幕不在画面显示？</p></blockquote><ul><li>“开放字幕”和“开放式字幕”不一样。选<strong>“开放式字幕”</strong>。</li></ul><h3 id="视频格式转换"><a href="#视频格式转换" class="headerlink" title="视频格式转换"></a>视频格式转换</h3><p>录屏建议用<strong>ev录屏</strong>。视频播放建议<strong>PotPlayer</strong>。</p><blockquote><p>PotPlayer <a href="https://zhuanlan.zhihu.com/p/366308705">https://zhuanlan.zhihu.com/p/366308705</a></p><p>ev录屏 <a href="https://www.ieway.cn/">https://www.ieway.cn/</a> 官网下载，开包后傻瓜式界面。OS助教培训15min过去后我意识到该录个屏，OS助教培训20min时，我从官网下载好了ev录屏，进入ev界面，开启了人生中第一次正儿八经的录屏。</p><p>OBS也可以录，但是如果你想用pr剪辑或者剪辑的人想用pr剪辑，请导出<strong>mp4格式</strong>或者换ev录屏，（不是每个pr人遇到mkv格式都能耐心地听百度的下了两个格式转换软件试了三种格式还是被pr拒之门外之后，依旧因为舍不得让队友重录从而创新了百度没有的方法肢解<code>.mkv</code>然后成功导入pr的。）</p></blockquote><h4 id="mkv如何导入pr"><a href="#mkv如何导入pr" class="headerlink" title=".mkv如何导入pr"></a><code>.mkv</code>如何导入pr</h4><ul><li>下载了【格式工厂】，打开以后就在吐槽这复古的UI和感人的音效，让我觉得我的py大作业的前端虽然不堪入目但起码走上现代化了</li><li>【格式工厂】的谜之设计：选择操作载入文件以后，要点上面的启动才会开始转换 :)</li><li>百度告诉我【格式工厂】可以把<code>.mkv</code>转成<code>.mp4</code>，确实可以，不过导出来的<code>.mp4</code>还是不能导入pr。</li><li>正确的办法应该是，【格式工厂-分离器】会把<code>.mkv</code>导出成一个zip，把里面的两个文件分别拖到画面轨道和声音轨道就可以了。</li></ul><h3 id="bgm格式转换"><a href="#bgm格式转换" class="headerlink" title="bgm格式转换"></a>bgm格式转换</h3><p>我一般用网易云pc端下载bgm。网易云下载下载的格式有两种，一般不火的歌是<code>.mp3</code>，正常用就行。一些歌下载完是<code>.ncm</code>格式，导入pr前需要转换。</p><p>【在线网站工具】<strong>NCM格式在线转换为MP3格式 NCM TO MP3</strong>: link: <a href="https://ncm.worthsee.com/">https://ncm.worthsee.com/</a></p><p>它也提供了其他音乐软件的转换工具，非常强大。</p><h3 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h3><h4 id="自动生成字幕"><a href="#自动生成字幕" class="headerlink" title="自动生成字幕"></a>自动生成字幕</h4><p>【在线网站工具】<strong>网易见外工作台</strong>  <a href="https://jianwai.youdao.com/">https://jianwai.youdao.com/</a> </p><p>可以剪完视频确认音轨没问题以后，把视频导出mp3格式，传到网易见外工作台，选<strong>字幕模式</strong>等几分钟就好。</p><p>生成字幕之后导出成<code>.srt</code>文件，直接拖进pr即可。</p><h4 id="字幕大小修改"><a href="#字幕大小修改" class="headerlink" title="字幕大小修改"></a>字幕大小修改</h4><p>跟视频大小统一即可。比如1920:1080。</p><ul><li>在【项目】工具箱，右键字幕序列文件，【修改-字幕…】修改大小。</li><li>(?) 字幕工具栏里导入设置也有一个字幕大小。好像对已经导入的字幕没有什么作用。</li></ul><h4 id="字幕工具栏位置"><a href="#字幕工具栏位置" class="headerlink" title="字幕工具栏位置"></a>字幕工具栏位置</h4><p>拉到预览窗口右侧比较舒服。可以看到字幕预览位置，入点出点，字幕文字。</p><img src="/2022/08/24/PR-summary/SubtitleTools.png" class="" title="SubtitleTools"><h4 id="字幕全选"><a href="#字幕全选" class="headerlink" title="字幕全选"></a>字幕全选</h4><p>点击第一个字幕，滑倒最后一个字幕的地方，按住shift同时左键最后一个字幕，然后批量修改。记得把字幕选九宫格最下排居中的格子让字幕居中。</p><h4 id="字幕格式"><a href="#字幕格式" class="headerlink" title="字幕格式"></a>字幕格式</h4><p> （字号边缘对于1920*1080的字幕大小）：</p><ul><li>网易工作台导出的格式就还可以：背景颜色#AAAAAA，字体颜色#FFFFFF，字号50，微软雅黑bold。</li><li>更清晰正式一些的：背景颜色透明度0%，字体颜色#000000，描边颜色#FFFFFF，字号55，边缘12，微软雅黑bold。</li><li>注意检查自己的字号有没有让一行显示不全的。合理确定字幕字的数量。</li></ul><h4 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h4><ul><li><p><strong>修改字幕的时候，先改字幕的出点</strong>，从而保证修改字幕时间线的过程中入点一直小于出点，防止入点大于出点造成闪退</p></li><li><p>拖拽单条字幕时长时，确保<strong>选中</strong>该段字幕（序列中的字幕段从黑的变成<strong>灰色</strong>）<strong>再拖拽</strong>，否则会造成字幕序列的整体偏移</p></li><li><p>点击单条字幕，字幕窗口显示的字幕会跳到那条字幕的位置</p></li><li><p>尽量<strong>不要</strong>对<strong>字幕序列</strong>进行剪切和<strong>拖拽延长</strong>。时间线会错乱。整个视频和字幕完成后，需要在中间插一段视频和字幕可以：剃刀工具剪开-在字幕文件的最后，空过去足够长的时间后，把想加的字幕输入，然后把最后这段剪到视频画面的地方。还是尽量少裁剪拖拽字幕序列</p></li></ul><h3 id="声音减弱-渐入渐出"><a href="#声音减弱-渐入渐出" class="headerlink" title="声音减弱 渐入渐出"></a>声音减弱 渐入渐出</h3><p>不要用效果控件的音量过渡，难用。</p><p>把<strong>音轨拉宽</strong>到出现音量横线，用【<strong>钢笔工具</strong>】选帧标记圆点，上下拖拽音量线或者移动圆点实现音量缩放。</p><h3 id="效果控件"><a href="#效果控件" class="headerlink" title="效果控件"></a>效果控件</h3><ul><li><p>水平翻转：【视频效果-变换】</p></li><li><p>过渡：【视频过渡-擦除/溶解】都比较好用，几个常用：</p><ul><li><strong>渐变擦除</strong>：适合<strong>文字</strong>的过渡</li><li><strong>水波块/油漆飞溅</strong>：适合<strong>手绘</strong>、<strong>图片</strong>等元素的过渡</li><li><strong>胶片溶解</strong>：适合两段<strong>视频画面</strong>的过渡</li></ul></li></ul><h3 id="用pr把剪好的视频倍速"><a href="#用pr把剪好的视频倍速" class="headerlink" title="用pr把剪好的视频倍速"></a>用pr把剪好的视频倍速</h3><ul><li><p>一个还可以的办法：把剪好的长视频导出，再新建个pr项目拖进来，直接右键设置倍速。</p><ul><li>优点是操作方便，并且试了一下画质没有被压缩，而且第二个倍速项目导出非常快。</li><li>缺点是视频有问题需要回第一个项目剪，可能会导出好多慢速版稿子。不过对于想要原速视频稿子留档，或者用原速视频审稿的人来说也不算缺点了。<del>比如py作业。</del></li></ul></li><li><p>操作比较复杂的办法：也是新建一个项目，把剪好的【视频序列】拖进来。这时候的视频素材是<strong>一刀一刀的</strong>，<strong>没办法整体倍速</strong>。要认真地正确执行每一个步骤，不然最后导出可能会有问题：</p><ul><li>先选中所有【视频】素材，右键【取消链接】把画面和声音分离</li><li>然后全选所有画面轨道的素材，右键嵌套。然后所有声音轨道的素材也嵌套。</li><li>嵌套的时候要注意，项目只有这画面和声音的两个嵌套。不要出现循环嵌套、交叉嵌套或者第一次嵌套丢了点啥又开了一个嵌套把它补上，这样都是不行的，会导致导出的时候有奇怪的问题</li><li>然后上面做对了以后是只有两个绿色的轨道，选中这俩然后右键设置倍速，导出就好了。</li></ul><p>这样倍速有不少待解决的缺点：</p><ul><li>修改视频内容，要手动同步到两个文件。而且预览倍速视频时，发现m分s秒有问题，正常速度的视频还要自己去找那个时间。</li><li>更离谱的是，对嵌套素材的修改在导出的时候无效</li><li>应该有更好的解决办法，这种比较麻烦的办法目前适合剪辑时的局部倍速，剪完后的全局倍速还是方法一好些</li></ul></li></ul><hr><p>一些保守但一定不会出错的建议：</p><ul><li>保证C盘D盘有充足空间再剪视频。尤其是内容多的视频</li><li>可以设置定时保存功能，但是据我曾经的闪退、蓝屏、黑屏等情况来看，定时保存不一定能真的保存。还是<strong>手动ctrl+s稳稳的幸福</strong>。所以我一般把定时保存功能的弹窗当作提醒我手动保存的消息用</li><li>把视频、图片、mp3素材设定好文件位置再导入pr。否则移动已导入文件在本地存储的位置后，pr项目会丢失素材。pr项目真的很小很小，KB级的，所以请一定在剪辑之前安排好素材的目录。</li><li><strong>pr项目路径、素材路径、pr项目名字、素材名字：全英，不要带中文</strong></li><li>套网上的pr模板：感受是，跟github上下载别人的hexo博客主题，我再把这个主题修改成自己喜欢的个性化的样子，deploy到gitPage，差不多的感觉。意思就是：难，因为我一个初学者的技术，第三次剪视频就被迫套模板，工具栏还不知道在哪里找，更别说找到自定义素材的位置，替换进自己的素材了。有一种OO Pre的感觉<del>（这是可以说的吗）</del>；风险极高，因为模板版本和pr版本不一定适配。而且套模板特别特别吃性能。我正常导入手机视频或者电脑录屏加bgm加字幕，pr从来没炸过。就是在连套了四五套模板剪视频的那一次，让我留下了手动保存这个习惯。而且用模板，在pr里预览会卡QAQ</li></ul><hr><p>待解决：</p><ul><li>有时候mp4拖不进来，或者拖进来没音轨</li><li>字幕导入设置的窗口太大了</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8的新增特性与函数式编程</title>
      <link href="/2022/06/16/OO-lambda-in-Java8/"/>
      <url>/2022/06/16/OO-lambda-in-Java8/</url>
      
        <content type="html"><![CDATA[<ol><li>函数式编程的引入：通过四种两类编程范式之间的对比，介绍函数式编程这种编程模式的特别之处。</li><li>Java8引入的两个新特性：lambda函数和stream流式编程。这两个特性让java8有了一些函数式编程的能力或者说特点。</li><li>函数式编程的优势。</li></ol><span id="more"></span><h2 id="函数式编程的引入"><a href="#函数式编程的引入" class="headerlink" title="函数式编程的引入"></a>函数式编程的引入</h2><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>经过一学期OO课程的设计与构造，体会到面向对象编程的特点是封装、继承、多态，让程序有了非常丰富的可扩展性。</p><blockquote><p>比如这是一段最简单的多线程创建的例子。我们的电梯就是在这个实现了runnable接口的类中被定义了开关门、上下行的行为。</p><p>电梯作业中从这个电梯对象出发，<strong>和其他对象交互</strong>：比如调度器对象、等待对象。</p></blockquote><img src="/2022/06/16/OO-lambda-in-Java8/1.png" class="" title="pic1"><p>这就是面向对象编程范式的核心，以类作为对象的模板，把类和继承作为构造机制，<strong>以对象为中心</strong>，来思考并解决问题。好处是易于拓展，允许我们实现复杂的逻辑。</p><p>让我们再来仔细看这个输出线程。其实<code>output类</code>作为接口，只实现了一个<code>run方法</code>，甚至只是作为了<code>thread</code>创建的一个构造参数。java比较痛苦的一点是要经常新建类，给他起名，写构造函数等等。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>为了简化这种负担，java有<strong>匿名类</strong>的机制，可以省略掉这个外部类的定义，就是<strong>把<code>output类</code>匿名</strong>，直接把<code>new runnavle接口</code>实现作为<code>thread</code>的构造参数。</p><p>使用了匿名类之后代码看起来简洁了不少，线程的行为也更加直观。不过可以看到，idea给我们把<code>new runnable</code>这一行标灰了，意思是可以省略。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>其实思考一下也不难理解，上边这么多行，真正有效的代码就一行输出语句。<strong>创建线程是为了执行某一个任务</strong>，任务也就是一个<strong>方法</strong>，那我们为何不<strong>直接传入一个方法</strong>呢？干脆把新建类也省去。</p><p>这就是函数式编程的一个核心概念，函数式编程的<strong>主要抽象</strong>是<strong>函数</strong>，函数是一等公民。</p><p>所谓的一等公民，指的是函数与其他数据类型一样，处于同等地位。函数可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，因此可以对函数进行组合。</p><p>放在这个代码里理解，就是这短短的一行函数，作了线程创建的参数，用到了Lambda函数。这是函数式编程和我们面向对象的世界中不一样的一种抽象。</p><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>下面我们再来看另一组编程范式。</p><img src="/2022/06/16/OO-lambda-in-Java8/2.png" class="" title="pic1"><p><strong>面向对象</strong>是一种典型的<strong>命令式编程</strong>，命令式编程是关于定义<strong>如何做</strong>。</p><p>怎么做，是一种<strong>面向硬件</strong>的抽象，程序员需要告诉机器每一步的实现过程。比如这个例子，想计算销量大于100的店铺的总数。命令式编程中，我们就得告诉计算机，你要先做循环，再做条件判断，销量比<code>1000</code>高就给<code>count+1</code>。哦对一定不要忘了，非常致命的一点，**<code>count</code><strong>这个负责计数的变量要记得</strong>初始化**。</p><p>命令式程序有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令）。简单来说，命令式程序就是一个<strong>冯诺依曼机的指令序列</strong>。</p><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p><strong>声明式编程</strong>的风格，是关于定义<strong>要做什么</strong>而不是如何做，更接近<strong>自然语言</strong>的接口。</p><p>同样的功能，声明式的代码不仅写起来起来更简洁，不需要看函数内部的实现细节就可以了解大意。比如这段这段声明式编程的代码只是说：我要<code>过滤(filter)</code> 一下这些店 构成的<code>流(stream)</code> , 只把那些销量大于<code>1000</code>的留下， 计算出个数就行了。</p><p>流式编程是一种典型的声明式编程，更接近自然语言接口，这一些函数调用返回一个结果给<code>count</code>变量，也规避了<code>count</code>自增前的初始化问题。<br>这也是函数式编程的另一个优势，不需要考虑过程量的副作用。</p><img src="/2022/06/16/OO-lambda-in-Java8/3.png" class="" title="pic1"><p>看这例子：两段代码都是先排序，然后返回第一项作为最近的店。区别在于上面的排序改变了这个表的顺序，按照距离由小到大排序。而流式编程的<code>sort</code>并未改变原数据。也就是<strong>函数执行没有副作用</strong>。</p><p>第一个排序，跟下边的比起来也是唯一一个没有使用Lambda表达式的排序写法，它的<code>compartor接口</code>就需要在这个<strong>店铺的类</strong>里边<strong>继承接口</strong>，然后<strong>重写</strong><code>compareto方法</code>。</p><p>在排序的代码中，后面几种出现了 <code>-&gt;</code>、<code>::</code> 的，都用了lambda表达式实现<code>compartor</code>这个比较接口。</p><p>可以看到都是lambda函数，有的刷灰了意思是还可有更简化的写法。<br>我们可以对比集合排序的比较器接口的几种使用lambda函数实现的方法，从compartor接口的例子中了解lambda函数的语法。</p><h2 id="二、lambda函数"><a href="#二、lambda函数" class="headerlink" title="二、lambda函数"></a>二、lambda函数</h2><p>这么多次OO作业肯定大家都用到过，尽管我们在作业中使用Lambda的场景并不是为了函数式编程，是使用新特性来让代码的书写更加优雅。</p><h3 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h3><img src="/2022/06/16/OO-lambda-in-Java8/4.png" class="" title="pic1"><p>这张图使用了刚刚提到过的<code>runnable接口</code>的实现的例子。包括函数签名，这个标志着lambda函数的箭头，还有函数式编程中最重视的函数实现。</p><p>这三部分组成了Lambda表达式的完整结构，这一行就可以作为一个<code>runnable接口</code>变量。lambda表达式也可以向我们刚刚创建线程那样作为参数进行传递。</p><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><p>函数签名包括函数名、函数的返回值和传入参数。</p><p>刚刚提到了，lambda函数是匿名类的进一步简化。lambda的匿名性省略了函数名。同时它有一种更强大的省略特性，这种机制被允许的原因是<strong>java编译器的自动类型推断</strong>。</p><ul><li>返回值可以省略，可以从接口类型判断出返回值。</li><li>参数的类型，也可以被省略。</li><li>如果只有一个参数，可以省略括号。</li><li>把它存成 比较器接口变量，借助这个变量的<code>reverse方法</code>我们可以实现逆序。</li></ul><h4 id="函数主体"><a href="#函数主体" class="headerlink" title="函数主体"></a>函数主体</h4><img src="/2022/06/16/OO-lambda-in-Java8/5.png" class="" title="pic1"><ul><li><p>主体只包含一个语句，可以省略大括号。刚刚的实现里，箭头后边都只有一条语句，没有大括号。</p></li><li><p>函数实现也可以语句块作为函数，这里除了比较距离，还比较了年龄这个参数，实现了多重条件的比较。</p><blockquote><p>函数实现比较复杂，下面介绍如何一步步化简省略定义这种多重条件的比较逻辑。</p><p>首先<code>::</code>这个符号，两个冒号，像C++的作用域解析运算符，是<strong>Java 8</strong>的一种更方便的<strong>方法引用</strong>。</p><p>我们可以通过使用这种实例方法的引用和<code>Comparator.comparing</code>方法来避免定义比较逻辑——它会自动提取和创建一个基于这个函数的<code>Comparable</code>。</p><p>这里看起来没有lambda表达式的结构，是怎么实现的接口呢？具体原因我们放在后边再展开讲。</p></blockquote></li></ul><h3 id="Lambda表达式的化简"><a href="#Lambda表达式的化简" class="headerlink" title="Lambda表达式的化简"></a>Lambda表达式的化简</h3><p>总结一下刚刚逐步简化的Lambda表达式。它的作用是取代一个类，用来实现接口。</p><img src="/2022/06/16/OO-lambda-in-Java8/6.png" class="" title="pic1"><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式的语法是什么支持的呢？这种实现的<strong>对象类型</strong>。再怎么函数式编程，也要在java面向对象的机制中扩展。表达式的类型是函数式接口。</p><p>只有一个接口函数需要被实现的接口类型，称为”函数式接口“。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明<code>@FunctionalInterface</code>, 这样就无法在里面添加新的接口函数。</p><h3 id="函数式接口的前提条件"><a href="#函数式接口的前提条件" class="headerlink" title="函数式接口的前提条件"></a>函数式接口的前提条件</h3><ul><li><p>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。</p><p>无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</p></li><li><p>使用Lambda必须具有<strong>上下文推断</strong>。</p><p>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。上文提到的依托java编译器的自动类型推断的省略机制要求上下文推断。</p></li></ul><h3 id="几种常见的函数式接口"><a href="#几种常见的函数式接口" class="headerlink" title="几种常见的函数式接口"></a>几种常见的函数式接口</h3><img src="/2022/06/16/OO-lambda-in-Java8/7.png" class="" title="pic1"><ul><li><p><code>predicte</code>：推断出参数类型返回值类型，是用来判断真假的函数接口。 函数实现是一个布尔表达式。</p></li><li><p><code>BinaryOperator</code>：接收两个参数，返回一个值，返回值和参数的数据类型相同。体现一种映射关系，<code>x y -&gt;x+y</code>。</p></li><li><p><code>comparing</code>：上文提到的 “<code>comparing</code>没有lambda表达式的结构是怎么实现的接口？” 因为这个方法返回了一个函数式接口，使用<code>comparing()</code>的地方，也就是<code>sort()</code>的传入参数就是函数式接口function。<br><code>comparing()</code>的传入参数也是函数式接口function。<code>key::lambda</code>是对函数式接口的更一步简化。</p></li></ul><h3 id="集合的函数式接口"><a href="#集合的函数式接口" class="headerlink" title="集合的函数式接口"></a>集合的函数式接口</h3><p>java集合框架也新增部分函数接口用于与Lambda表达式对接。</p><img src="/2022/06/16/OO-lambda-in-Java8/8.png" class="" title="pic1"><ul><li><p>作业中很常见，比如说removeif规避了for遍历删除的问题，这里的参数就是Prediect 函数式接口。</p></li><li><p>创建优先队列的构造参数，是一个比较器接口。</p></li><li><p>foreach遍历接受函数式接口做参数。</p></li><li><p>第四单元类重名的异常机制，可以借助这个merge方法，BinaryOperator接口作为重映射函数。</p></li></ul><h3 id="作业中使用lambda函数的优化"><a href="#作业中使用lambda函数的优化" class="headerlink" title="作业中使用lambda函数的优化"></a>作业中使用lambda函数的优化</h3><h4 id="unit1"><a href="#unit1" class="headerlink" title="unit1"></a>unit1</h4><ul><li><p>如果在某些情况下我们只需要实现一些行为/操作而不需要实现状态，OOP 会限制将该行为包装在一个类中以便能够执行它。会导致不必要的冗长代码，其中计算只需要执行一个函数。</p></li><li><p>合并同类项的加法类：代码完美遵循了面向对象地封装概念。美中不足是略为繁琐</p><img src="/2022/06/16/OO-lambda-in-Java8/9.png" class="" title="pic1"></li></ul><ul><li>合并同类项：选用hashmap的merge()方法和lambda函数来实现合并同类项非常简洁。<ul><li>forEach()方法用于对 HashMap 中的每个键值对执行指定的操作。匿名函数 lambda 的表达式 作为 forEach()方法的参数传入。</li><li>merge()方法用于合并两个hashmap，使用lambda表达式 (oldValue, newValue) -&gt; (oldValue + newValue) 作为重映射函数。</li><li>Java 8的方法引用更方便，方法引用由::双冒号操作符标示,使用BigInteger::add作为重映射函数即可。</li></ul></li></ul><ul><li><p>减法：</p><ul><li>由于hashmap.merge()在插入hashmap2中不存在的key与其对应的value时不会调用重映射函数，故减法不能使用BigInteger::subtract作为映射函数；</li><li>解决办法为减数先取反，再与被减数调用quanticAdd()即可</li></ul></li><li><p>乘法：</p><ul><li>将两个BaseKey相乘后的新BaseKey作为merge方法的key参数，系数的乘积作为value参数，重映射函数BigInteger::add</li><li>Key为自定义类型BaseKey，重写hashcode()和equal()后便于合并同类项</li><li>由于需要维护可变类型BaseKey作为hashmap的key的不可变性，以及value代表的系数为不可变类型BigInteger，没有出现深浅拷贝的Bug</li></ul></li></ul><h2 id="三、Stream流式编程"><a href="#三、Stream流式编程" class="headerlink" title="三、Stream流式编程"></a>三、Stream流式编程</h2><p>Stream 使用类似 SQL 语句从数据库查询数据的方式来提供一种<strong>对 Java 集合运算和表达的高阶抽象</strong>。  </p><img src="/2022/06/16/OO-lambda-in-Java8/10.png" class="" title="pic1"><p>Stream API <strong>将要处理的元素集合看作一种流</strong>，流在<strong>管道</strong>中传输，并且可以在管道的节点上进行处理， 比如<strong>筛选，排序，聚合</strong>等。</p><h3 id="流式编程特点"><a href="#流式编程特点" class="headerlink" title="流式编程特点"></a>流式编程特点</h3><ul><li>Stream并无数据存储，不会修改背后的数据源。所有惰性操作以<strong>pipeline</strong>的方式执行，<strong>减少迭代次数</strong>.</li><li>处理•大量元素时，为了<strong>提高性能</strong>需要<strong>并行处理</strong>，并利用多核架构。并行化的Stream 不需要再写多线程代码，所有对它的操作会<strong>自动并行</strong>进行的。</li><li>流的操作可以分为两类：处理操作、聚合操作。<ul><li><strong>处理操作（惰性求值）</strong>：诸如filter、map等处理操作将Stream一层一层的进行抽离，返回一个流给下一层使用。</li><li><strong>聚合操作（及早求值）</strong>：从最后一次流中生成一个结果给调用方，得到<strong>最终的结果</strong>而不是Stream。</li></ul></li></ul><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><img src="/2022/06/16/OO-lambda-in-Java8/11.png" class="" title="pic1"><ul><li>filter()：过滤大规模数据集合。接受一个前面提到的 Predicate 断言型函数式接口，传入一个lambda表达式作为过滤逻辑,获得一个新的列表。</li></ul><pre><code class="java">//Unit4作业//Elements读取不用使用多层循环嵌套Map&lt;String,MyClass&gt; myClass = Arrays.stream(elements)    .filter(element -&gt; element instanceof UmlClass)    .map(MyClass::new)    .collect(Collectors.toMap(MyClass::getId,item -&gt; item));//重写MyClass构造方法public MyClass(UmlElement std) &#123;    this.std = (UmlClass) std;    this.id = std.getId();    //...&#125;</code></pre><ul><li>map()：是函数式编程中非常重要的一个概念，能够将对象进行转换</li></ul><pre><code class="java">// 为每个订单加上12%的税，使用reduce计算总开销// 老方法：List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double total = 0;for (Integer cost : costBeforeTax) &#123;    double price = cost + .12*cost;    total = total + price;&#125;System.out.println(&quot;Total : &quot; + total);// 新方法：List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost)                                    .reduce((sum, cost) -&gt; sum + cost).get();System.out.println(&quot;Total : &quot; + bill); </code></pre><ul><li>其他例子：<a href="https://zhuanlan.zhihu.com/p/28112239">https://zhuanlan.zhihu.com/p/28112239</a></li></ul><h3 id="ForkJoin框架"><a href="#ForkJoin框架" class="headerlink" title="ForkJoin框架"></a>ForkJoin框架</h3><img src="/2022/06/16/OO-lambda-in-Java8/12.png" class="" title="pic1"><h2 id="四、函数式编程的特点与优势"><a href="#四、函数式编程的特点与优势" class="headerlink" title="四、函数式编程的特点与优势"></a>四、函数式编程的特点与优势</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>函数是输入和输出之间的映射。可以将其视为将输入转换为输出的“黑匣子”。 </p><p>（1）函数避免改变状态和改变数据。他们观察到的所有状态只是提供给他们的输入。 </p><p>（2）函数不会改变输入的值，对它们的执行没有副作用。 </p><p>（3）对于每个输入，都有<strong>相同的输出</strong>。 </p></li><li><p>以上特点自然适合并发和并行适用性。计算朝着更多内核和分布式/并行计算的方向发展，事实证明<strong>函数式编程</strong>更适合这些要求。</p></li><li><p>java并不是很典型的函数式编程语言。Apache Spark 是一个用 Scala 编码的大数据平台，它是一种函数式语言。另一个例子是 R，这是数据科学家中最流行的语言，它是函数式的。</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>因为FP中的每个符号都是final的，没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它作用域之外的值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。  </p><p>测试程序中的函数时只需要关注它的参数就可以。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。  </p><h4 id="调试时的可复现性"><a href="#调试时的可复现性" class="headerlink" title="调试时的可复现性"></a>调试时的可复现性</h4><p>如果一段FP程序没有按照预期设计那样运行，调试的工作非常容易，因为这些错误是百分之一百可以重现的。FP程序中的错误不依赖于之前运行过的不相关的代码。</p><p>而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。</p><h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><ul><li><p>所有FP程序都是可以并发执行的。由于根本<strong>不需要采用锁机制</strong>，因此完全不需要担心死锁或是并发竞争的发生。</p></li><li><p>某个FP程序本身只是<strong>单线程</strong>的，编译器也可以将其<strong>优化</strong>成可以在多CPU上运行的并发程序。</p></li><li><p>这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab6</title>
      <link href="/2022/06/12/OS-lab6-summary/"/>
      <url>/2022/06/12/OS-lab6-summary/</url>
      
        <content type="html"><![CDATA[<img src="/2022/06/12/OS-lab6-summary/lab6.png" class="" title="shell"><h2 id="一、MOS中体现“面向对象”思想的两个设计"><a href="#一、MOS中体现“面向对象”思想的两个设计" class="headerlink" title="一、MOS中体现“面向对象”思想的两个设计"></a>一、MOS中体现“面向对象”思想的两个设计</h2><h3 id="1-fd-c的文件服务函数接口，实际上包含console-file-pipe三种外设文件类型"><a href="#1-fd-c的文件服务函数接口，实际上包含console-file-pipe三种外设文件类型" class="headerlink" title="1. fd.c的文件服务函数接口，实际上包含console file pipe三种外设文件类型"></a>1. fd.c的文件服务函数接口，实际上包含console file pipe三种外设文件类型</h3><span id="more"></span><h3 id="1-1-fd-h-定义外设文件的抽象接口dev"><a href="#1-1-fd-h-定义外设文件的抽象接口dev" class="headerlink" title="1.1 fd.h 定义外设文件的抽象接口dev"></a>1.1 fd.h 定义外设文件的抽象接口dev</h3><pre><code class="c">struct Dev &#123;    int dev_id;    char *dev_name;    int (*dev_read)(struct Fd *, void *, u_int, u_int);    int (*dev_write)(struct Fd *, const void *, u_int, u_int);    int (*dev_close)(struct Fd *);    int (*dev_stat)(struct Fd *, struct Stat *);    int (*dev_seek)(struct Fd *, u_int);&#125;;</code></pre><h4 id="1-2-实现dev接口的继承类"><a href="#1-2-实现dev接口的继承类" class="headerlink" title="1.2 实现dev接口的继承类"></a>1.2 实现dev接口的继承类</h4><p>以下三种外设类型，都给dev结构体填入了自己的id name 和各自的开关、读写文件函数指针。</p><h5 id="file-c"><a href="#file-c" class="headerlink" title="file.c"></a>file.c</h5><pre><code class="c">struct Dev devfile = &#123;        .dev_id =    &#39;f&#39;,        .dev_name =    &quot;file&quot;,        .dev_read =    file_read,        .dev_write =    file_write,        .dev_close =    file_close,        .dev_stat =    file_stat,&#125;;</code></pre><h5 id="console-c"><a href="#console-c" class="headerlink" title="console.c"></a>console.c</h5><pre><code class="c">struct Dev devcons =&#123;.dev_id=    &#39;c&#39;,.dev_name=    &quot;cons&quot;,.dev_read=    cons_read,.dev_write=    cons_write,.dev_close=    cons_close,.dev_stat=    cons_stat,&#125;;</code></pre><h5 id="pipe-c"><a href="#pipe-c" class="headerlink" title="pipe.c"></a>pipe.c</h5><pre><code class="c">struct Dev devpipe =&#123;.dev_id=    &#39;p&#39;,.dev_name=    &quot;pipe&quot;,.dev_read=    piperead,.dev_write=    pipewrite,.dev_close=    pipeclose,.dev_stat=    pipestat,&#125;;</code></pre><h4 id="1-3-父类方法调用的多态性"><a href="#1-3-父类方法调用的多态性" class="headerlink" title="1.3 父类方法调用的多态性"></a>1.3 父类方法调用的多态性</h4><p>在fd.c中调用close()\read()\write()的文件操作函数接口时，使用类似<code>(*dev-&gt;dev_close)(fd)</code> 、<code>(*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset)</code>的调用，可以实现类似类方法的多态的效果，不同的子类（外设文件类型）对应不同的文件服务函数效果。</p><h3 id="2-在对shell读入的命令进行split和parse，拆分出命令和参数的过程中，将所有符号和字符串都抽象成token"><a href="#2-在对shell读入的命令进行split和parse，拆分出命令和参数的过程中，将所有符号和字符串都抽象成token" class="headerlink" title="2. 在对shell读入的命令进行split和parse，拆分出命令和参数的过程中，将所有符号和字符串都抽象成token"></a>2. 在对shell读入的命令进行split和parse，拆分出命令和参数的过程中，将所有符号和字符串都抽象成token</h3><p>见<a href="https://mmmusel-github-io.vercel.app/2022/07/12/OS-lab6-summary/#/2-rumcmd%EF%BC%9A%E6%8A%8A%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E4%BB%A4%E6%8B%86%E5%88%86%E6%88%90%E5%91%BD%E4%BB%A4%E5%92%8C%E5%8F%82%E6%95%B0">shell流程分析的命令拆分部分</a>。</p><h2 id="二、Shell执行流程"><a href="#二、Shell执行流程" class="headerlink" title="二、Shell执行流程"></a>二、Shell执行流程</h2><img src="/2022/06/12/OS-lab6-summary/lab6.png" class="" title="shell"><h3 id="2-1-申请新进程的几种方式"><a href="#2-1-申请新进程的几种方式" class="headerlink" title="2.1 申请新进程的几种方式"></a>2.1 申请新进程的几种方式</h3><ul><li>内核态下，init.c中<code>加载二进制映像的宏ENV_CREATE()直接调用内核态函数env_create_priotity()</code>来创建进程</li><li>需要新进程执行外部命令commands.b时，通过spawn()中的系统调用<code>syscall_env_alloc()</code> 创建新进程</li><li>shell中通过 fork() 创建新进程进行命令的解析和重定向工作，再调用spwan() 执行外部命令</li></ul><h3 id="2-2-shell的基本功能与其对应的函数"><a href="#2-2-shell的基本功能与其对应的函数" class="headerlink" title="2.2 shell的基本功能与其对应的函数"></a>2.2 shell的基本功能与其对应的函数</h3><h4 id="1-把shell终端的标准输入输出初始化为控制台输入和屏幕输出"><a href="#1-把shell终端的标准输入输出初始化为控制台输入和屏幕输出" class="headerlink" title="1.把shell终端的标准输入输出初始化为控制台输入和屏幕输出"></a>1.把shell终端的标准输入输出初始化为控制台输入和屏幕输出</h4><ul><li><p>user/init.b中：int opencons(void)：把标准输入设置为控制台输入</p><ul><li>fd_alloc(&amp;fd)：从小到大遍历fd号，通过检查INDEX2FD(fd) 对应的页表是否PTE_V，判断fd号是否被占用</li><li>给fd号所对应的fd结构体申请BY2PG，标记为共享页面。<code>syscall_mem_alloc(0, (u_int)fd, PTE_V|PTE_R|PTE_LIBRARY)</code></li></ul><blockquote><p>实际上，在Linux的终端概念中，默认每个进程的fd 0,1,2已经被占用。被申请使用的文件描述符fd是从3开始的。Linux默认0是标准输入，从键盘输入；1是标准输出，输出到屏幕；2是标准错误输出。</p><p>而在MOS中，不存在标准输入、标准输出的概念，并没有被人为预设好。也就是说，我们的MOS中fd是从0开始申请的。所以，我们要在MOS中模拟类似Linux终端的标准输入输出这一行为。</p><p>所以在user/init.b中有以下这段代码：</p><pre><code class="c">if ((r = opencons()) &lt; 0)        user_panic(&quot;opencons: %e&quot;, r);    if (r != 0)        user_panic(&quot;first opencons used fd %d&quot;, r);    if ((r = dup(0, 1)) &lt; 0)</code></pre><p>可以看到，因为init.c是我们从内核态进程spwan出来的第一个进程，所以opencons()返回的文件描述符r必然是0。</p><p>此时，我们实现了标准输入 fd 0代表控制台的键盘输入。</p></blockquote></li><li><p>shell的umain函数是一个死循环，关于用户命令的读入自顶向下调用了以下函数：</p><ul><li><p>readline(buf, sizeof buf) 读取用户输入的命令行，读到回车返回。</p></li><li><p>read(0, buf + i, 1) ：从标准输入中每次读取一个char。这个在fd.c中的用户文件服务函数接口，调取标准输入fd 0代表的控制台文件，从而调用了console.c的cons_read()函数。</p></li><li><p>cons_read()函数通过系统调用<code>syscall_cgetc()</code>读取控制台的字符，返回给上层函数，并把字符writef显示在终端</p></li><li><p>syscall_cgetc() 调用了内核函数lib/getc.S，从控制台获取了输入字符并返回。</p><blockquote><p>小彩蛋：</p><p>这是getc.S的函数，这段汇编函数的第一行从地址0x90000000获取字符。</p><p>然而，把这个地址换为控制台的外设地址0xB0000000，控制台的效果也完全一致。</p><pre><code class="c">LEAF(sys_cgetc)1:    lb    t0, 0x90000000    beqz    t0, 1b    nop    move    v0,t0    jr    ra    nopEND(sys_cgetc) </code></pre></blockquote></li></ul></li><li><p>user/init.b中：dup(1,0)：把标准输出设置为控制台文件</p><ul><li>目的：把标准输入定向给标准输出，在user/init.b中通过<code>write(1,&quot;LALA&quot;,4);</code>语句来进行测试。</li><li>原理：由于fd 1被重定向到控制台文件，write(1) 就是向控制台文件写入，目的是把写入内容显示在屏幕。</li><li>对于console类型文件，write()调用cons_write()函数，通过user_bcopy和writef直接写在终端。</li></ul></li></ul><h4 id="2-rumcmd：把用户输入的字符串指令拆分成命令和参数"><a href="#2-rumcmd：把用户输入的字符串指令拆分成命令和参数" class="headerlink" title="2.rumcmd：把用户输入的字符串指令拆分成命令和参数"></a>2.rumcmd：把用户输入的字符串指令拆分成命令和参数</h4><img src="/2022/06/12/OS-lab6-summary/lab6-1.png" class="" title="parse_commands"><ul><li>readline()读入的用户命令字符串，通过gettoken()函数进行层次化建模与拆分：<ul><li>不论是连接命令和命令的pipe符号’|’，还是表示命令或者文件名的字符串，或者表示重定向的符号’&gt;’、’&lt;’等，在gettoken()中被拆分成出一个元素后，都用一个char作为返回值。（字符串使用’w’，其他符号使用自身）。</li><li>这样做的优势是，可以使用一个死循环来处理可变长参数。循环内部switch case语句接受char类型的返回值，进行不同的处理。</li><li>把不同元素抽象成token，实现了句法拆分的层次化处理，把繁琐的字符串处理变的有层次化，扩展性强。 对此部分的扩展性迭代见lab6-challenge的easy任务部分。</li></ul></li><li>至此，完成了命令的读入与解析部分。下面为命令如何执行</li></ul><h4 id="3-dup：文件、管道、标准输入输出之间的重定向"><a href="#3-dup：文件、管道、标准输入输出之间的重定向" class="headerlink" title="3.dup：文件、管道、标准输入输出之间的重定向"></a>3.dup：文件、管道、标准输入输出之间的重定向</h4><h5 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h5><ul><li>在上述switch case语句中，如果识别到重定向符号，会再次调用gettoken()函数读入文件名字符串，并使用r=open()获取文件描述符。</li><li>如果是输出重定向，open()的参数除了写O_WONLY，还要加上创建O_CREATE。</li><li>文件类型的重定向，只需要把标准输入0、或者标准输出1使用dup()重定向为打开的文件描述符r即可。</li></ul><h5 id="管道重定向"><a href="#管道重定向" class="headerlink" title="管道重定向"></a>管道重定向</h5><ul><li><strong>大致流程</strong>：识别到’|’，说明目前识别到的argv已经可以执行左边的指令。而shell的原则是申请新进程来执行命令。所以fork()，子进程进入<code>runit:</code>的命令执行部分。父进程继续循环，parse右半部分command。</li></ul><img src="/2022/06/12/OS-lab6-summary/lab6-2.png" class="" title="pipe"><ul><li><p>父进程的任务：</p><ul><li><p>fork()前申请管道 <code>pipe(p);</code>，因为父子进程需要共享pipe</p></li><li><p>fork()后：由于父进程要继续识别后续指令，所以它在管道中作为读方，接受左边命令子进程的返回数据。所以<code>dup(p[0],0)</code>，把管道的读指针作为父进程后续指令的标准输入。</p></li><li><p>此时结合管道特性分析：dup时，fd2data(0)的页面被映射到了fd2data(p[0])，此时fd2data(p[0])这个物理页所对的虚拟地址包括：fd2data(p[0]),fd2data(p[1]),fd2data(0)。</p></li></ul><blockquote><p>这使得MOS对于管道的close()时机与linux下gcc中的管道close()时机存在差异。二者都需要父进程或者子进程首先关闭一个不用的读或写指针。</p><p>对于各自进程的另一个需要使用的指针的关闭时机，linux下gcc中的管道close()需要在读或者写完成时，才关闭相应指针。参考这段程序</p><p>而MOS系统中，由于释放pipe的机制是ref(fd)==ref(fd2data)，也就是fd物理页面的引用次数=data物理页面的引用次数，才释放。</p></blockquote><ul><li>所以此时，父进程可以关闭读指针和写指针。（子进程在<code>dup(p[1],1)</code>后也同样关闭读写指针。）这样此时，fd[0]和fd[1]的页面引用都是0，fd2data那个物理页面由于两次dup()重定向，页面引用是2.所以pipe不会因为两次close关闭，会在后续fd2data页面引用降到0时关闭。</li><li>父进程继续解析后续指令，<code>goto again;</code></li></ul></li><li><p>子进程的任务</p><ul><li>子进程用于执行识别到的指令，产生指令结果作为后续指令的输入，所以它在管道中作为写方。所以<code>dup(p[1],1)</code>，把管道的写指针作为子进程执行指令的标准输出。</li><li>子进程执行自身指令，<code>goto runit;</code></li></ul></li></ul><h5 id="dup-int-oldfdnum-int-newfdnum-函数的具体实现"><a href="#dup-int-oldfdnum-int-newfdnum-函数的具体实现" class="headerlink" title="dup(int oldfdnum, int newfdnum)函数的具体实现"></a>dup(int oldfdnum, int newfdnum)函数的具体实现</h5><ul><li>找到两个fd的fd2data页面的虚拟地址</li><li>遍历fd2data(oldfdnum)所对应的文件区的虚拟地址的页表项，如果PTE_V，使用系统调用<code>syscall_mem_map</code>把fd2data(oldfdnum)文件区中的这一虚拟地址的物理页，映射给fd2data(newfdnum)文件区的相同偏移的虚拟地址。</li></ul><h4 id="4-spawn：加载命令的二进制映像，创建子进程执行外部命令"><a href="#4-spawn：加载命令的二进制映像，创建子进程执行外部命令" class="headerlink" title="4.spawn：加载命令的二进制映像，创建子进程执行外部命令"></a>4.spawn：加载命令的二进制映像，创建子进程执行外部命令</h4><p>在runcmd()的runit部分，把解析到的命令和参数argv数组传入spawn()函数，执行外部命令。</p><ul><li><p>从文件系统打开2 进制 ELF，在MOS 里是 *.b，申请新的进程描述符</p><ul><li> MOS中open()的文件要在磁盘映像中检索，对应到fs.img文件。而此文件在fs/Makefile中生成。所以我们没有办法打开user/*.b，而是需要在fs/Makefile中给生成磁盘映像fs.img的命令中加入user/*.b的二进制文件，才能在磁盘中烧录对应的文件。</li></ul></li><li><p>使用系统调用syscall_env_alloc() 生成新进程</p></li><li><p>为子进程初始化堆、栈空间，并设置栈顶指针，对于栈空间，因为我们的调用可能是有参数的，所以要将参数也安排进用户栈中。</p><img src="/2022/06/12/OS-lab6-summary/lab6-3.png" class="" title="init_stack"></li><li><p>将目标程序加载到子进程的地址空间中，并为它们分配物理页面; </p><ul><li><p>usr_load_elf(): <code>load_icode_mapper() </code>+ 类似lab4 <code>fork.c的pgfault()</code> 中的用户态页面复制</p></li><li><p>二进制文件从text_start位置开始加载。这个位置对于每个*.b是固定的，由user/user.lds指导链入</p></li></ul><pre><code class="c">   . = 0x00400000;     _text = .;                    /* Text and read-only data */     .text : &#123;           *(.text)           *(.fixup)           *(.gnu.warning)     &#125;</code></pre></li><li><p>设置子进程的寄存器 (栈寄存器 sp 设置为 esp。程序入口地址 pc 设置为 UTEXT)</p><ul><li>寄存器指针为进程中上下文寄存器<code>tf = &amp;(envs[ENVX(child_envid)].env_tf);</code>。</li><li>用户进程下的<code>envs</code>与env.c中的不同。envs在user/entry.S中定义，<code>.globl envs</code>，然后被赋值为UENVS <code>envs: .word UENVS</code>。此时在用户态，想修改进程env结构体，从UENVS的虚拟地址通过两级页表访问修改env结构体的物理页面。</li></ul></li><li><p>遍历页表，将父进程的共享页面syscall_mem_map() 映射到子进程的地址空间中。</p></li><li><p>这些都做完后，syscall_set_env_status() 设置子进程可执行。</p></li></ul><h2 id="三、pipe机制"><a href="#三、pipe机制" class="headerlink" title="三、pipe机制"></a>三、pipe机制</h2><p>思考题和教程描述的较为清晰。</p><h3 id="关于中断导致竞争的解决策略"><a href="#关于中断导致竞争的解决策略" class="headerlink" title="关于中断导致竞争的解决策略"></a>关于中断导致竞争的解决策略</h3><ul><li><p>对于fd页和fd2data页的映射和解映射不能封装成原子操作，所以做了两次修正：</p><ul><li>一个是顺序的问题，map时先data页再fd页，unmap时先fd页再data页。</li><li>env_runs域要在lab3部分的env.c的env_runs()维护，从而保证可以通过env_runs确保获取的两个pageref是没有被时钟中断分开。</li></ul></li><li><p>pipe_read()中需要在读取过程中写好结束或者调度条件</p><pre><code class="c">while (p-&gt;p_rpos &gt;= p-&gt;p_wpos) &#123;            if (_pipeisclosed(fd, p) || i &gt; 0) return i;            syscall_yield();        &#125;</code></pre></li><li><p>关于MOS的管道与linux下gcc中的管道在close()中的不同：</p><p>见<a href="https://mmmusel-github-io.vercel.app/2022/07/12/OS-lab6-summary/#/%E7%AE%A1%E9%81%93%E9%87%8D%E5%AE%9A%E5%90%91">上述关于close()的分析</a>。</p></li></ul><h3 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h3><blockquote><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？ </p></blockquote><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int fildes[2];/* buf size is 100 */char buf[100];int status;int main()&#123;    status = pipe(fildes);    if (status == -1 ) &#123;        /* an error occurred */        printf(&quot;error\n&quot;);    &#125;    switch (fork()) &#123;    case -1: /* Handle error */        break;    case 0: /* Child - reads from pipe */        close(fildes[0]); /* Read end is unused */        write(fildes[1], &quot;Hello world\n&quot;, 12); /* Write data on pipe */        close(fildes[1]); /* father will see EOF */        exit(EXIT_SUCCESS);    default: /* Parent - writes to pipe */        close(fildes[1]); /* Write end is unused */        read(fildes[0], buf, 100); /* Get data from pipe */        printf(&quot;father-process read:%s&quot;,buf); /* Print the data */        close(fildes[0]); /* Finished with pipe */        exit(EXIT_SUCCESS);    &#125;&#125;</code></pre><h3 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h3><blockquote><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/fd.c 中的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？</p></blockquote><pre><code>    pipe(p);    rightpipe = fork();    if (rightpipe == 0) &#123;        dup(p[1], 0);        read(p[0]);    &#125;    else &#123;        close(p[0]);        write(p[1]);        close(p[1]);    &#125;</code></pre><ul><li> fork 结束后，子进程先执行dup(p[0],newfd).时钟中断产生在下面两条指令之间.</li></ul><pre><code class="c">    if ((r = syscall_mem_map(0, (u_int)oldfd, 0, (u_int)newfd,                             ((*vpt)[VPN(oldfd)]) &amp; (PTE_V | PTE_R | PTE_LIBRARY))) &lt; 0) &#123;        goto err;    &#125;    /* break */    if ((* vpd)[PDX(ova)]) &#123;        for (i = 0; i &lt; PDMAP; i += BY2PG) &#123;            pte = (* vpt)[VPN(ova + i)];            if (pte &amp; PTE_V) &#123;                // should be no error here -- pd is already allocated                if ((r = syscall_mem_map(0, ova + i, 0, nva + i,                                         pte &amp; (PTE_V | PTE_R | PTE_LIBRARY))) &lt; 0) &#123;                    goto err;                &#125;            &#125;        &#125;    &#125;</code></pre><ul><li>子进程 dup(p[1],newfd) 后，newfd增加了对 p[1] 的映射，但还没有来得及增加对 pipe 的映射(map)，此时时钟中断产生，父进程接着执行。</li><li>父进程close(p[0])后，此时各个页的引用情况：pageref(p[0]) = 1， pageref(p[1]) = 3(因为子进程复制了p[1])。此时 pipe 的pageref 是 3(子进程的pageref(pipe)是2，子进程对pipe没有dup增加映射也没有close解除映射；同时父进程中 p[0] 刚解除对 pipe 的映射，所以在父进程中也只有 p[1] 引用了 pipe。</li><li>父进程执行 write，write 中首先判断读者是否关闭。比较 pageref(pipe) 与 pageref(p[1])之后发现它们都是 3，说明写端已经关闭，于是父进程退出。</li></ul><h3 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h3><blockquote><p>仔细阅读上面这段话，并思考下列问题<br>• 按照上述说法控制 pipeclose 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。<br>• 我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件内容。试想，如果要复制的是一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</p></blockquote><ul><li><p>close()的ummap(fd)后unmap(pipe)可以解决竞争问题。考虑下面的过程：</p><ul><li>fork 结束后，子进程先执行。时钟中断产生在 close(p[1]) 与 read 之间，父进程开<br>始执行。</li><li>父进程在 close(p[0]) 中，p[0] 已经解除了对 p[0] 的映射 (unmap)，还没有来得及<br>解除对 pipe 的映射，时钟中断产生，子进程接着执行。</li><li>此时各个页的引用情况：pageref(p[0]) = 1(父进程解除了对 p[0] 的<br>映射)，而 pageref(p[1]) = 1(因为子进程已经关闭了 p[1])。但注意，此时 pipe 的<br>pageref 是 3，子进程中 p[0] 和 p[1] 都引用了 pipe，同时父进程中 p[0] 刚解除对 pipe 的映<br>射，所以在父进程中只有 p[1] 引用了 pipe。</li><li>子进程执行 read，read 中首先判断写者是否关闭。比较 pageref(pipe) 与 pageref(p[0])<br>不相等，说明写端没有关闭。</li></ul></li><li><p>由于pageref(fd)的取值为2或1，pageref(pipe)可以是4~2，所以需要满足“大追小”，即分pageref(pipe)和pageref(fd)别从4和2开始，要让他们在1=1的时候相遇，从而避免在2=2的时候意外相遇而终止。所以dup的时候，要先让大的pageref(pipe)先map从而增加一，再让pageref(fd)map增加一，避免因为pageref(fd)map增加的时候导致二者相等的错误情况。具体错误情况可见<a href="https://mmmusel-github-io.vercel.app/2022/07/12/OS-lab6-summary/#/Thinking-6-2">thinking 6.2</a>。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab5</title>
      <link href="/2022/05/31/OS-lab5-summary/"/>
      <url>/2022/05/31/OS-lab5-summary/</url>
      
        <content type="html"><![CDATA[<p>BUAA-OS-Lab5 : 文件管理系统</p><span id="more"></span><h1 id="一、实验难点"><a href="#一、实验难点" class="headerlink" title="一、实验难点"></a>一、实验难点</h1><ul><li>lab5新增加的虚拟地址的映射布局<ul><li>需要明确：广义用户进程是相对于内核态的，lab5的文件服务进程和用户进程都是用户态下的进程。但是以下涉及的lab5的“用户进程”都是相对服务进程而言的普通用户进程。尽管文件服务进程也属于广义用户进程。</li><li>用户进程：文件映射区</li><li>文件服务进程：块缓存</li></ul></li><li>lab5新增加的物理空间和虚拟空间的对应<ul><li>磁盘-文件系统缓存-用户进程的文件区  </li></ul></li><li>用户读写文件时通过fsipc，把文件块在fs进程对应的块缓存读到用户的文件映射区，而fs进程的块缓存通过ide与磁盘交互。  </li></ul><img src="/2022/05/31/OS-lab5-summary/1.jpg" class="" title="pic1"><ul><li>多角色间的协作<ul><li>在做完lab4梳理系统调用、fork、页缺失处理的时候，反观出现在lab4的ipc通信机制，我总觉得它和Lab4的内容格格不入。因为感觉Lab4的内核态和用户态通过系统调用浑然一体地联系了起来，包办好了这三项任务，而此时出现的负责用户进程和用户进程地通信机制ipc看上去是那么不合时宜。<del>所以个人觉得 lab4的两次extra都是关于ipc的考题，是否有些重点偏了呢（x</del></li><li>是在lab5通过文件系统服务的流程梳理，明确了用户进程和服务进程两个用户态进程，才理清楚进程之间ipc机制的流程。</li><li>以下是fs进程的初始化：<img src="/2022/05/31/OS-lab5-summary/2.jpg" class="" title="pic1"></li></ul></li><li>两次ipc机制<ul><li>第一次ipc：<ul><li>用户进程fsipc()的ipc_send()唤醒被ipc_recv()阻塞的fs进程。</li><li>用户进程ipc_send()的页面为req结构体，把用户进程的请求信息传递给fs进程，写进fs进程的dstva为fs进程的REQVA页。</li><li>此后fs进程执行文件服务函数，用户进程被fsipc()的ipc_recv()阻塞，此时的待写入页面为INDEX2FD(fd)页面，此页面需要fs进程执行完文件服务后填入文件的相关信息。</li></ul></li><li>第二次ipc:<ul><li>fs进程执行过程中，把获取到的文件信息保存在<code>struct Open o = opentab[i]</code>结构体中的o_ff页面。（此页面为open_alloc时使用系统调用alloc）。</li><li>fs进程执行完文件服务后，ipc_send()唤醒被ipc_recv()阻塞的用户进程，把写入了文件信息的页面o-&gt;o_ff作为ipc的srcva，映射给用户进程的待写入页面dstva:INDEX2FD(fd)。</li><li>这也是理解难度最大的一个页面:实际上<code>opentab[i].o_ff,fd,ffd</code>这一些虚拟页面都指向同一个物理页面。由于这个页面先是在opentab[i]里判断o_ff地址的pp_ref，再进入没有break的两个case分支，使得o_ff地址在fs进程里alloc出物理页面p，再在fs进程和用户进程之间以ipc映射。映射给用户进程的dstva。dstva在用户进程下的一个名字是fd，另一个名字是ffd。实际上fd和ffd不仅所对物理页面一样，他们作为指针保存的虚拟地址dstva也是一样的。这个页面在两个进程里都不好理解，所以可以说是lab5最大的难点吧…  </li></ul></li></ul></li></ul><img src="/2022/05/31/OS-lab5-summary/3.jpg" class="" title="pic1"><img src="/2022/05/31/OS-lab5-summary/4.jpg" class="" title="pic1"><ul><li>用户文件读写流程、用户通过fsipc机制调用的文件服务接口  </li></ul><img src="/2022/05/31/OS-lab5-summary/5.jpg" class="" title="pic1"><h1 id="二、思考题"><a href="#二、思考题" class="headerlink" title="二、思考题"></a>二、思考题</h1><h2 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h2><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？  </p></blockquote><p>BY2FILE = 256，一个文件控制块为256B。<br>BY2BLK = 4096，一个磁盘块4KB。<br>因此一个磁盘块中包含4KB / 256B = 16个文件控制块。<br>一个目录包含1024个指向磁盘块的指针，即最多有1024 * 16 = 16384个文件。<br>1024个磁盘块共1024 * 4KB = 4MB。单个文件最大为4MB。</p><h2 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h2><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？  </p></blockquote><p>DISKMAX = 0x40000000，因此支持的最大磁盘大小为1GB。</p><h2 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h2><blockquote><p>在lab5 中，fs/fs.h、include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，并进行解释，写出其主要应用之处。 </p></blockquote><ul><li>user/fd.h 这两个宏用来找fd对应的文件信息页面和文件缓存区地址<pre><code>#define INDEX2FD(i)    (FDTABLE+(i)*BY2PG)#define INDEX2DATA(i)    (FILEBASE+(i)*PDMAP)</code></pre></li><li>文件服务函数调用号，可以重用user/fsipc.c的fsipc()函数，作为进程间通信的value，用户进程传给文件服务系统的fs/serve()<pre><code>#define FSREQ_OPEN    1#define FSREQ_MAP    2#define FSREQ_SET_SIZE    3#define FSREQ_CLOSE    4#define FSREQ_DIRTY    5#define FSREQ_REMOVE    6#define FSREQ_SYNC    7</code></pre></li></ul><h2 id="Thinking-5-8"><a href="#Thinking-5-8" class="headerlink" title="Thinking 5.8"></a>Thinking 5.8</h2><blockquote><p>阅读 user/file.c ，你会发现很多函数中都会将一个 struct Fd * 型的指针转换为 struct Filefd * 型的指针，请解释为什么这样的转换可行。  </p></blockquote><p>在结构体Filefd中储存的第一个元素就是struct Fd*，因而对于相匹配的一对struct Fd和struct Filefd，他们的指针实际上指向了相同的虚拟地址INDEX2FD(fd)</p><h2 id="Thinking-5-9"><a href="#Thinking-5-9" class="headerlink" title="Thinking 5.9"></a>Thinking 5.9</h2><blockquote><p>在 lab4 的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。  </p></blockquote><p> fork 前后的父子进程共享文件描述符和定位指针。<br>验证程序：  </p><pre><code class="c">#include &quot;lib.h&quot;static char *msg = &quot;This is the NEW message of the day!\n\n&quot;;static char *diff_msg = &quot;This is a different massage of the day!\n\n&quot;;void umain()&#123;        int r;        int fdnum;        char buf[512];        int n;        if ((r = open(&quot;/newmotd&quot;, O_RDWR)) &lt; 0) &#123;            user_panic(&quot;open /newmotd: %d&quot;, r);        &#125;        fdnum = r;        writef(&quot;open is good\n&quot;);        if ((n = read(fdnum, buf, 511)) &lt; 0) &#123;            user_panic(&quot;read /newmotd: %d&quot;, r);        &#125;        if (strcmp(buf, diff_msg) != 0) &#123;            user_panic(&quot;read returned wrong data&quot;);        &#125;        writef(&quot;read is good\n&quot;);        int id;        if ((id = fork()) == 0) &#123;            if ((n = read(fdnum, buf, 511)) &lt; 0) &#123;                user_panic(&quot;child read /newmotd: %d&quot;, r);            &#125;            if (strcmp(buf, diff_msg) != 0) &#123;                user_panic(&quot;child read returned wrong data&quot;);            &#125;            writef(&quot;child read is good &amp;&amp; child_fd == %d\n&quot;,r);            struct Fd *fdd;            fd_lookup(r,&amp;fdd);            writef(&quot;child_fd&#39;s offset == %d\n&quot;,fdd-&gt;fd_offset);        &#125;        else &#123;            if((n = read(fdnum, buf, 511)) &lt; 0) &#123;                user_panic(&quot;father read /newmotd: %d&quot;, r);            &#125;            if (strcmp(buf, diff_msg) != 0) &#123;                user_panic(&quot;father read returned wrong data&quot;);            &#125;            writef(&quot;father read is good &amp;&amp; father_fd == %d\n&quot;,r);            struct Fd *fdd;            fd_lookup(r,&amp;fdd);            writef(&quot;father_fd&#39;s offset == %d\n&quot;,fdd-&gt;fd_offset);        &#125;&#125;</code></pre><p>结果：  </p><pre><code>main.c: main is start ...init.c: mips_init() is calledPhysical memory: 65536K available, base = 65536K, extended = 0Kto memory 80401000 for struct page directory.to memory 80431000 for struct Pages.pmap.c:  mips vm init successpageout:        @@@___0x7f3fe000___@@@  ins a page pageout:        @@@___0x40d000___@@@  ins a page FS is runningFS can do I/Opageout:        @@@___0x7f3fe000___@@@  ins a page pageout:        @@@___0x407000___@@@  ins a page superblock is gooddiskno: 0diskno: 0read_bitmap is gooddiskno: 0alloc_block is goodfile_open is goodfile_get_block is goodfile_flush is goodfile_truncate is gooddiskno: 0file rewrite is goodserve_open 00000400 ffff000 0x2open is goodread is goodfather read is good &amp;&amp; father_fd == 0father_fd&#39;s offset == 41[00000400] destroying 00000400[00000400] free env 00000400i am killed ... child read is good &amp;&amp; child_fd == 0child_fd&#39;s offset == 41[00001402] destroying 00001402[00001402] free env 00001402i am killed ... </code></pre><h2 id="Thinking-5-10"><a href="#Thinking-5-10" class="headerlink" title="Thinking 5.10"></a>Thinking 5.10</h2><blockquote><p>请解释 Fd, Filefd, Open 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。 </p></blockquote><pre><code class="c">struct Fd &#123;     u_int fd_dev_id;     // 外设的id。     //用户使用fd.c的文件接口时，不同的dev_id会调取不同的文件服务函数。     //比如File类型的文件服务函数为user/File.c的file_*()函数。     u_int fd_offset;     // 读写的偏移量     //seek()时修改。     //offset会被用来找起始filebno文件块号。     u_int fd_omode;      // 打开方式，包括只读、只写、读写     //req和open结构体都会用到&#125;;struct Filefd &#123;     struct Fd f_fd;     // file descriptor     u_int f_fileid;     // 文件的id     //模1024后会用来在opentab[]里索引open结构体     struct File f_file; // 对应文件的文件控制块&#125;;struct Open &#123;     struct File *o_file;    // 指向打开的文件     u_int o_fileid;         // 打开文件的id     int o_mode;             // 打开方式     struct Filefd *o_ff;    // 指向读写的位置（偏移）&#125;;</code></pre><ul><li>结构体均为内存数据，记录了文件信息。</li><li>Filefd以及Open中的指向的文件控制块File中记录的磁盘指针对应物理实体。</li></ul><h2 id="Thinking-5-11"><a href="#Thinking-5-11" class="headerlink" title="Thinking 5.11"></a>Thinking 5.11</h2><blockquote><p>上图中有多种不同形式的箭头，请结合 UML 时序图的规范，解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><ul><li>ENV_CREATE(user_env)和ENV_CREATE(fs_serv)都是异步消息，由init()发出创建消息后，init()函数即可返回执行后续步骤，由fs和user线程执行自己的初始化工作。</li><li>fs线程初始化serv_init()和fs_init()完成后，进入serv()函数，被ipc_receive()阻塞为ENV_NOT_RUNNABLE，直到收到User线程的ipc_send(fsreq)被唤醒。</li><li>User线程向fs线程ipc_send(fsreq)发送请求为同步消息，发送后自身进入阻塞ENV_NOT_RUNNABLE等待被唤醒的fs线程服务结束时ipc_send(dst_va),用户线程接收到数据后继续运行，此后fs线程进入阻塞，等待下次被用户唤醒。</li></ul><h2 id="Thinking-5-12"><a href="#Thinking-5-12" class="headerlink" title="Thinking 5.12"></a>Thinking 5.12</h2><blockquote><p>阅读serv.c/serve函数的代码，我们注意到函数中包含了一个死循环for (;;) {…}，为什么这段代码不会导致整个内核进入 panic 状态？  </p></blockquote><p>serve调用ipc_recv函数后会将自身状态变为ENV_NOT_RUNNABLE，进入等待状态。其他进程发出文件系统请求后才被唤醒并开始服务。</p><h1 id="三、体会与感想"><a href="#三、体会与感想" class="headerlink" title="三、体会与感想"></a>三、体会与感想</h1><ul><li>lab5的感觉是填空代码量锐减，但是需要阅读的代码量骤增，一个文件的open操作的函数嵌套层数也是让我大开眼界:)。所以一开始区区18页的指导书让我以为lab5很简单:) 我觉得lab5的复杂度和lab4不相上下，尽管理解上比中断、页缺失容易很多。</li><li>lab5的局部代码理解起来比前边lab更快，可能是因为内核态用户态的接口切换 和 线程间的通信协作在lab4有过涉及，文件索引函数等与lab2的内存管理大体结构比较相似，对于宏函数、指针、结构体以及函数间的调用和异常的写法在前边的lab都有了很好的练习。</li><li>从lab4到lab5更加体会到MOS操作系统设计方面的精巧，各lab之间环环相扣，借助之前lab的代码实现本次lab的新功能，看着自己写的操作系统一步步有了更加完善的功能是非常有趣的一种感受。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-Unix-Linux下C语言实现MyShell</title>
      <link href="/2022/05/04/Unix-MyShell-Summary/"/>
      <url>/2022/05/04/Unix-MyShell-Summary/</url>
      
        <content type="html"><![CDATA[<img src="/2022/05/04/Unix-MyShell-Summary/main.png" class="" title="pic1"><span id="more"></span><h1 id="一、功能概述"><a href="#一、功能概述" class="headerlink" title="一、功能概述"></a>一、功能概述</h1><h2 id="1-1-高亮提示"><a href="#1-1-高亮提示" class="headerlink" title="1.1 高亮提示"></a>1.1 高亮提示</h2><img src="/2022/05/04/Unix-MyShell-Summary/highlight.png" class="" title="pic1"><ul><li>myShell运行的起始提示</li><li>命令提示符前<code>Musel&#39;s shell</code>的前缀标识</li><li>当前路径提示</li><li>Error的报错提示</li></ul><h2 id="1-2-cd切换目录"><a href="#1-2-cd切换目录" class="headerlink" title="1.2 cd切换目录"></a>1.2 cd切换目录</h2><img src="/2022/05/04/Unix-MyShell-Summary/cd.png" class="" title="pic1"><h2 id="1-3-标准I-O重定向"><a href="#1-3-标准I-O重定向" class="headerlink" title="1.3 标准I/O重定向"></a>1.3 标准I/O重定向</h2><img src="/2022/05/04/Unix-MyShell-Summary/io.png" class="" title="pic1"><h2 id="1-4-可变长参数命令的运行"><a href="#1-4-可变长参数命令的运行" class="headerlink" title="1.4 可变长参数命令的运行"></a>1.4 可变长参数命令的运行</h2><img src="/2022/05/04/Unix-MyShell-Summary/cmd.png" class="" title="pic1"><h2 id="1-5-管道连接多条命令"><a href="#1-5-管道连接多条命令" class="headerlink" title="1.5 管道连接多条命令"></a>1.5 管道连接多条命令</h2><img src="/2022/05/04/Unix-MyShell-Summary/pipe.png" class="" title="pic1"><h2 id="1-6-管道、重定向、命令格式的错误检查"><a href="#1-6-管道、重定向、命令格式的错误检查" class="headerlink" title="1.6 管道、重定向、命令格式的错误检查"></a>1.6 管道、重定向、命令格式的错误检查</h2><img src="/2022/05/04/Unix-MyShell-Summary/error.png" class="" title="pic1"><h2 id="1-7-exit退出myShell"><a href="#1-7-exit退出myShell" class="headerlink" title="1.7 exit退出myShell"></a>1.7 exit退出myShell</h2><img src="/2022/05/04/Unix-MyShell-Summary/exit.png" class="" title="pic1"><h2 id="1-8-malloc与free"><a href="#1-8-malloc与free" class="headerlink" title="1.8 malloc与free"></a>1.8 malloc与free</h2><ul><li>管道连接命令数、命令参数个数、参数长度均不定长，所以使用malloc申请存储空间，避免内存浪费。</li><li>单条命令执行完后调用free释放命令申请的空间，防止内存泄漏。</li></ul><h1 id="二、系统调用"><a href="#二、系统调用" class="headerlink" title="二、系统调用"></a>二、系统调用</h1><p>在第三部分会结合具体功能具体阐述系统调用。此处作简要汇总：</p><ul><li>获取当前目录：<code>path = getcwd(NULL, 0)</code></li><li>切换工作目录：<code>chdir(command-&gt;args[1])</code></li><li>创建进程：<code>pid_t pid = fork()</code></li><li>打开文件描述符表：<code>open(command-&gt;read, O_RDONLY, 0666)</code></li><li>复制文件描述符表：<code>dup2(in, 0)</code></li><li>执行程序：<code>execvp(command-&gt;cmd, command-&gt;args)</code></li><li>父进程等待子进程退出：<code>wait(&amp;status)</code></li><li>父进程获取子进程退出状态：<code>WIFEXITED(status)</code></li><li>创建与关闭管道：<code>pipe(fd);close(fd[0]);</code></li><li>退出进程：<code>exit(0)</code></li></ul><h1 id="三、功能实现与流程图"><a href="#三、功能实现与流程图" class="headerlink" title="三、功能实现与流程图"></a>三、功能实现与流程图</h1><img src="/2022/05/04/Unix-MyShell-Summary/myShell.png" class="" title="pic1"><h2 id="3-1-宏定义"><a href="#3-1-宏定义" class="headerlink" title="3.1 宏定义"></a>3.1 宏定义</h2><h3 id="3-1-1-单行命令的输入与解析规模"><a href="#3-1-1-单行命令的输入与解析规模" class="headerlink" title="3.1.1 单行命令的输入与解析规模"></a>3.1.1 单行命令的输入与解析规模</h3><pre><code class="c">#define ARGS_COUNT 8        //单条命令的参数个数#define COMMANDS_COUNT 8    //管道连接的命令个数#define BUF_SIZE 128        //单行命令的字符数</code></pre><h3 id="3-2-2-命令格式的错误检查"><a href="#3-2-2-命令格式的错误检查" class="headerlink" title="3.2.2 命令格式的错误检查"></a>3.2.2 命令格式的错误检查</h3><pre><code class="c">#define ERROR_EMPTY(errorStr)       //起始或管道符号后未输入合法命令#define ERROR_STR                   //字符串格式错误，后引号丢失#define ERROR_FORK                  //创建子进程失败#define ERROR_OPEN                  //重定向的读文件不存在#define ERROR_EXECUTE(errorCmd)     //命令执行失败：命令类型或参数不合法#define ERROR_EXIT                  //子进程退出失败</code></pre><h2 id="3-2-打印当前路径"><a href="#3-2-打印当前路径" class="headerlink" title="3.2 打印当前路径"></a>3.2 打印当前路径</h2><p><code>print_current_directory()</code>函数调用<code>path = getcwd(NULL, 0)</code>获取当前工作目录。</p><h2 id="3-3-拆分管道连接的多条命令和重定向文件名"><a href="#3-3-拆分管道连接的多条命令和重定向文件名" class="headerlink" title="3.3 拆分管道连接的多条命令和重定向文件名"></a>3.3 拆分管道连接的多条命令和重定向文件名</h2><img src="/2022/05/04/Unix-MyShell-Summary/parse.png" class="" title="pic1"><img src="/2022/05/04/Unix-MyShell-Summary/split.png" class="" title="pic1"><ul><li>fgets获取输入、malloc命令结构体、标志本次输入的命令条数为1</li><li><code>splitCommands(buf, commands)</code><ul><li>初始化命令结构体：<ul><li>标志状态为<strong>等待命令</strong>，即<code>waitCommand</code>置位：此时如果接受到管道符号、重定向符号、字符串、回车终止符均会由相关宏抛出ERROR_EMPTY</li><li>初始化本条命令的结构体</li><li>malloc申请参数数组</li></ul></li><li>识别到命令</li><li>持续识别本条命令的命令参数与重定向标志，直到管道符号或回车符<ul><li>可识别的命令参数：无特殊符号的字符串、单双引号标志的字符串。记录在args参数数组中。</li><li>重定向标志：识别到<code>&lt; &gt; &gt;&gt;</code>后调用<code>fetchFileName()</code>识别重定向文件名，记录在命令结构体中。如果文件格式不对会由相关宏抛出ERROR_IOFILE</li></ul></li><li>识别到管道符号<ul><li>标记本条命令的参数数组的最后一个参数(*args)为NULL。目的是便于execvp(command)和free(commands)。</li><li>命令条数++</li><li>初始化下一条命令结构体，继续读取下一条命令</li></ul></li><li>识别到回车符：<ul><li>标记本条命令的参数数组的最后一个参数<code>(*args) = NULL</code>。</li><li>标记命令数组的最后一个命令<code>commans-&gt;cmd = NULL</code>。目的是便于<code>execvp(command)</code>和<code>free(commands)</code>。</li></ul></li></ul></li></ul><h2 id="3-4-如果拆分命令未出现异常，逐条执行命令commands"><a href="#3-4-如果拆分命令未出现异常，逐条执行命令commands" class="headerlink" title="3.4 如果拆分命令未出现异常，逐条执行命令commands"></a>3.4 如果拆分命令未出现异常，逐条执行命令commands</h2><img src="/2022/05/04/Unix-MyShell-Summary/exe.png" class="" title="pic1"><h3 id="3-4-1-逐条执行指令，使用管道连接父子进程数据"><a href="#3-4-1-逐条执行指令，使用管道连接父子进程数据" class="headerlink" title="3.4.1 逐条执行指令，使用管道连接父子进程数据"></a>3.4.1 逐条执行指令，使用管道连接父子进程数据</h3><p><code>executeCommands(commands)</code></p><ul><li>命令数commandsCount = 1：<ul><li>不用创建管道，不从pipe读取重定向I/O，fd_in和fd_out为-1</li><li><code>forkToExecute(commands,-1,-1)</code>创建子进程并执行</li></ul></li><li>命令数commandsCount = 2：<ul><li>此时重定向方向为：第一条命令写 -&gt; 第二条命令读。故创建一条管道<code>pipe(fd);</code>即可；</li><li>为第一条指令创建子进程，执行第一条指令的子进程不使用此管道的读指针（没有前序命令为此命令提供输入），fd_in设置为-1；使用写指针fd[1].</li><li>第一条指令结束后其子进程退出。父进程关闭此管道的fd[1],释放第一条指令结构体。</li><li>父进程为第二条指令创建子进程，执行第二条指令的子进程使用此管道的读指针fd[0]，不使用此管道的写指针（没有后续命令需要此命令的输出），fd_out设置为-1。</li><li>第二条指令结束后其子进程退出。父进程关闭此管道的fd[1],释放第二条指令结构体。</li></ul></li><li>命令数commandsCount &gt; 2: <ul><li>与上述大致相同，基本遵循：<strong>pipe()-&gt;fork()-&gt;execute()-&gt;close()-&gt;free()</strong></li><li>多命令的管道需要保证两条管道同时开启：见源码下的分析<pre><code class="c">    int *pipes[2];    pipes[0]=(int *)malloc(sizeof(int)*2);    pipes[1]=(int *)malloc(sizeof(int)*2);    int newPoint = 0;    pipe(pipes[newPoint]);    forkToExecute(commands,-1,(pipes[newPoint])[1]);    close((pipes[newPoint])[1]);    freeCommand(commands++);    for (int i = 1; i &lt; (commandsCount - 1); ++i) &#123;        newPoint = 1-newPoint;                pipe(pipes[newPoint]);        forkToExecute(commands,(pipes[1-newPoint])[0],(pipes[newPoint])[1]);        close((pipes[1-newPoint])[0]);        close((pipes[newPoint])[1]);        freeCommand(commands++);    &#125;    forkToExecute(commands,(pipes[newPoint])[0],-1);    close((pipes[newPoint])[0]);    freeCommand(commands);</code></pre></li></ul></li></ul><h4 id="关于pipe-close-与fork-父子进程的理解："><a href="#关于pipe-close-与fork-父子进程的理解：" class="headerlink" title="关于pipe(),close()与fork()父子进程的理解："></a>关于pipe(),close()与fork()父子进程的理解：</h4><blockquote><p>(由于网上资料并不多，以下仅为根据程序的运行结果做出的个人理解,正确性未知)</p></blockquote><h5 id="pipe-int-fd-2-："><a href="#pipe-int-fd-2-：" class="headerlink" title="pipe(int fd[2])："></a>pipe(int fd[2])：</h5><ul><li>malloc是用户区的申请。而pipe类似于<strong>内核区域</strong>的malloc。</li><li>pipe相当于在内核缓冲区<strong>申请</strong>一片空间，用于存放数据。类似多线程生产者消费者模式的table，供不同线程不同时间的读取。<h5 id="int-fd-2-："><a href="#int-fd-2-：" class="headerlink" title="int fd[2]："></a>int fd[2]：</h5></li><li>fd为<strong>内核缓冲区指针</strong>的数组，fd[0]为此缓冲区的<strong>读指针</strong>，fd[1]为<strong>写指针</strong>。<h5 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h5></li><li>在内核缓冲区申请的空间的<strong>释放</strong>：需要<strong>两个条件</strong>，即<strong>四次操作</strong>：<ul><li>一次pipe得到的空间，<strong>只允许发生且必须发生</strong>一次读和一次写。</li><li>必须在读后关闭读指针close(fd[0]);必须在写后关闭写指针close(fd[1]);</li><li>完成上述条件后，此段空间自动释放。<h5 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h5></li></ul></li><li>一个进程创建pipe(int fd[2])，只供自己读取是没有意义的，因为可以在用户区malloc也能实现同等效果。pipe一般**与fork()**配合使用，目的是用于不同进程之间的数据传输。</li><li>学过OS的进程管理以后非常容易理解：因为不同进程自身占用各自的用户区虚拟空间，而<strong>不同进程</strong>之间<strong>共享</strong>相同的<strong>内核</strong>虚拟空间。一个<strong>进程结束</strong>后，自身<strong>用户区</strong>的虚拟空间中的数据随之<strong>消失</strong>。</li><li>那么pipe的应用场景是，当一个进程运行后产生数据后就消亡。而另一个进程在<strong>上个进程消亡后</strong>才开始运行，需要获取上个进程运行的数据。这时候上个进程的数据只能<strong>写入内核区</strong>才能保存，即在**地址fd[1]**写数据。</li><li>造成此种应用场景的原因是:<ul><li>① Linux支持的众多指令是靠<strong>调用内核程序</strong>实现的。所以当shell把用户命令解析出命令和命令参数后，通过c库函数<code>execvp(command-&gt;cmd, command-&gt;args)</code>等实现调用内核程序的效果。该函数成功执行后，<strong>调用此函数的进程结束</strong>，此函数的后续指令并不会再运行。</li><li>② c语言用于并行操作的<strong>fork函数</strong>。其模式是这样的：所以可以看到，当子进程调用执行函数执行命令后，子进程消亡。父进程需要等待子进程结束后再工作。   <pre><code class="c">pid_t pid = fork();if (pid &lt; 0) &#123;         //子进程创建失败，不会进入此分支     &#125;else if (pid == 0) &#123;        //子进程创建成功，进入此分支。        //此分支执行子进程操作        Execute and Write (to fd[1] in kernel buffer);&#125; else &#123;        //由于fork()函数有两个返回值        //所以如果子进程创建成功，进入上个分支后，也会进入这个分支        //此分支执行父进程操作        Wait;        Fetch Data (from fd[0] in kernel buffer) and continue;&#125;</code></pre><h5 id="close-的时机"><a href="#close-的时机" class="headerlink" title="close()的时机"></a>close()的时机</h5></li><li>父进程在fork()前pipe(fd)，fork()后父子进程共享相同的fd。</li><li>子进程执行时写fd[1]。返回到父进程时由父进程close(fd[1]).</li><li>父进程再次创建新的子进程执行下一条指令，子进程执行时读fd[0]。如果此命令后续还有指令，那么子进程再写另一条新管道的newfd[1].子进程执行完毕返回到父进程时，由父进程close(fd[0]).至此fd的缓冲区完成两次关闭和一写一读，被释放。由于已经写过新管道的newfd[1]，此时父进程也要close(newfd[1]).</li><li>原则是创建新进程前pipe，子进程负责读写fd，父进程负责关闭fd。</li></ul></li></ul><h3 id="3-4-2-创建子进程，执行单条指令"><a href="#3-4-2-创建子进程，执行单条指令" class="headerlink" title="3.4.2 创建子进程，执行单条指令"></a>3.4.2 创建子进程，执行单条指令</h3><p><code>forkToExecute(Command *command, int fd_in, int fd_out)</code></p><ul><li>exit : 释放命令结构体并退出shell</li><li>cd ：系统调用<code>chdir(command-&gt;args[1])</code>切换工作目录</li><li>外部命令：<ul><li>fork()创建子进程</li><li>command结构体中读出重定向文件：<code>int open(const char *pathname, int oflag, [mode_t mode])</code>系统调用获得文件描述符表</li><li>重定向：<code>dup2(in, 0);dup2(out, 1);</code></li><li>子进程运行命令<code>execvp(command-&gt;cmd, command-&gt;args)</code></li><li>父进程等待子进程结束后运行下一条命令</li></ul></li></ul><h2 id="3-5-释放本次输入的commands数组，等待用户的下一次输入"><a href="#3-5-释放本次输入的commands数组，等待用户的下一次输入" class="headerlink" title="3.5 释放本次输入的commands数组，等待用户的下一次输入"></a>3.5 释放本次输入的commands数组，等待用户的下一次输入</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab4</title>
      <link href="/2022/05/03/OS-lab4-summary/"/>
      <url>/2022/05/03/OS-lab4-summary/</url>
      
        <content type="html"><![CDATA[<p>操作系统 Lab4：系统调用与FORK</p><span id="more"></span><h1 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h1><h2 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h2><blockquote><p>内核在保存现场的时候是如何避免破坏通用寄存器的？  </p></blockquote><ul><li><code>move    k0,sp</code>：先把通用寄存器的sp复制到$k0</li><li><code>sw    k0,TF_REG29(sp)、sw    $2,TF_REG2(sp)</code>：保存现场需要使用$v0作为协寄存器到内存的中转寄存器，写到内存时需要$sp，所以在正式保存协寄存器和通用寄存器前先保存这两个寄存器</li></ul><blockquote><p>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用msyscall 留下的信息吗？  </p></blockquote><p>可以。从用户函数<code>syscall_*()</code>到内核函数<code>sys_*()</code>时，$a1-$a3未改变,$a0在<code>handle_sys()</code>的时候被修改为内核函数的地址，但在内核函数<code>sys_*()</code>仅为占位符，不会被用到。  </p><blockquote><p>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时<br>同样的参数的？  </p></blockquote><ul><li>用户调用时的参数：用户进程的寄存器现场(保存在了内核栈的TF_4-TF_7)的$a0-$a3;用户栈(栈指针为用户现场的sp)的参数a4a5</li><li>把上面两部分参数分别拷贝至内核现场寄存器$a0-$a3和内核栈。  </li></ul><blockquote><p>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是？  </p></blockquote><ul><li>返回值存入$v0</li><li>PC+4,跳转到下一条指令。如果是延迟槽指令异常，PC不变。</li></ul><h2 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h2><blockquote><p>请回顾 lib/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。</p></blockquote><ul><li><code>mkenvid()</code>有有效位，所以不会返回0</li><li><code> envid2env()</code>的envid为0时返回curenv。</li><li>由于curenv为内核态的变量，用户态不能获取curenv的envid，所以用0代表curenv-&gt;envid。</li><li>目的是方便用户进程调用syscall_*()时把当前进程的envid作为参数传给内核函数，即方便用户态在内核变量不可见的情况下调用内核接口。</li></ul><h2 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h2><blockquote><p>子进程完全按照 fork() 之后父进程的代码执行，说明了什么？  </p></blockquote><p>fork()后子进程的data段和text段与父进程相同</p><blockquote><p>但是子进程却没有执行 fork() 之前父进程的代码，又说明了什么？ </p></blockquote><p>PC从fork后的指令开始执行，子进程恢复到的上下文位置是fork函数。</p><h2 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h2><blockquote><p>关于 fork 函数的两个返回值，下面说法正确的是：<br>A、fork 在父进程中被调用两次，产生两个返回值<br>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值<br>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值<br>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值   </p></blockquote><p>C</p><h2 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h2><blockquote><p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合本章的后续描述、mm/pmap.c中 mips_vm_init 函数进行的页面映射以及 include/mmu.h 里的内存布局图进行思考。  </p></blockquote><ul><li>USTACKTOP以下的应该映射。</li><li>USTACKTOP到UTOP之间的 user exception stack 是用来进行页写入异常的，不会在处理COW异常时调用fork(),所以 user exception stack 这一页不需要共享。</li><li>USTACKTOP到UTOP之间的 invalid memory 是为处理页写入异常时做缓冲区用的，所以同理也不需要共享。</li><li>UTOP以上页面的内存与页表是所有进程共享的，且用户进程无权限访问，不需要做父子进程间的duppage。</li></ul><h2 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h2><blockquote><p>在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个“指针的指针”，请参考 user/entry.S 和 include/mmu.h 中的相关实现，思考并回答这几个问题：<br>• vpt 和 vpd 的作用是什么？怎样使用它们？<br>• 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？<br>• 它们是如何体现自映射设计的？<br>• 进程能够通过这种方式来修改自己的页表项吗？  </p></blockquote><ul><li>作用：在用户态下通过访问进程自己的物理内存获取用户页的页目录项页表项的perm，用于duppage根据不同的perm类型在父子进程间执行不同的物理页映射</li><li>mmu.h 中，声明vpt和vpd的类型：</li></ul><pre><code class="c">extern volatile Pte* vpt[];extern volatile Pde* vpd[];</code></pre><ul><li>使用：<ul><li>vpd是类型为页表项指针Pde *数组，即int *的数组；vpt同理。</li><li>以vpt举例，vpt是Pte *数组指针，(*vpt)代表第一个pte*，也就是第一个页表项的地址。</li><li>第i个页表项：*((*vpt)+i)，也就是(*vpt)[i]</li></ul></li><li>由于用户进程下的系统调用的虚拟内存管理的函数传入的pgdir均为env结构体的kuseg的进程页目录，并且<code>env_setup_vm()时</code>把页目录进行自映射<code>e-&gt;env_pgdir[PDX(UVPT)]  = e-&gt;env_cr3</code>，所以实现了用户进程的虚拟内存管理，可以通过两级页表机制访问</li><li>user/entry.S文件中，初始化了vpt和vpd的地址，在kuseg范围：  </li></ul><pre><code class="js">vpt:    .word UVPT    .globl vpdvpd:    .word (UVPT+(UVPT&gt;&gt;12)*4)</code></pre><p>此处也体现了自映射设计。kuseg范围内只给VPT留出了1024*BY2PG的大小，没有给VPD设置额外BY2PG。</p><ul><li>可以，因为在pmap.c中实现的虚拟内存机制，给页表项和页目录项的perm均为可写。</li></ul><h2 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h2><blockquote><p>page_fault_handler 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：<br>• 这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？<br>• 内核为什么需要将异常的现场 Trapframe 复制到用户空间？  </p></blockquote><ul><li>当出现COW异常时，需要使用用户态的系统调用发生中断，即中断重入</li><li>由于处理COW异常时调用的<code>handle_mod()</code>函数把epc改为用户态的异常处理函数<code>__asm_pgfault_handler</code>(env结构体的env_pgfault_handler域)，退出内核中断后跳转到epc所在的用户态的异常处理函数。由于用户态把异常处理完毕后仍然在用户态恢复现场，所以此时要把内核保存的现场保存在用户空间的用户异常栈。</li></ul><h2 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h2><blockquote><p>到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：<br>• 在用户态处理页写入异常，相比于在内核态处理有什么优势？<br>• 从通用寄存器的用途角度讨论，在可能被中断的用户态下进行现场的恢复，要如何做到不破坏现场中的通用寄存器？  </p></blockquote><ul><li>解放内核，不用内核执行大量的页面拷贝工作。</li><li>使用存放函数调用返回值的$v0, $v1恢复非通用寄存器，之后通过sp恢复通用寄存器，最后恢复$sp</li></ul><h2 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h2><blockquote><p>• 为什么需要将 set_pgfault_handler 的调用放置在 syscall_env_alloc 之前？<br>• 如果放置在写时复制保护机制完成之后会有怎样的效果？<br>• 子进程是否需要对在 entry.S 定义的字 __pgfault_handler 赋值？  </p></blockquote><ul><li><code>syscall_env_alloc()</code>返回后父子进程各自执行自己的进程，子进程需要修改entry.S中定义的env指针，涉及到对COW页面的修改，会触发COW写入异常，COW中断的处理机制依赖于set_pgfault_handler。所以<code>set_pgfault_handler</code>要放在<code>syscall_env_alloc()</code>之前。</li><li>写时复制保护机制会把entry.S中定义的__pgfault_handler变量所在的页面被COW保护，而<code>set_pgfault_handler()</code>需要写__pgfault_handler变量。此时会涉及到对COW页面的修改，会触发COW写入异常，COW中断的处理机制依赖于set_pgfault_handler。所以<code>set_pgfault_handler</code>要放在<code>写时复制保护机制duppage()</code>之前。</li><li>不需要，父进程已经在syscall_env_alloc子进程前对在 entry.S 定义的字 __pgfault_handler 赋值，syscall_env_alloc后父子进程共享读即可。</li></ul><h1 id="二、实验难点"><a href="#二、实验难点" class="headerlink" title="二、实验难点"></a>二、实验难点</h1><ul><li><p>如果是延迟槽指令，epc为当前pc,不需要再加4</p></li><li><p>sys_yield(void)时可以使用sched_yield()调度，但是sched_yield()从TIMESTACK中读取现场，所以需要先把现场从KERNEL_SP复制到TIMESTACK中。</p></li><li><p>权限位：</p><ul><li>sys_mem_alloc的页面初始权限为不能设置为COW；只能给当前进程或子进程sys_mem_alloc，所以此处checkperm为1</li><li>sys_mem_map</li></ul></li><li><p>sys_env_alloc要修改子进程的pc为父进程的e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc;返回值 e-&gt;env_tf.regs[2]=0;子进程状态env_status=ENV_NOT_RUNNABLE;</p></li><li><p>内核栈、用户栈和用户异常栈：内核栈保存中断时的现场，用户栈保存系统调用的参数，用户异常栈保存缺页中断时的现场。</p></li><li><p>duppage时父进程需要设置COW权限位时也要使用syscall_mem_map(0, addr, 0, addr, perm | PTE_COW)系统调用进行相同页面的映射从而修改权限位。</p></li><li><p>用户处理COW异常和页面复制时要引入用户异常栈下面的Invalid memory临时区域的原因：用户态处理COW异常，所以使用用户态的bcopy，由于不在内核处理，不能使用dst物理页面的地址进行映射，所以需要使用dst复制页面的虚拟地址。</p></li><li><p>流程图</p><ul><li><p>I/O中断  </p><img src="/2022/05/03/OS-lab4-summary/1.jpg" class="" title="pic1"> </li><li><p>系统调用  </p><img src="/2022/05/03/OS-lab4-summary/2.jpg" class="" title="pic1"></li><li><p>fork  </p><img src="/2022/05/03/OS-lab4-summary/3.jpg" class="" title="pic1"></li><li><p>页缺失处理</p><img src="/2022/05/03/OS-lab4-summary/4.jpg" class="" title="pic1"></li></ul></li></ul><h1 id="三、体会与感想"><a href="#三、体会与感想" class="headerlink" title="三、体会与感想"></a>三、体会与感想</h1><ul><li>对计组P7的知识要求比较高，关于中断的机制了解的更加细致</li><li>用户进程的二进制映像elf执行流程的很多细节可以类比lab1，内存管理的理念和lab2是几乎相同的，lab4有关栈和中断的部分又与lab3联系比较紧密，所以整体上综合了前边的知识，难度也很高，断断续续看了将近一周</li><li>这次的指导书加了很多流程图，对于理解很有帮助</li><li>做完lab4之后参加的Lab3-2的上机，但是extra还是没有顺利做出来，自我反思是除了需要熟悉汇编语法以外，对于中断的机制需要更加深入的理解掌握，比如关于延迟槽出现异常；中断现场从寄存器还是栈取、从哪个栈取；以及需要把汇编和c函数灵活掌握应用，比如中断处理函数可以写c代替写法比较繁琐的汇编。</li></ul><h1 id="四、指导书反馈"><a href="#四、指导书反馈" class="headerlink" title="四、指导书反馈"></a>四、指导书反馈</h1><ul><li><code>sys_mem_alloc</code><ul><li>post-condition：<code>va must be &lt; UTOP</code>应该是pre-condition</li><li><code>env may modify its own address space or the address space of its children</code>很难联想到指的是envid2env的checkperm，可以把注释再细化一些。</li></ul></li><li><code>sys_mem_map</code><ul><li><code>Perm has the same restrictions as in sys_mem_alloc.</code>这句注释容易带来很大误解，sys_mem_alloc对perm的限制是不允许出现COW，而map允许COW。</li></ul></li></ul><h1 id="五、残留问题"><a href="#五、残留问题" class="headerlink" title="五、残留问题"></a>五、残留问题</h1><ul><li>sys_*()函数中，envid2env的checkperm什么时候是1什么时候是0</li><li>sys_mem_map中为什么va需要对齐？sys_mem_alloc需要吗？</li><li>处理COW缺页中断时还会再发生中断吗？观察缺页中断用户态的代码<code>entry.S的__asm_pgfaut_handler()</code>和<code>fork.c的pgfault()</code>，均没有发生修改用户态页面的行为。如果不会再发生中断，那为什么在<code>handle_mod()</code>跳转到<code>trap.c的__pgfault-handler()</code>时要判断tf-&gt;regs[29]是用户栈指针还是异常栈指针呢？</li><li>set_pgfault_handler函数调用sys_set_pgfault_handler系统调用时，对env的赋值的两个域都是常量，为什么不能初始化时候就赋值，要特地系统调用给它赋值呢？</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-Unit2</title>
      <link href="/2022/05/01/OO-Unit2-summary/"/>
      <url>/2022/05/01/OO-Unit2-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="一、电梯的调度策略"><a href="#一、电梯的调度策略" class="headerlink" title="一、电梯的调度策略"></a>一、电梯的调度策略</h1><h2 id="1-1-状态转移图"><a href="#1-1-状态转移图" class="headerlink" title="1.1 状态转移图"></a>1.1 状态转移图</h2><img src="/2022/05/01/OO-Unit2-summary/5.png" class="" title="pic1"><span id="more"></span><h2 id="1-2-纵向电梯的LOOK算法"><a href="#1-2-纵向电梯的LOOK算法" class="headerlink" title="1.2 纵向电梯的LOOK算法"></a>1.2 纵向电梯的LOOK算法</h2><h3 id="LOOK算法实现"><a href="#LOOK算法实现" class="headerlink" title="LOOK算法实现"></a>LOOK算法实现</h3><ul><li>与真实的电梯大致相同的策略，即维护电梯当前运行方向dir，更远层无请求(各楼层的call请求&amp;电梯中乘客的目的地请求)时才转向。  </li><li>为了在实现捎带策略的同时将电梯和调度器功能解耦，电梯应当①具有“短视性”，即并不知道自己的目的楼层，而是仅根据从调度器获取上行、下行的boolean值。在此条件下电梯实现以层间运行时间为最小单位实时更新可稍带目标层。②屏蔽外部各楼层的call请求：按运行方向运行一层后，询问调度器是否应该开门。  </li></ul><h3 id="LOOK算法相较ALS的优势"><a href="#LOOK算法相较ALS的优势" class="headerlink" title="LOOK算法相较ALS的优势"></a>LOOK算法相较ALS的优势</h3><ul><li><p>打破了ALS算法可能出现的<strong>“局部性原理”</strong>。  </p></li><li><p>即ALS算法在将电梯内部乘客全部送达后形成空梯时，会选择最先到达的请求作为主请求。两种策略下对于<strong>中间楼层的捎带表现一致</strong>，但是ALS策略下<strong>低层和高层请求</strong>因为<strong>难于被捎带而堆积</strong>，直到被安排为主请求时才会运行到低层或高层。此类请求容易堆积在末尾才进行集中处理，导致电梯出现因为一个远端请求<strong>空转</strong>(<strong>无捎带</strong>，远端请求的vip专梯)的效率问题。</p></li><li><p>LOOK算法更像是<strong>就近远端捎带</strong>，在将电梯内部乘客全部送达后形成空梯时会沿此方向去处理远端请求，避免了底层和高层请求因为难于捎带而堆积后的空转问题，效率较好。  </p></li></ul><h2 id="1-3-横向电梯"><a href="#1-3-横向电梯" class="headerlink" title="1.3 横向电梯"></a>1.3 横向电梯</h2><h3 id="就近策略"><a href="#就近策略" class="headerlink" title="就近策略"></a>就近策略</h3><ul><li><p>不再需要LOOK算法  </p><p>LOOK算法的优势在于处理纵向梯难于到达的高底层问题，而横向电梯由于下面两个原因不需要LOOK算法。  </p><p>①横向电梯仅5个座    </p><p>②横向电梯可环状运行，即打破纵向电梯1层与10层的时间差    </p></li><li><p>就近策略的实现<br>①判定请求的方向时按<strong>最短运行路径</strong>  </p><p>②同方向捎带  </p><p>③空梯时选择<strong>距离最近</strong>的请求作为主请求  </p></li><li><p>就近策略的电梯利用率比较高，因为总运行路径最短，比较适合横向电梯出现大量请求的情况下使用，比较适合hw7。缺点是开关门的次数比按同方向运行的横向电梯多，顾客等待电梯转到自己方向的时间比较长。不过由于hw6拖后腿的是纵向电梯，所以请求少的时候这种策略也不会很耽误事。  </p></li></ul><h2 id="1-4-性能分析"><a href="#1-4-性能分析" class="headerlink" title="1.4 性能分析"></a>1.4 性能分析</h2><ul><li>hw5实现LOOK算法后性能分98，发现的问题是：调度器在<strong>是否应该开门</strong>时没有考虑<strong>已满员</strong>的情况，导致出现满员时在请求层开门，电梯发现满员不接客，出现空开关门的情况 :(</li><li>所以在hw6重构了纵向电梯优化掉了开关门问题，然而性能分只有96 :( 观察输出后发现主要问题不在调度器的调度策略上，而是重构以后的LOOK算法出了问题：虽然<strong>捎带</strong>要满足<strong>同方向</strong>才可捎带，但是LOOK算法的<strong>远端请求</strong>可以为任意方向。有几个强测85的点观察输出后发现是因为远端请求被一刀切成同方向，导致<strong>反方向的请求没有被LOOK到</strong>不会远端捎带，退化成ALS的主请求造成堆积。  </li><li>个人感觉比较影响hw6性能分的一些85的点的问题并不在调度器策略，对于后两次作业来说，在hw5把LOOK算法实现好就可以保证比较可观的性能分，比起写复杂的调度器算法更符合二八法则 :)</li></ul><h1 id="二、调度器"><a href="#二、调度器" class="headerlink" title="二、调度器"></a>二、调度器</h1><h2 id="2-1-调度器设计"><a href="#2-1-调度器设计" class="headerlink" title="2.1 调度器设计"></a>2.1 调度器设计</h2><h3 id="2-1-1-电梯调度器使用掩码表示楼层请求，取代遍历"><a href="#2-1-1-电梯调度器使用掩码表示楼层请求，取代遍历" class="headerlink" title="2.1.1 电梯调度器使用掩码表示楼层请求，取代遍历"></a>2.1.1 电梯调度器使用掩码表示楼层请求，取代遍历</h3><ul><li>FLOOR[1]为<code>10&#39;b1</code>，FLOOR[3]为二进制<code>10&#39;b100</code></li><li><del>后来Experiment4才知道可以用Bitset</del></li></ul><pre><code class="java">private static final int[] FLOOR = new int[12];public static void init() &#123;        FLOOR[0] = 0;        for (int h = 1;h &lt; 12;h++) &#123;            FLOOR[h] = 1 &lt;&lt; (h - 1);        &#125;&#125;</code></pre><ul><li>掩码表示楼层请求，取代遍历</li></ul><pre><code class="java">private int inElv;//电梯中所有人的目的地private int upCall;//上行请求发出层private int downCall;//下行请求发出层int status = inElv | upCall | downCall;    //判断是否开门    public synchronized boolean isToOpen(boolean dir,int nowFloor) &#123;        boolean order;        int nowCall = ((dir) ? upCall : downCall);         if ((inElv &amp; FLOOR[nowFloor]) &gt; 0) &#123; order =  true; &#125;        else if (((nowCall &amp; FLOOR[nowFloor]) &gt; 0) &amp;&amp; (inNum &lt; capacity)) &#123; order = true; &#125;        else &#123; order = false; &#125;        notifyAll();        return order;    &#125;    //判断远端是否有请求 即判断是否换向，无需遍历    public synchronized boolean furtherNoReq(boolean dir,int nowFloor) &#123;        boolean noReq;        int status = inElv | upCall | downCall;        if (dir) &#123;            noReq = (!(status &gt;= FLOOR[nowFloor + 1]));        &#125; else &#123;            noReq = ((status &amp; (FLOOR[nowFloor] - 1)) == 0);         &#125;        notifyAll();        return noReq;    &#125;</code></pre><h3 id="2-1-2-座调度器分配纵向电梯的调度策略"><a href="#2-1-2-座调度器分配纵向电梯的调度策略" class="headerlink" title="2.1.2 座调度器分配纵向电梯的调度策略"></a>2.1.2 座调度器分配纵向电梯的调度策略</h3><p>①优先分配空梯</p><p>②LOOK算法能捎带的电梯：处在电梯运行方向的远端+加入该请求后此次此方向的可稍带请求不会因此请求的加入导致满员而无法捎带</p><p>上行时的判断<strong>捎带后不满员</strong>的逻辑：</p><pre><code class="java">//维护当前方向的upNum[i]：i层将要进入电梯的人数//维护当前方向的outNum[i]：i层将要下电梯的人数int people = inElvNum;//当前电梯人数for (int i = floor;i &lt;= 9;i++) &#123;    people = people + upNum[i] - outNum[i];    if (people &gt; capacity) &#123;        notifyAll();        return false;    &#125;&#125;notifyAll();return true;</code></pre><p>③无可稍带的电梯，则<strong>上行</strong>请求分配给当前<strong>未处理请求数最少</strong>的<strong>下行</strong>电梯(换向后可处理此请求)；<strong>下行</strong>请求分配给当前<strong>未处理请求数最少</strong>的<strong>上行</strong>电梯</p><h3 id="2-1-3-层调度器分配横向电梯的调度策略"><a href="#2-1-3-层调度器分配横向电梯的调度策略" class="headerlink" title="2.1.3 层调度器分配横向电梯的调度策略"></a>2.1.3 层调度器分配横向电梯的调度策略</h3><ul><li>当前未到达请求数最少的电梯调度器</li></ul><h3 id="2-1-4-hw7的请求拆分策略"><a href="#2-1-4-hw7的请求拆分策略" class="headerlink" title="2.1.4 hw7的请求拆分策略"></a>2.1.4 hw7的请求拆分策略</h3><ul><li>分成五类：纵向直达、横向直达、横+纵、纵+横、纵+横+纵。分别在<code>ProRequest</code>中标记好下一站目的地，投入对应层/座的调度器。</li><li>允许在某一层<strong>乘坐两次横向电梯</strong>扩展横向电梯的可达性：由于横向电梯只有五个座比较容易连通，且为了横向梯的可达性而去一层或其他层中转的纵向时间代价比较大，所以采取<code>Arraylist&lt;NextBuilding&gt;</code>存储横向电梯的两次换乘，以达到尽量<strong>缩减去其他层中转的纵向电梯的代价</strong>。</li></ul><h3 id="2-1-5-调度器的性能分析"><a href="#2-1-5-调度器的性能分析" class="headerlink" title="2.1.5 调度器的性能分析"></a>2.1.5 调度器的性能分析</h3><ul><li>hw6强测96，主要是LOOK算法没有优化好。</li><li>LOOK算法修正后hw7强测98，我认为在调度器的调度策略上还是比较好地符合了二八定律的 :)</li></ul><h2 id="2-2-UML协作图与三次作业的迭代"><a href="#2-2-UML协作图与三次作业的迭代" class="headerlink" title="2.2 UML协作图与三次作业的迭代"></a>2.2 UML协作图与三次作业的迭代</h2><ul><li><p>输入线程、层\座的调度器线程、电梯线程三类线程之间的协作关系由<strong>两类调度器</strong><code>BuildingScheduler``ElevatorScheduler</code>负责<strong>中转请求</strong>、<strong>信息交互</strong>和<strong>计算调度</strong>。后续将结合UML类图具体说明。</p></li><li><p>下图为协作方面的迭代设计。</p></li></ul><img src="/2022/05/01/OO-Unit2-summary/4.png" class="" title="pic1"><h2 id="2-3-协作模式与调度器功能"><a href="#2-3-协作模式与调度器功能" class="headerlink" title="2.3 协作模式与调度器功能"></a>2.3 协作模式与调度器功能</h2><h3 id="hw5-UML类图"><a href="#hw5-UML类图" class="headerlink" title="hw5 UML类图"></a>hw5 UML类图</h3><img src="/2022/05/01/OO-Unit2-summary/1.png" class="" title="pic1"><h3 id="hw5-生产者消费者模式"><a href="#hw5-生产者消费者模式" class="headerlink" title="hw5 - 生产者消费者模式"></a>hw5 - 生产者消费者模式</h3><ul><li><p>仅有输入线程、电梯线程和每个电梯的调度器。</p></li><li><p>中转请求：</p><ul><li>调度器负责接受来自输入线程的请求，把当前楼层的请求发放给电梯。使用生产者消费者模式。</li></ul></li><li><p>信息交互：</p><ul><li><p>调度器作为电梯线程的决策类，综合当前的各层请求和电梯状态，计算电梯的下一步行为。包括：本层是否开门、是否进入等待请求的阻塞状态、是否换向。</p></li><li><p>调度器接受输入线程的终止信号，传递给电梯线程，作为线程结束标志。</p></li></ul></li></ul><h3 id="hw6-UML类图"><a href="#hw6-UML类图" class="headerlink" title="hw6 UML类图"></a>hw6 UML类图</h3><img src="/2022/05/01/OO-Unit2-summary/2.png" class="" title="pic1"><h3 id="hw6-两级调度器"><a href="#hw6-两级调度器" class="headerlink" title="hw6 - 两级调度器"></a>hw6 - 两级调度器</h3><ul><li><p>迭代：增加层/座的调度器<code>BuildingScheduler</code>和调度线程<code>SchedulerThread</code>。</p></li><li><p>中转请求：调度器负责接受来自输入线程的请求，调度线程把请求发放给本层/座特定电梯的调度器。使用生产者消费者模式。</p></li><li><p>计算调度：调度器综合本层/座的各电梯状态，按调度策略<code>choose()</code>选择派遣请求的电梯。</p></li><li><p>信息交互：调度器接受输入线程的终止信号，将其传递给电梯调度器后，作为调度线程结束标志。</p></li></ul><h3 id="hw7-UML类图"><a href="#hw7-UML类图" class="headerlink" title="hw7 UML类图"></a>hw7 UML类图</h3><img src="/2022/05/01/OO-Unit2-summary/3.png" class="" title="pic1"><h3 id="hw7-流水线模式"><a href="#hw7-流水线模式" class="headerlink" title="hw7 - 流水线模式"></a>hw7 - 流水线模式</h3><ul><li><p>迭代：请求分阶段存储；增加<code>RequestCounter</code>作为流水是否结束的计数器。</p></li><li><p>中转请求：未完成请求由电梯线程更新下一流水阶段的目的地，并把请求发放给本层/座调度器。</p></li><li><p>信息交互：完成请求计数器加1.</p></li></ul><h2 id="2-4-调度器的可扩展性"><a href="#2-4-调度器的可扩展性" class="headerlink" title="2.4 调度器的可扩展性"></a>2.4 调度器的可扩展性</h2><p>我认为本单元选择调度器是一种结构清晰、扩展性好的办法。</p><ul><li>层/座的调度器<code>BuildingScheduler</code>和调度线程<code>SchedulerThread</code><ul><li>不论对于楼层和楼座，其基本行为保持一致，都可直接使用，复用性强。</li><li>如果想更换调度策略，只需重载choose()方法即可。</li><li>由于电梯的调度器实现了<code>Sche</code>接口，本级调度器存储的电梯名单为<code>elvList : ArrayList&lt;Sche&gt;</code>类型，所以不仅仅可以作为某层或某座的调度器，还可作为包含特定横向电梯+特定纵向电梯的调度器，例如服务于一类二次元主题的横纵电梯，乘客愿意步行爬楼前往此类电梯的可搭乘地进行观光乘坐电梯，即二次元乘客的专属调度器。</li></ul></li><li>不同类的电梯调度器实现<code>Sche</code>接口，方便与上层调度器交互。开始时由于横向电梯和纵向电梯的策略和实现差异较大，所以选择了接口而非继承。画出UML图以后觉得使用抽象类或许更加简洁。</li><li>两级调度器模式在hw7并未很大改动，只是增加了电梯线程把未完成请求发给层/座调度器的工序。两级调度器的扩展性较好。</li></ul><h1 id="三、同步块的设置和锁的选择"><a href="#三、同步块的设置和锁的选择" class="headerlink" title="三、同步块的设置和锁的选择"></a>三、同步块的设置和锁的选择</h1><h2 id="3-1-输出安全"><a href="#3-1-输出安全" class="headerlink" title="3.1 输出安全"></a>3.1 输出安全</h2><ul><li><p>输出类中采取单例模式，实现加锁的静态方法。</p></li><li><p>采用<strong>生产者消费者模式</strong>并<strong>不能</strong>完美地解决<strong>电梯作业</strong>的输出安全的问题：原因为例如[0.0]在输出队列添加OPEN请求，[0.4]在输出队列添加CLOSE请求，此时并不一定保证输出线程两次take()并println()的时间间隔严格≥0.4s.</p></li></ul><pre><code class="java">public class MainOutput &#123;    public static synchronized void println(String str) &#123;        TimableOutput.println(str);    &#125;&#125;</code></pre><h2 id="3-2-共享对象"><a href="#3-2-共享对象" class="headerlink" title="3.2 共享对象"></a>3.2 共享对象</h2><ul><li>Scheduler类包含的共享对象为<strong>本电梯</strong>的请求队列<code>Arraylist&lt;PersonRequest&gt; requests</code>，所有读写此请求队列的方法均在Scheduler中实现。</li><li>即把共享对象和需要加锁的方法全部封装进Scheduler.</li></ul><h1 id="四、bug分析"><a href="#四、bug分析" class="headerlink" title="四、bug分析"></a>四、bug分析</h1><blockquote><p>分析自己程序的bug分析未通过的公测用例和被互测发现的bug：问题特征和修复办法  </p></blockquote><ul><li>本单元强测互测没有Bug。</li><li>hw5中测时遇到了轮询cpu超时的问题，后来经过排查是在[电梯线程里关门后]进入[依赖下一步请求实现的换向逻辑]时忘记wait()，导致电梯关门后进入空闲时跳过了此次换向逻辑而进入下一个循环的起始处wait().这导致了空闲后再有新请求进入时，电梯按上次循环时遗留下的方向继续运行，而缺少了电梯换向的逻辑导致从1层运行到0层。解决办法是电梯的每一个步骤后都添加wait()。</li><li>由于我在电梯每个步骤前都有换向逻辑，所以这种轮询出现情况只会在运行到1层且需要换向时空闲的这种特殊的情况下出现，所以轮询的bug在随机生成样例时比较难复现。手动造边界数据+循环起始处println()对于轮询更为有效。</li></ul><h1 id="五、hack策略"><a href="#五、hack策略" class="headerlink" title="五、hack策略"></a>五、hack策略</h1><blockquote><p>分析自己发现别人程序bug所采用的策略<br>列出自己所采取的测试策略及有效性<br>分析自己采用了什么策略来发现线程安全相关的问题<br>分析本单元的测试策略与第一单元测试策略的差异之处  </p></blockquote><ul><li>主要采用自动评测机的方式。不过这种评测方式有一定随机性，本地评测的bug有时难复现。hw5和hw6的评测机并没有发现bug。hw7的评测机本地运行发现了bug但是没有提交成功。评测机主要用于正确性测试，适合作业前期自测正确性。</li><li>另一种hack策略时针对特定线程安全的bug手动造数据，比如hw5时的线程输出安全问题，hw7时不可达的横线电梯出现的轮询问题。hw7时hack到一个横向电梯轮询的Bug。手动hack策略覆盖范围不如自动评测，但是效率和命中率较好。</li><li>本单元相较第一单元的策略差异是，例如超时和轮询的bug比较难通过评测机显现，所以更需要针对特殊情况手动造数据。</li></ul><h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><blockquote><p>从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</p></blockquote><ul><li><p>从线程安全的角度：</p><ul><li><strong>死锁</strong>的bug比较好排查和避免，出现率并不高；</li><li><strong>共享对象</strong>使用sychronized和notifyAll()保证临界区的访问和修改是一种简单且省心的办法；本次作业稍有遗憾的是受限于时间并没有实现读写锁。</li><li><strong>线程的结束条件</strong>需要依据具体情况判断，比如hw5和hw6的结束条件只需要考虑<code>输入结束 &amp;&amp; 调度器中无请求 &amp;&amp; 电梯为空</code>；由于hw7出现请求中转的情况，所以在<code>输入结束</code>这个条件上不再只是输入线程读到<code>null</code>，而是使用类似Experiment4.2代码中的Counter静态实例，当所有请求均运送完毕后才视作输入结束，各级调度器逐级发放isEnd信号。</li><li><strong>轮询</strong>的Bug出现率比较高，且仅在特殊条件下出现而较难排查，需要合理地布局while循环终止地条件和wait()的位置。尤其是在LOOK算法需要频繁依据<strong>当前请求</strong>而实现转向逻辑的电梯中，需要更加细心地应对各种换向和空闲等情况。</li></ul></li><li><p>层次化设计：</p><ul><li>两级调度器更适合完成hw7的多换乘请求，各层级间传递请求易于实现。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab3</title>
      <link href="/2022/04/26/OS-lab3-summary/"/>
      <url>/2022/04/26/OS-lab3-summary/</url>
      
        <content type="html"><![CDATA[<p>操作系统 Lab3：进程与调度</p><span id="more"></span><h1 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h1><h2 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h2><blockquote><p>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id !=envid 的情况？如果没有这步判断会发生什么情况？</p></blockquote><ul><li><code>mkenvid(struct Env *e)</code>中生成的envid为<code>(asid &lt;&lt; (1 + LOG2NENV)) | (1 &lt;&lt; LOG2NENV) | idx</code>,即<code>asid|有效位|env结构体在envs数组的偏移</code>。</li><li>而<code>envid2env(u_int envid, struct Env **penv, int checkperm)</code>中通过envid的偏移找到结构体<code>e=envs+ENVX(envid);</code>。而此时不能确保所给envid中asid的有效性。所以需要通过再次判断<code>e-&gt;env_id !=envid</code>保证进程块的asid.</li><li>若此index所对的env已经更换，则新env结构体会对应新的ASID。如果没有这步判断，可能会出现：①所给envid所对的结构体已经被free后再次使用，即旧结构体所代表的PCB被淘汰，而此时得到的新env与envid想找的旧结构体不匹配；②env结构体没有成功切换为新进程的PCB，导致asid匹配出现错误。</li></ul><h2 id="Thinking-3-2-结合-include-mmu-h-中的地址空间布局，思考-env-setup-vm-函数："><a href="#Thinking-3-2-结合-include-mmu-h-中的地址空间布局，思考-env-setup-vm-函数：" class="headerlink" title="Thinking 3.2 结合 include/mmu.h 中的地址空间布局，思考 env_setup_vm 函数："></a>Thinking 3.2 结合 include/mmu.h 中的地址空间布局，思考 env_setup_vm 函数：</h2><blockquote><p>UTOP 和 ULIM 的含义分别是什么?</p></blockquote><ul><li>ULIM: user limit:kuseg用户态上限，0x8000 0000区分内核态和用户态的地址</li><li>UTOP: userSpace top:用户可分配虚拟内存上限  </li></ul><blockquote><p>UTOP 和 ULIM 之间的区域与 UTOP 以下的区域相比有什么区别？</p></blockquote><ul><li>UTOP 和 ULIM 之间的区域：<ul><li>用与存放页表和内核结构体，用户不可自由分配，即env中结构体数组的pgdir被清零后不会被赋值</li><li>其中UPAGES和ENVS其所占的物理页面，除了映射到用户态的这一部分虚拟地址，还与内核中的虚拟地址有一一映射关系。</li></ul></li><li>UTOP 以下的区域：占用物理内存，但是以页表形式，没有物理内存和内核地址的一一映射  </li></ul><blockquote><p>请结合系统自映射机制解释 Step4 中pgdir[PDX(UVPT)]=env_cr3的含义。</p></blockquote><ul><li>内核态中的虚拟页目录的第PDX(UVPT)个页目录项中保存着此页目录所在页表的基地址的物理地址env_cr3  </li></ul><blockquote><p>谈谈自己对进程中物理地址和虚拟地址的理解。</p></blockquote><ul><li>每个进程都有kuseg的2G虚拟空间，但是实际所有进程共享相同的内存空间。不同的进程有相同的虚拟地址，但是相同虚拟地址映射到不同物理地址</li></ul><h2 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h2><blockquote><p>找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）</p></blockquote><ul><li>来源：env_create_priority()函数中alloc的Env结构体指针</li><li>这个参数的作用是传给load_elf函数，并作为load_elf的int* map函数的参数，获得结构体的页目录</li><li>c语言库函数中qsort()的回调函数<code>int(*cmp)(const void* e1,const void* e2))</code>使用qsort()的参数width实现多类型的比较：<code>cmp((char*)base + j*width,(char*)base+(j+1)*width) &gt; 0))</code></li></ul><h2 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h2><blockquote><p>结合 load_icode_mapper 的参数以及二进制镜像的大小，考虑该函<br>数可能会面临哪几种复制的情况？你是否都考虑到了？</p></blockquote><img src="/2022/04/26/OS-lab3-summary/mapper.jpg" class="" title="pic1"><h2 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h2><blockquote><p>你认为这里的 env_tf.pc 存储的是物理地址还是虚拟地址?</p></blockquote><ul><li>物理地址。大概在0x400000+   </li></ul><blockquote><p>你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？</p></blockquote><ul><li>entry_point是一样的虚拟地址，但是进程PCB不同，可以映射到各自不同的物理地址。</li></ul><h2 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h2><blockquote><p>请查阅相关资料解释，上面提到的 epc 是什么？为什么要将env_tf.pc 设置为 epc 呢？</p></blockquote><ul><li>epc是发生异常中断时执行到的pc值,保存在curenv-&gt;env_tf.cp0_epc。</li><li>env_tf.pc保存进程上下文，pc保存了返回该进程时开始执行的pc值，即为发生异常时的epc</li></ul><h2 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h2><blockquote><p>操作系统在何时将什么内容存到了 TIMESTACK 区域</p></blockquote><ul><li>handle_int()处理时钟中断时，SAVE_ALL保存当前寄存器值的栈顶地址get_sp为0x8200_0000，即为TIMESTACK.  </li></ul><blockquote><p>TIMESTACK 和 env_asm.S 中所定义的 KERNEL_SP 的含义有何不同</p></blockquote><ul><li>TIMESTACK是产生时钟中断异常时用的存放CPU寄存器状态的栈顶指针，KERNEL_SP是非时钟中断异常用的栈指针。</li></ul><h2 id="Thinking-3-8"><a href="#Thinking-3-8" class="headerlink" title="Thinking 3.8"></a>Thinking 3.8</h2><blockquote><p>试找出上述 5 个异常处理函数的具体实现位置。</p></blockquote><ul><li>genex.S中有 handle_int()的实现，有do_refill()即handle_tlb()的实现</li><li>syscall.S有handle_sys()的实现</li></ul><h2 id="Thinking-3-9"><a href="#Thinking-3-9" class="headerlink" title="Thinking 3.9"></a>Thinking 3.9</h2><blockquote><p>阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和time_irq 函数中每行汇编代码的作用</p></blockquote><pre><code class="c">    .textLEAF(set_timer)    li t0, 0xc8    sb t0, 0xb5000100 //实时钟绑定4号中断，触发4号中断    sw    sp, KERNEL_SP //内核栈保存栈寄存器值setup_c0_status STATUS_CU0|0x1001 0//设置SR寄存器的状态：//1.STATUS_CU0：打开CP0寄存器使用权//2.SR[16]：IsC：软件能够访问并使指令高速缓存条目无效//3.SR[4]：IEo    jr ra    nopEND(set_timer)    .extern delaytimer_irq:    sb zero, 0xb5000110//关闭时钟中断1:    j    sched_yield//进程调度    nop    /*li t1, 0xff    lw    t0, delay    addu  t0, 1    sw    t0, delay    beq    t0,t1,1f        nop*/    j    ret_from_exception//异常返回    nop</code></pre><h2 id="Thinking-3-10"><a href="#Thinking-3-10" class="headerlink" title="Thinking 3.10"></a>Thinking 3.10</h2><blockquote><p>阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</p></blockquote><img src="/2022/04/26/OS-lab3-summary/clock1.jpg" class="" title="pic1"><img src="/2022/04/26/OS-lab3-summary/clock2.jpg" class="" title="pic1"><h1 id="二、实验难点与指导书反馈"><a href="#二、实验难点与指导书反馈" class="headerlink" title="二、实验难点与指导书反馈"></a>二、实验难点与指导书反馈</h1><ul><li>初始化进程目录时，没有理解为什么要复制UTOP上部分的内核目录，也不知道这部分的权限该如何设置。建议建议指导书把<strong>权限位</strong>的作用在头文件中指明，或者在lab教程中指明本实验中用到的权限位及其说明</li><li>汇编代码读起来比较晦涩，可以把R3000中的一些部分的<strong>汇编知识</strong>抽离出来，辅助理解；比如：<ul><li>SR寄存器各个位的作用。因为个人感觉虽然自己强硬地把R3000中那部分阅读翻译了一遍，但实际上还是比较困惑，不是很能读懂</li><li>使用到的伪指令的作用。伪指令对阅读理解造成了比较大的理解障碍。</li></ul></li><li><code>load_icode_mapper()</code>，纠结了很久段尾要不要考虑和后面段的共享页面。希望指导书可以提前说明段按地址顺序由小到大加载，只用考虑段首的页面共用情况</li><li>de的第一个Bug就是<code>load_elf()</code>里面的binary地址，开始没有给<code>binary+shdr_offset</code>的段偏移</li><li>TIMESTACK和SP两个概念的辨析：这个思考题一开始卡住了，原因是<code>grep -r TIMESTACK</code>的时候没有查到汇编代码get_sp出现了0x8200_0000。</li><li>可以强调一下<code>INSERT_TAIL(env_sche_list,e,sche_link)</code>要在<code>env_create()</code>而不是alloc时插入</li><li>进程调度算法时为<code>INSERT_TAIL</code></li></ul><h1 id="三、体会与感想"><a href="#三、体会与感想" class="headerlink" title="三、体会与感想"></a>三、体会与感想</h1><p>个人对Lab3的整体感受是比Lab2体验差很多。主要是以下原因：</p><ul><li>课下：<ul><li>Lab2对存储管理的结构比较浑然一体，Lab3的知识相对零碎，比如很多变量的设置并不能直接看到其作用效果或范围，所以debug的时候也比较困难，比如Lab2debug还可以通过输出地址判断本步骤的正确性等，Lab3设计很多汇编函数和寄存器的操作，不管是理解还是测试都不是很容易</li><li>从Lab3遇到Bug会比较瞻前顾后，不知道是本次Lab还是之前Lab的bug，排查Bug所在范围的过程比较头疼</li></ul></li><li>上机时的Exam和Extra题面都比较模糊，具体是以下几点：<ul><li>Exam对于“版本号相同、ASID空闲”这一分支并未显式说明要分配此ASID，而另一分支显式说明“找到最小的未使用ASID并分配”，且还强调“不要做任何无关操作”，虽然按题意是要分配，但是在阅读上的体验并不好，会在是否需要分配的问题上绊住</li><li>Exam对于“模拟位图”和“运行进程”的界定可以更清晰些，避免歧义</li><li>Extra对PV操作资源的个数并未叙述清楚造成理解偏差</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab2</title>
      <link href="/2022/04/14/OS-lab2-summary/"/>
      <url>/2022/04/14/OS-lab2-summary/</url>
      
        <content type="html"><![CDATA[<img src="/2022/04/14/OS-lab2-summary/lab2.png" class="" title="banner"><h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><p>以下是在整个lab2从学习到理解的过程中，和朋友遇到的相同困惑和思考讨论后给出的答案：</p><span id="more"></span><ul><li>c语言写代码时，只能*内核态下的虚拟地址。不能*物理地址。</li><li>在lab2中不能*用户态的虚拟地址。</li></ul><blockquote><ul><li><p>在c语言中指针面向的是cpu，所以<strong>只能 *虚拟地址</strong>。寄存器中如pc也是虚拟地址。</p></li><li><p>所以页表项的PTE_ADDR是物理地址，不能*物理地址。要*KADDR(PTE_ADDR(物理地址))。</p></li><li><p>kseg1和kuseg都是虚拟地址，但是在Lab2中只能*kseg1区域的虚拟地址。原因是：MOS 中，通过页表进行地址变换时，硬件只会查询TLB，如果查找失败，就会触发 TLB 中断，对应的异常中断处理就会对 TLB 进行重填，才能完成kuseg的虚拟地址通过二级页表访问物理地址。然而，lab2 里面没有开启tlb中断这个异常处理的功能，因此在<strong>lab2中不能*kuseg的用户态虚拟地址</strong>，比如UPAGES、UENVS。</p></li><li><p>在lab3的init/init.c中开启了<code>trap_init();</code>中断处理后，此时tlb中断正常响应，就可以*kuseg的用户态虚拟地址了。</p></li></ul></blockquote><ul><li>在编写操作系统的c代码时，变量分别存放在哪部分物理内存？page_alloc() 申请的物理页面用来存什么？</li></ul><blockquote><ul><li><p>代码段、全局变量和静态变量在编译阶段被确定，链接时被链入0x8001 0000向上这部分物理内存。</p></li><li><p>临时变量在内核栈区，被存放在0x8040 0000向下8*BY2PG这部分物理内存。</p></li><li><p>申请物理页面的用途：lab3用于给新进程申请页目录、给内核进程加载外部二进制elf文件并执行；lab4用于为用户进程申请用户栈、duppage()时为COW复制的页表申请物理空间；lab5在进程内存放文件内容、lab6用于给用户进程加载外部二进制elf文件来执行命令。</p><p>申请的页面存放在0x8040 0000向上这部分物理内存</p></li></ul></blockquote><ul><li>在建立两级页表的映射机制时，虚拟地址、物理地址、（页表项）指针、（页表项）指针存放的数据 是什么关系？</li></ul><blockquote><p>页目录项和页表项：存储于物理内存中某个物理地址中。KADDR(物理地址)就是存储页目录项和页表项的虚拟地址（位于kseg0），这个虚拟地址是页表项指针。使用*页表项指针（kseg0的虚拟地址）可以获取到这个虚拟地址对应的物理内存中的数据（页表项）。</p><p>对于获取到的页表项数据，PTE_ADDR(页表项)得到的是物理页的基地址。PTE_ADDR(页目录项)得到的物理页是二级页表的物理页基地址。二级页表项指针pte = KADDR(PTE_ADDR(页目录项))。访存二级页表项数据*pte 。PTE_ADDR（二级页表项）得到的物理页是内存数据页的物理页基地址。内存数据指针同理KADDR(PTE_ADDR(二级页表项))，*得到要访存的虚拟地址的数据。</p><p>要访存的虚拟地址va的不同段，用于*时提供偏移，包括页目录项在页目录的偏移PDX(va)，页表项在二级页表的偏移PTX(va)，数据在物理页面（等于在虚拟页面）的偏移offset(va)。</p></blockquote><ul><li>MOS编写函数时，为了扩展性、代码复用性，在函数的传入参数上的两个设计：</li></ul><blockquote><ul><li>传入0或者1的标志位：例如pgdir_walk()函数的create参数，用于标志寻找二级页表项时是否创建二级页表。</li><li>传入指针的指针，用作返回值：例如pgdir_walk()函数的**ppte参数，用于底层函数pgdir_walk() 传给上层调用者二级页表项地址 。</li></ul></blockquote><ul><li><p>alloc() 和page_alloc()</p><p>boot_pgdir_walk() 和pgdir_walk()</p><p>前后两个相似功能函数的区别？</p></li></ul><blockquote><p>物理内存管理：页式管理的思想</p><p>在mips_vm_init()时，才进行了pages物理页面结构体的内存初始化。所以才能进行page_init() 页式内存管理的初始化。</p><p>page_alloc() 和pgdir_walk() 页式内存管理机制。所以在mips_vm_init()时需要使用alloc() 和boot_*() 来初始化物理内存。</p></blockquote><ul><li>一些在Lab2为固定值，但是还存在于函数声明的参数：</li></ul><blockquote><ol><li><p>参数pgdir在pmap.c中全是使用的内核页目录地址boot_pgdir固定值：在后续用户进程使用pmap.c的函数时，参数pgdir会传入进程的页目录基地址，不再是内核页目录地址。</p></li><li><p>align：BY2PG。在mips_vm_init()，为了申请的时候页对齐，便h后续于物理内存的管理，页式管理，按页分配回收。</p></li></ol></blockquote><h1 id="一、操作系统启动时的内存初始化过程"><a href="#一、操作系统启动时的内存初始化过程" class="headerlink" title="一、操作系统启动时的内存初始化过程"></a>一、操作系统启动时的内存初始化过程</h1><h2 id="mips-vm-init"><a href="#mips-vm-init" class="headerlink" title="mips_vm_init()"></a>mips_vm_init()</h2><ul><li>作用：初始化内核页目录、Page结构体数组、env结构体数组的内存空间</li></ul><h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>static void *alloc(u_int n, u_int align, int clear)</p><ul><li>作用：建立页式管理机制前，初始化内存时标记已使用的内存</li><li>流程：修改freemem全局变量，类似向上移动移动剩余物理空间的栈顶指针。如果clear=1，同时清空所对应的物理内存。</li></ul><img src="/2022/04/14/OS-lab2-summary/lab2-2.png" class="" title="banner"><h3 id="boot-map-segment"><a href="#boot-map-segment" class="headerlink" title="boot_map_segment"></a>boot_map_segment</h3><p>void boot_map_segment(Pde *pgdir, u_long va, u_long size, u_long pa, int perm)</p><img src="/2022/04/14/OS-lab2-summary/lab2-1.png" class="" title="banner"><ul><li><p>作用：把以va为起始，长度为size的这一范围内的虚拟地址，<strong>映射</strong>到起始地址为pa的这一段物理地址</p></li><li><p>如何实现页表<strong>映射</strong>：建立从va到pa的映射，也就是boot_map_segment()关键的代码：在<strong>va所对应的页表项</strong>中写入pa的<strong>物理页框号</strong>ppn以及<strong>权限位</strong>。</p><pre><code class="c">*pgtable_entry = PTE_ADDR(pa + i) | (perm | PTE_V);</code></pre><ul><li><p>pa 的物理页框号ppn : PTE_ADDR(pa + i)</p></li><li><p>权限位 ： (perm | PTE_V)</p></li><li><p>va 所对应的页表项 : *pgtable_entry</p><ul><li><p>如何获取页表项地址 (指针) pgtable_entry ：boot_pgdir_walk的返回值</p><pre><code class="c">pgtable_entry = boot_pgdir_walk(pgdir, va + i, 1);</code></pre></li></ul></li></ul></li></ul><h4 id="boot-pgdir-walk"><a href="#boot-pgdir-walk" class="headerlink" title="boot_pgdir_walk"></a>boot_pgdir_walk</h4><p>static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create)</p><img src="/2022/04/14/OS-lab2-summary/lab2-3.png" class="" title="banner"><ul><li><p>作用：</p><ul><li>返回值作为页表项地址 (指针) pgtable_entry</li><li>如果页目录项的权限位为0，表示此页目录项保存的二级页表的物理地址为空，即所对的二级页表未申请物理内存。此时如果传入参数create位为1，则alloc()出va所在二级页表的物理内存地址，写入页目录项；如果传入参数create位为0，表示boot_pgdir_walk()此时只检查二级页表是否已申请物理内存。如果已申请，正常返回页表项地址。否则返回0</li></ul></li><li><p>流程：如何找到va所对的页表项地址</p><ul><li><p>计算页目录项的虚拟地址：<code>pgdir_entryp = pgdir + PDX(va);</code></p></li><li><p><strong>判断页目录项的有效性</strong>：<code>if (!((*pgdir_entryp) &amp; PTE_V)) </code></p><ul><li>为空：create位为1，则alloc()出va所在二级页表的物理内存地址，写入页目录项；create位为0，返回0.</li></ul></li><li><p><strong>把页目录项PTE_ADDR存储的的二级页表物理地址，通过KADDR宏转换成kseg0的虚拟地址，得到二级页表基地址</strong>：<code>pgtable = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp));</code></p></li><li><p>计算va所对应的二级页表项的虚拟地址：<code>pgtable_entry = pgtable + PTX(va);</code></p></li><li><p>返回va所对应的二级页表项的虚拟地址</p></li></ul></li></ul><h2 id="page-init"><a href="#page-init" class="headerlink" title="page_init"></a>page_init</h2><ul><li><p>作用：</p><ul><li>建立页式内存管理机制，进行物理内存的管理。</li><li>一个物理页面对应一个page结构体，物理内存管理主要是修改page结构体数组的信息</li></ul></li><li><p>流程：</p><ul><li>从pages（第一个page结构体地址）开始，到freemem的所对的页面的page结构体，所有page结构体的pp_ref记为1。表示被使用次数为1.</li><li>剩下的所有空闲结构体的pp_ref记为0，并插入空闲结构体链表page_free_list。</li></ul></li></ul><h1 id="二、页式内存管理机制建立后，为后续lab提供的也是内存管理接口"><a href="#二、页式内存管理机制建立后，为后续lab提供的也是内存管理接口" class="headerlink" title="二、页式内存管理机制建立后，为后续lab提供的也是内存管理接口"></a>二、页式内存管理机制建立后，为后续lab提供的也是内存管理接口</h1><p>返回值均为函数执行是否成功。真正的返回值靠传入<strong>指针的指针返回给上层函数</strong>。</p><h2 id="page-alloc-vs-alloc"><a href="#page-alloc-vs-alloc" class="headerlink" title="page_alloc() vs alloc()"></a>page_alloc() vs alloc()</h2><p>int page_alloc(struct Page **pp)</p><ul><li>不再使用freemem标记占用内存，而是使用页式内存管理模式，即使用空闲结构体链表page_free_list的删除和重新插入管理空闲页面。</li><li>传入一个指针的指针pp，用于修改指针的内容，也就是给*pp写入返回分配的物理页面所对的结构体指针。</li></ul><h2 id="pgdir-walk-vs-boot-pgdir-walk"><a href="#pgdir-walk-vs-boot-pgdir-walk" class="headerlink" title="pgdir_walk() vs boot_pgdir_walk()"></a>pgdir_walk() vs boot_pgdir_walk()</h2><p>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</p><ul><li>需要使用page_alloc()为二级页表申请物理内存空间，不要忘记 <code>ppage-&gt;pp_ref++</code></li></ul><h2 id="page-insert-vs-boot-map-segment"><a href="#page-insert-vs-boot-map-segment" class="headerlink" title="page_insert() vs boot_map_segment"></a>page_insert() vs boot_map_segment</h2><p>int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm)</p><ul><li>作用：<ul><li>把物理页pp映射到虚拟地址va</li></ul></li><li>流程：<ul><li>pgdir_walk() 找va的二级页表项和物理地址是否存在，create=0<ul><li>如果存在：<ul><li>va之前映射到的旧物理页面不是pp，<code>pa2page(*pgtable_entry) != pp</code>：取消va对旧物理页面的映射，<code>page_remove(pgdir, va)</code></li><li>va之前映射到的旧物理页面是pp：更新二级页表项的perm，所以需要<code>tlb_invalidate(pgdir, va);</code>清空旧的TLB，返回。</li></ul></li></ul></li><li>需要对二级页表项修改PTE_ADDR，所以要<code>tlb_invalidate(pgdir, va);</code>清空旧的TLB</li><li>找到二级页表项的地址，<code>pgdir_walk(pgdir, va, 1, &amp;pgtable_entry)</code>，如果不存在，此时需要创建</li><li>二级页表项填入ppn和perm，物理页pp的pp_ref++</li></ul></li></ul><h2 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup"></a>page_lookup</h2><p>struct Page * page_lookup(Pde *pgdir, u_long va, Pte **ppte)</p><ul><li>检查二级页表项是否存在：<code>pgdir_walk(pgdir, va, 0, &amp;pte);</code>，不存在返回0</li><li>填入二级页表项地址 <code>*ppte = pte;</code></li><li>返回va物理页面结构体 <code>return pa2page(*pte);</code></li></ul><h1 id="三、实验思考题"><a href="#三、实验思考题" class="headerlink" title="三、实验思考题"></a>三、实验思考题</h1><h2 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h2><blockquote><p>请你根据上述说明，回答问题：在我们编写的 C 程序中，指针变量中存储的地址是虚拟地址还是物理地址？MIPS 汇编程序中 lw, sw 使用的是虚拟地址还是物理地址？  </p></blockquote><p>指针变量中存储的地址是虚拟地址;MIPS 汇编程序中 lw, sw 使用的是物理地址。</p><h2 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h2><blockquote><p>请从可重用性的角度，阐述用宏来实现链表的好处。  </p></blockquote><ul><li>各类结构体都可以使用queue.h的宏简化代码量：<ul><li>一开始写Exercise2.2的时候没有明白field字段设置的意义，觉得传入了elm参数以后，field应该是作为elm的成员变量名，不应该作为可变参数传入，显得有点多此一举，忘记了宏定义除了可以替换成实参，还可以做字符串字面量的替换。</li><li>写到2.3才意识到field不是变量参数，而是pp_link这个字符串。</li><li>后来思考之所以在queue.h的宏里面这样定义，应该是因为这里的宏并不止服务于Page，所以从工程角度来看，field仍然属于一种变量，field的设置提高了宏的可重用性，因为可以兼顾所有结构体的所有成员变量名。</li></ul></li><li>复杂宏(如LIST_INSERT_TAIL、LIST_INSERT_BEFORE)大量使用简单宏(如LIST_FIRST、LIST_NEXT)，可重用性强</li><li>可读性强，简化代码量，易于维护</li></ul><h2 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h2><blockquote><p>请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性  </p></blockquote><ul><li>由于多线程系统中不同进程中，相同的虚拟地址各自占用不同的物理地址空间，所以同一虚拟地址通常映射到不同的物理地址。因此TLB中装着不同进程的页表项，ASID用于区别不同进程的页表项。没有ASID机制的情况下每次进程切换需要地址空间切换的时候都需要清空TLB。</li></ul><blockquote><p>请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。  </p></blockquote><p>ASID6位，容纳64个不同进程。</p><h2 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h2><blockquote><p>请用一句话概括 tlb_invalidate 的作用  </p></blockquote><ul><li>实现删除特定虚拟地址的映射，每当页表被修改，就需要调用该函数以保证下次访问该虚拟地址时诱发 TLB 重填以保证访存的正确性</li></ul><blockquote><p>逐行解释 tlb_out 中的汇编代码  </p></blockquote><pre><code class="c">/* Exercise 2.10 */LEAF(tlb_out)//1: j 1bnop    mfc0    k1,CP0_ENTRYHI  //把当前VPN和ASID存储到$k1，用于函数结束时恢复CP0_ENTRYHI    mtc0    a0,CP0_ENTRYHI  //把调用函数时传入的VPN和ASID写进CP0_ENTRYHI    nop  nop    tlbp  //根据 EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器（若未找到匹配项，则Index最高位被置 1）  nop    nop    nop    nop    nop    mfc0    k0,CP0_INDEX    bltz    k0,NOFOUND  //如果TLB中保存了此VPN 与 ASID对应的表项，那么把EntryHi 与 EntryLo 的值写为0，即清空此表项，用于触发TLB缺失，重新装入    nop    mtc0    zero,CP0_ENTRYHI    mtc0    zero,CP0_ENTRYLO0    nop    tlbwiNOFOUND:    mtc0    k1,CP0_ENTRYHI  //$k1保存的原VPN和ASID恢复到CP0_ENTRYHI        j    ra    nopEND(tlb_out)</code></pre><h2 id="Thinking-2-7"><a href="#Thinking-2-7" class="headerlink" title="Thinking 2.7"></a>Thinking 2.7</h2><blockquote><p>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 PTbase，请你计算：  </p></blockquote><ul><li>三级页表页目录的基地址</li><li>映射到页目录自身的页目录项（自映射）</li></ul><img src="/2022/04/14/OS-lab2-summary/1.jpg" class="" title="pic1"><h2 id="Thinking-2-8"><a href="#Thinking-2-8" class="headerlink" title="Thinking 2.8"></a>Thinking 2.8</h2><blockquote><p>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</p></blockquote><ol><li>X86 体系结构中的内存管理机制</li></ol><ul><li>通过分段将逻辑地址转换为线性地址，通过分页将线性地址转换为物理地址。</li><li>逻辑地址由两部分构成，一部分是段选择器，一部分是偏移。</li><li>段选择符存放在段寄存器中，如CS（存放代码段选择符）、SS（存放堆栈段选择符）、DS（存放数据段选择符）和ES、FS、GS（一般也用来存放数据段选择符）等；</li><li>偏移与对应段描述符中的基地址相加就是线性地址。</li><li>操作系统创建全局描述符表和提供逻辑地址，之后的分段操作x86的CPU会自动完成，并找到对应的线性地址。</li><li>从线性地址到物理地址的转换是CPU自动完成的，转化时使用的Page Directory和Page Table等需要操作系统提供。</li></ul><ol start="2"><li>X86 和 MIPS 在内存管理上的区别</li></ol><ul><li>TLB不命中：<ul><li>MIPS触发TLB缺失和充填，然后CPU重新访问TLB</li><li>x86硬件MMU索引获得页框号，直接输出物理地址，MMU充填TLB加快下次访问速度</li></ul></li><li>分页方式不同：<ul><li>一种MIPS系统内部只有一种分页方式</li><li>x86的CPU支持三种分页模式</li></ul></li><li>逻辑地址不同：<ul><li>MIPS地址空间32位</li><li>x86支持64位逻辑地址，同时提供转换为32位定址选项</li></ul></li><li>段页式的不同：<ul><li>MIPS同时包含了段和段页式两种地址使用方式</li><li>在x86架构的保护模式下的内存管理中，分段是强制的，并不能关闭，而分页是可选的；</li></ul></li></ul><h1 id="四、实验难点"><a href="#四、实验难点" class="headerlink" title="四、实验难点"></a>四、实验难点</h1><h2 id="程序空间和物理内存的映射理解："><a href="#程序空间和物理内存的映射理解：" class="headerlink" title="程序空间和物理内存的映射理解："></a>程序空间和物理内存的映射理解：</h2><ol><li>对于Page结构体数组的理解：</li></ol><ul><li>虚拟空间内，存储在kseg0(pages)和kuseg(UPAGES),映射到<strong>相同物理地址</strong>。<ul><li>kseg0的pages和物理地址一一对应，va高位置0即可得到pa</li><li>kuseg的UPAGES需要建立页目录和物理地址的映射</li></ul></li><li>Page结构体插入page_free_list的顺序不需要按地支顺序。差别仅在于分配物理页面时提供的物理地址不同。保证Page所对物理页面为空即可</li></ul><ol start="2"><li>没有分清虚拟地址和物理地址</li></ol><ul><li>MOS中的页表和页表项在虚拟内存中也占有一片空间。我们模拟的内存管理都是在CPU环境下模拟MMU的映射过程，所以涉及的代码均为操作虚拟地址，也就是得到一个需要访存的程序地址，通过MMU读取页目录地址，转换成页表的虚拟地址，返回给CPU，完成访存。</li></ul><ol start="3"><li>pgdir_walk函数中，对应的二级页表不存在则会使用 page_alloc 函数分配一页物理内存用于存放。pp_ref 对应这一页物理内存被引用的次数，它等于有多少虚拟页映射到该物理页。所以此时pgdir_walk函数create的时候，pp_ref需要+1.</li></ol><ol start="4"><li>对于PPN和PTE_ADDR一开始没有分清楚</li></ol><ul><li>PPN得到虚页号，PTE_ADDR可以得到页表的物理地址。PTE_ADDR&gt;&gt;12=PPN</li></ul><h2 id="链表相关的指针、结构体、宏定义等C语言知识："><a href="#链表相关的指针、结构体、宏定义等C语言知识：" class="headerlink" title="链表相关的指针、结构体、宏定义等C语言知识："></a>链表相关的指针、结构体、宏定义等C语言知识：</h2><ol start="5"><li>由于野指针导致了出现死循环</li></ol><ul><li>测试时发现不停的跳转到main函数里，是取了野指针的问题。后来排查发现是出现了*页目录项的问题。pgdir_walk返回的是页表项的地址，所以不需要*页目录项，而是需要把页目录项的物理地址转换成虚拟地址。</li></ul><ol start="6"><li>对于链表初始化重复修改了多次才成功</li></ol><ul><li><code>LIST_INIT(&amp;page_free_list);</code>中，page_free_list是Page_list结构体变量，链表宏需要的参数均为Page_list结构体指针，所以需要传入<code>&amp;page_free_list</code>地址</li><li>page_init()函数中，不需要<code>LIST_HEAD(Page_list,Page) page_free_list;</code>的定义。结构体已经定义过。</li></ul><ol start="7"><li>双向链表的结构体结构理解不清晰</li></ol><ul><li>prev是struct Page**,保存next的地址；next是struct Page *,保存结构体的地址；</li><li>作用是remove节点时避免遍历双向链表</li></ul><ol start="8"><li>移位运算符的bug</li></ol><ul><li>移位运算符的优先级低于加号，需要加括号</li><li>右移后低位截断。如<code>((*pte)&gt;&gt;12)&amp;0xfff</code>,避免出现算数右移的情况</li></ul><h1 id="五、体会与感想"><a href="#五、体会与感想" class="headerlink" title="五、体会与感想"></a>五、体会与感想</h1><ul><li>测试代码写的很好，非常全面地测试了内存管理模块，把原来的黑盒评测变成了白盒，为debug带来了很大的方便！</li><li>回归到了最朴素的printf调试法。由于gxemul的单步调试只能看内存的存取情况，所以想观察函数和地址的行为只能用printf的方法进行单步调试。虽然看过gxemul的断点调试教程，但是比较抽象，希望如果有可能的话助教能结合lab2的具体代码给予结合gxemul的调试示例，作为第二种debug方法</li><li>虚拟内存的函数经常多次调用，返回值类型多，函数间的调用关系比较复杂。我选择在函数的入口、出口、分支判断条件的地方都加入printf语句，配合check()代码可以显式地看到内存分配的过程，加强了对内存管理的理解</li></ul><h1 id="六、指导书反馈"><a href="#六、指导书反馈" class="headerlink" title="六、指导书反馈"></a>六、指导书反馈</h1><ol><li><p><strong>Exercise2.8</strong>给的函数中，<strong>pgdir_walk函数</strong>中，对应的二级页表不存在则会使用 page_alloc 函数分配一页物理内存用于存放。pp_ref 对应这一页物理内存被引用的次数，它等于有多少虚拟页映射到该物理页。所以此时pgdir_walk函数create的时候，<strong>pp_ref需要+1</strong>.</p></li><li><p><strong>请在lab2</strong>就像lab3强调结构体必须为了评测而保证倒序插入一样，<strong>强调page结构体必须倒序插入</strong>。由于一开始在lab2顺序插入的page结构体，虽然在Lab2课上的题面有强调倒序，在课上评测我也按倒序做了修改。但是<strong>lab3的评测</strong>由于没有特殊说明，我没有再修改page结构体的顺序，导致<strong>lab3课下评测只过了8个点</strong>，误以为是lab3的bug导致浪费大量时间才定位到pmap.c</p></li><li><p>lab2的mmu.h增加的KADDR(pa)宏，由于没有对传入的**pa取(u_long)**，且此转换宏的逻辑是pa+ULIM也就是pa+0x8000_0000，导致如果传入指针型的变量就无法高位置1.建议从Lab2到后续lab对mmu.h的KADDR(pa)做修正</p></li><li><p>多级页表自映射可以强调一下自映射的页目录在<strong>页目录、所有页表、虚拟页框</strong>的偏移offset是一致的</p></li><li><p>可以在教程网站中增加一些mmu.h和pmap.h<strong>地址转换宏</strong>的练习题，增加对头文件的理解</p></li><li><p>增加流程图解</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-Unit1</title>
      <link href="/2022/03/24/OO-Unit1-summary/"/>
      <url>/2022/03/24/OO-Unit1-summary/</url>
      
        <content type="html"><![CDATA[<p>写在前面：我很满足！助教夸我类图画的好看耶！</p><img src="/2022/03/24/OO-Unit1-summary/0.png" class="" title="pic1"><h1 id="一、程序结构"><a href="#一、程序结构" class="headerlink" title="一、程序结构"></a>一、程序结构</h1><h2 id="UML类图与架构设计"><a href="#UML类图与架构设计" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><img src="/2022/03/24/OO-Unit1-summary/hw1.1.png" class="" title="pic1"><span id="more"></span><ul><li>通过Lexer和Parser解析字符串，递归下降生成Expr对象时去除括号</li><li>重写Expr.toString()，生成记录运算顺序的后缀表达式SuffixString。格式”X1(操作数) X2(操作数) +(操作符) …”。后缀表达式的<strong>操作符</strong>包括+、*、^int(表达式因子的幂运算)、!(取反)；</li><li>Parser维护了一个后缀表达式<strong>操作数表</strong></li><li>Suffix类获取包含操作符运算顺序的String和操作数表，用栈进行计算结果得到Quantic对象，对Quantic对象调用print()方法输出。<h3 id="第二次作业迭代思路："><a href="#第二次作业迭代思路：" class="headerlink" title="第二次作业迭代思路："></a>第二次作业迭代思路：</h3><img src="/2022/03/24/OO-Unit1-summary/hw1.2.png" class="" title="pic1"></li></ul><h4 id="一、引入三角函数后的统一存储形式"><a href="#一、引入三角函数后的统一存储形式" class="headerlink" title="一、引入三角函数后的统一存储形式"></a>一、引入三角函数后的统一存储形式</h4><ul><li>多项式的每项基本形式：ax^b -&gt; ax^b(sin容器)(cos容器)</li><li>选用hashmap，<code>merge()</code>方法和<strong>lambda函数</strong>实现合并同类项非常简洁。<ul><li>Key为自定义类型<code>BaseKey</code>，重写<code>hashcode()</code>和<code>equal()</code>后便于合并同类项。形式：<code>x^b(sin容器)(cos容器)</code></li><li>由于需要维护可变类型<code>BaseKey</code>作为hashmap的<code>key</code>的不可变性，以及<code>value</code>代表的系数为<strong>不可变类型</strong>BigInteger，没有出现深浅拷贝的Bug</li></ul></li></ul><h4 id="二、sum函数因子的处理"><a href="#二、sum函数因子的处理" class="headerlink" title="二、sum函数因子的处理"></a>二、sum函数因子的处理</h4><ul><li>将sum函数作为因子Factor，在递归下降处理表达式中，类似处理表达式因子的模式，进行递归下降处理</li><li>具体实现：识别出sum函数的求和表达式，为此表达式新建lexer和parser对象，返回求和后的Expr作为因子。类型为抽象接口Factor</li></ul><h4 id="三、自定义函数的处理"><a href="#三、自定义函数的处理" class="headerlink" title="三、自定义函数的处理"></a>三、自定义函数的处理</h4><ul><li>新建自定义函数类，类中使用static成员变量存储预先读入的函数形参表和函数表达式</li><li>递归下降过程中识别到自定义函数因子时，新建自定义函数类的对象，传入读取到的实参表，返回替换后的Expr作为因子。</li></ul><h3 id="第三次作业迭代思路"><a href="#第三次作业迭代思路" class="headerlink" title="第三次作业迭代思路"></a>第三次作业迭代思路</h3><img src="/2022/03/24/OO-Unit1-summary/hw1.3.png" class="" title="pic1"><h4 id="一、嵌套函数：作业二实现"><a href="#一、嵌套函数：作业二实现" class="headerlink" title="一、嵌套函数：作业二实现"></a>一、嵌套函数：作业二实现</h4><h4 id="二、三角函数因子为表达式因子"><a href="#二、三角函数因子为表达式因子" class="headerlink" title="二、三角函数因子为表达式因子"></a>二、三角函数因子为表达式因子</h4><ul><li>sin(bracket)，bracket类型由Single换为Quantic即可<h4 id="三、三角函数的化简"><a href="#三、三角函数的化简" class="headerlink" title="三、三角函数的化简"></a>三、三角函数的化简</h4></li><li>sin(0)-&gt;(0);cos(0)-&gt;(1)，<code>Pre</code>类内字符串替换即可；</li><li>sin(bracket)，bracket为常数因子或幂函数因子时去括号。<code>Suffix.print()</code>输出字符串时按有无<code>&#39;+&#39;&#39;*&#39;</code>作为常数因子或幂函数因子的判断依据；</li><li>诱导公式：括号内负号外提。<code>三角函数符号=f(括号内表达式符号，指数，三角名)</code>，<code>lexer.getTrigon()</code>内处理；</li><li>sin(brackt)**2-&gt;(1-cos(brackt)**2);CalculateExpr()化简，取最短字符串为结果；<br>cos(brackt)**2-&gt;(1-sin(brackt)**2);CalculateExpr()化简，取最短字符串为结果；</li></ul><h2 id="使用的OO度量"><a href="#使用的OO度量" class="headerlink" title="使用的OO度量"></a>使用的OO度量</h2><table><thead><tr><th>度量指标</th><th></th><th></th><th>说明</th></tr></thead><tbody><tr><td>LCOM</td><td>Lack of Cohesion in Methods – Class</td><td>方法的内聚缺乏度</td><td>值越大，说明类内聚合度越小。</td></tr><tr><td>FANIN</td><td>Fan-in – Class</td><td>类的扇入</td><td>表示调用该模块的上级模块的个数，扇入越大，表示该模块的复用性好。</td></tr><tr><td>FANOUT</td><td>Fan-out – Class</td><td>类的扇出</td><td>表示该模块直接调用的下级模块的个数，扇出过大表明模块复杂度高，但扇出过小也不好。</td></tr><tr><td>OCavg</td><td>Average opearation complexity</td><td>类的平均操作复杂度</td><td></td></tr><tr><td>OCmax</td><td>Maximum operation complexity</td><td>类的最大操作复杂度</td><td></td></tr><tr><td>WMC</td><td>Weighted method complexity</td><td>类的加权方法复杂度</td><td></td></tr><tr><td>CogC</td><td>Cognitive complexity</td><td>方法的认知复杂度</td><td></td></tr><tr><td>ev(G)</td><td>Essential cyclomatic complexity</td><td>方法的基本圈复杂度</td><td>衡量程序非结构化程度。</td></tr><tr><td>iv(G)</td><td>Design complexity</td><td>方法的设计复杂度</td><td>模块和其他模块的调用关系。软件模块设计复杂度高意味模块耦合度高，这将导致模块难于隔离、维护和复用。</td></tr><tr><td>v(G)</td><td>cyclonmatic complexity</td><td>方法的独立路径的条数</td><td></td></tr></tbody></table><h2 id="类的内聚和相互间的耦合情况"><a href="#类的内聚和相互间的耦合情况" class="headerlink" title="类的内聚和相互间的耦合情况"></a>类的内聚和相互间的耦合情况</h2><p>以下为三次作业的类的属性个数、方法个数、LCOM、FANIN、FANOUT。大致依据类的功能分为存储类和执行类分别统计。执行类包括解析、计算、化简输出三部分。</p><h3 id="hw1"><a href="#hw1" class="headerlink" title="hw1"></a>hw1</h3><img src="/2022/03/24/OO-Unit1-summary/1-1.png" class="" title="pic1"><img src="/2022/03/24/OO-Unit1-summary/1-2.png" class="" title="pic1"><h3 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a>hw2</h3><img src="/2022/03/24/OO-Unit1-summary/2-1.png" class="" title="pic1"><img src="/2022/03/24/OO-Unit1-summary/2-2.png" class="" title="pic1"><h3 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a>hw3</h3><img src="/2022/03/24/OO-Unit1-summary/3-1.png" class="" title="pic1"><img src="/2022/03/24/OO-Unit1-summary/3-2.png" class="" title="pic1"><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><strong>设计要求高内聚低耦合，即LCOM值要小，FANIN值要大，FANOUT值要合理。</strong></p><ol><li>存储类的FANIN明显高于执行类的FANIN</li></ol><ul><li>存储类的复用率高：说明存储类型选取的<code>hashmap&lt;BaseKey,BigInteger&gt;</code>较为合适，与同学交流时也发现自己的存储与计算的代码实现较为简洁，hw1-3均使用了Basekey和merge方法，没有过多迭代过程</li><li>执行类的复用率低，说明执行类的逻辑仍然存在面向过程性。</li></ul><ol start="2"><li>LCOM较低，说明方法的高内聚实现较好。</li></ol><h2 id="方法的规模与分支复杂度情况"><a href="#方法的规模与分支复杂度情况" class="headerlink" title="方法的规模与分支复杂度情况"></a>方法的规模与分支复杂度情况</h2><p>以下为截取hw3的复杂度较高的方法和类，复杂度集中在Lexer、Suffix的符号识别和字符串输出化简两部分。由于分支复杂度较高，这两部分的测试时间和bug也相应较多。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>存储类的数据类型选取合适：<ul><li>选用hashmap，<code>merge()</code>方法和<strong>lambda函数</strong>实现合并同类项非常简洁。</li><li>Key为自定义类型<code>BaseKey</code>，重写<code>hashcode()</code>和<code>equal()</code>后便于合并同类项</li><li>由于需要维护可变类型<code>BaseKey</code>作为hashmap的<code>key</code>的不可变性，以及<code>value</code>代表的系数为<strong>不可变类型</strong>BigInteger，没有出现深浅拷贝的Bug</li></ul></li></ul><pre><code class="java">public class Quantic &#123;    private HashMap&lt;BaseKey, BigInteger&gt; quanticMember;    public void quanticAdd(Quantic nextTop) &#123;        nextTop.getQuanticMember().forEach((key, value) -&gt;this.quanticMember.merge(key, value, BigInteger::add));        //hashmap1合并进hashmap2，类似合并同类项原理    &#125;</code></pre><ul><li>forEach()方法用于对 HashMap 中的每个键值对执行指定的操作。匿名函数 lambda 的表达式 作为 forEach()方法的参数传入。</li><li>merge()方法用于合并两个hashmap，使用lambda表达式 <code>(oldValue, newValue) -&gt; (oldValue + newValue)</code> 作为重映射函数。</li><li>Java 8的方法引用更方便，方法引用由::双冒号操作符标示,使用<code>BigInteger::add</code>作为重映射函数即可</li><li>由于<code>hashmap.merge()</code>在插入hashmap2中不存在的key与其对应的value时不会调用重映射函数，故减法不能使用<code>BigInteger::subtract</code>作为映射函数；解决办法为减数先取反，再与被减数调用<code>quanticAdd()</code>即可</li><li>乘法将两个BaseKey相乘后的新BaseKey作为merge方法的key参数，系数的乘积作为value参数，重映射函数<code>BigInteger::add</code><pre><code class="java">public Quantic quanticMulQuantic(Quantic nextTop) &#123;      Quantic ans = new Quantic();      for (BaseKey j : this.quanticMember.keySet()) &#123;          for (BaseKey y : nextTop.quanticMember.keySet()) &#123;              BigInteger coeJ = this.quanticMember.get(j);              BigInteger coeY = nextTop.getQuanticMember().get(y);              ans.getQuanticMember().merge(new BaseKey(j,y),coeJ.multiply(coeY), BigInteger::add);          &#125;      &#125;      return ans;  &#125;</code></pre></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>由于对应用设计模式的经验较为缺乏，架构设计时没有采用设计模式，存在显著的面向过程性</li><li>lexer和parser的实现时，复杂度过高。在hw1中把减号的语义去除，即parser的语义分割符仅为<code>&#39;+&#39;&#39;*&#39;</code>，<code>&#39;-&#39;</code>仅作为Expr、Term、Single和Trigon的符号位，在后续作业的<code>系数的符号=f(符号，指数)</code>的转化时出了很多错误，例如负号外提出错<code>sin(-1)**2化简成-sin(1)**2</code>与识别负号位时未考虑<code>pos==length</code>的情况出错。同时parser的三个方法均出现了表示符号的参数的嵌套传递情况，debug时出现非常大的麻烦。</li></ul><h1 id="二、bug分析"><a href="#二、bug分析" class="headerlink" title="二、bug分析"></a>二、bug分析</h1><h2 id="第二次公测"><a href="#第二次公测" class="headerlink" title="第二次公测"></a>第二次公测</h2><ul><li>自定义函数的函数声明中未考虑空格和tab，WA了两个点<h2 id="第二次互测"><a href="#第二次互测" class="headerlink" title="第二次互测"></a>第二次互测</h2></li><li>lexer的一个分支忘记添加<code>pos==length</code>时<code>return</code>的终止条件，导致<code>+-+1</code>出现exception<br>反思：迭代开发作业可以使用之前作业的强测数据来测试本次作业的修改是否影响到之前的功能；做测试时不要忘记测试原先的基础功能是否维持正常</li><li><code>sin(-1)**2</code>化简成<code>-sin(1)**2</code>,未考虑偶数次幂时消去负号的情况。<del>反思：可能是初中的知识没学好</del></li><li>没有注意到互测的指数输入可以大于8<br>反思：公测时也要注意互测的数据规范；修改指数的数据范围时有一处遗漏导致出错<h2 id="第一次和第三次作业未出现Bug"><a href="#第一次和第三次作业未出现Bug" class="headerlink" title="第一次和第三次作业未出现Bug"></a>第一次和第三次作业未出现Bug</h2><h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2></li><li>总体来说，由于存储类的代码行和圈复杂度明显低于工作类，未出现计算方面的Bug。</li><li>Bug主要集中在lexer和parser的识别和解析字符串部分，此部分的圈复杂度较高，出现遗漏分支与修改不完善的情况。</li><li>输出部分的圈复杂度最高，针对此部分做的测试较多，未出现bug。</li></ul><h1 id="三、hack策略"><a href="#三、hack策略" class="headerlink" title="三、hack策略"></a>三、hack策略</h1><ul><li>自动化评测机测试时，对于数据生成程序的要求较高，当数据输入的限制较多与程序功能较为简单时，自动生成数据的强度不容易控制，容易出现数据较弱或不合法的情况。</li><li>根据被测程序构造样例的思路：<ul><li>圈复杂度较高的环节：读入、输出、三角优化；</li><li>数据范围是否覆盖全面：例如sum的BigInteger</li><li>新增功能是否考虑全面：例如函数声明的空格和<code>i**n</code>的情况</li></ul></li></ul><h1 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h1><ul><li>不要出现50行+的方法，否则Bug修复的时候有方法超过60行的风险Orz</li><li>为debug模式重写<code>toString()</code>便于调试，尤其是包含嵌套hashmap的类；满足作业化简要求的的输出单独建立print()方法</li><li>尽量在作业的开始阶段留出一定的可扩展空间，降低后续的修改规模&amp;重构风险：比如作业1的时候偷懒按照幂次为单个char写的程序，不仅导致忘记幂次的前导符号和前导0，还导致作业2把幂次修改成大于8时只修改了lexer部分，后缀表达式有关幂次计算的部分忘记修改了；作业2的时候没有把sum和自定义函数作为字符串替换，而是在递归下降的过程中作为表达式因子替换，给作业3的嵌套函数留出了扩展性,作业3的相关功能也在作业2得到了测试;程序扩展一些额外的功能也意味着有更大的测试空间，对于数据生成程序的格式要求会降低，比如在作业1中不对括号层数和指数作限制时，测试的强度更高，数据生成程序也更简洁一些。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-C++与C#-项目分析报告</title>
      <link href="/2022/03/22/CPP-homework/"/>
      <url>/2022/03/22/CPP-homework/</url>
      
        <content type="html"><![CDATA[<img src="/2022/03/22/CPP-homework/1.png" class="" title="pic1"><span id="more"></span><h1 id="一、所选项目简介"><a href="#一、所选项目简介" class="headerlink" title="一、所选项目简介"></a>一、所选项目简介</h1><p>所选项目：c++实现的带GUI的背单词游戏</p><p>环境：VS2019 + EasyX</p><p>所选项目实现功能：三个不同的背单词游戏</p><p>所选项目开源库地址：<a href="https://github.com/Wenretium/Word-Games">https://github.com/Wenretium/Word-Games</a></p><h1 id="二、核心类结构——使用PlantUml绘制类图"><a href="#二、核心类结构——使用PlantUml绘制类图" class="headerlink" title="二、核心类结构——使用PlantUml绘制类图"></a>二、核心类结构——使用PlantUml绘制类图</h1><img src="/2022/03/22/CPP-homework/1.png" class="" title="pic1"><h1 id="三、面向对象特征分析"><a href="#三、面向对象特征分析" class="headerlink" title="三、面向对象特征分析"></a>三、面向对象特征分析</h1><h2 id="3-1-封装性"><a href="#3-1-封装性" class="headerlink" title="3.1 封装性"></a>3.1 封装性</h2><h3 id="3-1-1-基类Ball和Word"><a href="#3-1-1-基类Ball和Word" class="headerlink" title="3.1.1 基类Ball和Word"></a>3.1.1 基类Ball和Word</h3><ul><li><p>分别对图片的位置和单词的语义进行封装，为实现类或者派生类提供底层数据。</p></li><li><p>基类Ball中的坐标x和y均为protected类型，允许子类进行访问和修改当前图形所处的位置，保证游戏画面中各元素的运动性。</p></li><li><p>基类Word中的单词拼写和单词语义均为private类型并设置getter()方法进行访问，保证了单词数据的封装性。</p></li></ul><h3 id="3-1-2-派生类的新增属性"><a href="#3-1-2-派生类的新增属性" class="headerlink" title="3.1.2 派生类的新增属性"></a>3.1.2 派生类的新增属性</h3><ul><li><p>LetterBall的Letter字段为自身存储的字母，protect类型。便于子类LetterBallB::print()中直接访问父类LetterBall的letter，获取自身表示的字母。结合源码分析，此时LetterBall::getLetter()方法是冗余的，可以删去。</p><pre><code class="java">// 继承Ball，增加私有成员字母，作为Game2中每个浮现的字母class LetterBall :public Ball&#123;protected:    char letter;public:    LetterBall(char nletter, int xx, int yy) :Ball(xx, yy), letter(nletter) &#123;&#125;    virtual void print()=0;    char getLetter() &#123; return letter; &#125;&#125;;</code></pre></li><li><p>WordBurger和WordPiece的两个类中的关于LetterBall的聚合，如vector&lt;LetterBall*&gt;属于类的私有成员变量，外部通过调用类的check_click()、letterballs_empty()来与集合做交互，从而达到对外部隐藏集合，只提供方法接口。</p><pre><code class="java">// 用于Game3，每局创建一个WordBurger// 把Word英文单词拆成一组LetterBall，存入letterlayersclass WordBurger :public Word&#123;private:    list&lt;LetterBall*&gt;letterlayers;public:    WordBurger(Word nword);    ~WordBurger();    virtual void print() ;    bool moveNextLetter(list&lt;LetterBall*&gt;&amp; ls);    bool letterlayers_empty();&#125;;</code></pre></li></ul><h2 id="3-2-继承性"><a href="#3-2-继承性" class="headerlink" title="3.2 继承性"></a>3.2 继承性</h2><ul><li><p>基类Ball和Word。Ball负责控制图形坐标和位置移动。Word负责记录单词内容。</p></li><li><p>游戏1的内容是单词和意思匹配，玩家需要控制Basket篮子类左右移动，来接住不断下落的以小猫图形为背景的单词，所以类WordBall继承类Ball和Word。</p><img src="/2022/03/22/CPP-homework/2.png" class="" title="pic1"></li><li><p>游戏2的内容是以字母图标形式出现，按顺序点击字母拼出完整单词。所以类LetterBall表示字母图标，继承Ball，自己增加letter的char字段。类WordPiece表示由多个LetterBall聚合而成的完整单词，其也继承Word类用于记录自身单词内容。</p><img src="/2022/03/22/CPP-homework/3.png" class="" title="pic1"></li><li><p>游戏3的内容是使用篮子类Basket通过左右移动来接住汉堡的各个片层代表的字母，从而拼出完成单词。类LetterBallB表示字母的汉堡片层图标，继承LettterBall。类W ordBurger表示由多个LetterBallB聚合而成的完整单词，其继承Word类用于记录自身单词内容。</p><img src="/2022/03/22/CPP-homework/4.png" class="" title="pic1"></li></ul><h2 id="3-3-多态性"><a href="#3-3-多态性" class="headerlink" title="3.3 多态性"></a>3.3 多态性</h2><h3 id="3-3-1-virtual抽象类和重写父类方法实现的多态"><a href="#3-3-1-virtual抽象类和重写父类方法实现的多态" class="headerlink" title="3.3.1 virtual抽象类和重写父类方法实现的多态"></a>3.3.1 virtual抽象类和重写父类方法实现的多态</h3><ul><li><p>抽象类LetterBall中有virtual void print()=0; Word类有virtual void print()const;</p></li><li><p>在LetterBallA和LetterBallB中都有具体实现，分别用于游戏2和游戏3的不同字母图形实现。如：</p><pre><code class="java">void LetterBallB::print()&#123;    IMAGE let;    loadimage(&amp;let, _T(&quot;..\\hamburger\\stuff1.jpg&quot;), LayerWidth, LayerThickness, true);    putimage(x, y, &amp;pictures[1], SRCAND);    putimage(x, y, &amp;pictures[0], SRCPAINT);    setcolor(WHITE);    settextstyle(30, 0, _T(&quot;Consola&quot;));    outtextxy(x+LayerWidth/2, y+LayerThickness/2,letter);&#125;</code></pre></li><li><p>WordPiece和WordBurger中分别有LetterBallA和LetterBallB的集合，他们重写的打印方法print()为循环调用自身集合中元素的print()。如：</p><pre><code class="java">void WordBurger::print()&#123;        for (list&lt;LetterBall*&gt;::iterator iter = letterlayers.begin(); iter != letterlayers.end(); iter++)        (*iter)-&gt;print();&#125;</code></pre></li><li><p>WordBall并未重写print()方法，而是在运算符重载()的方法中实现print。目的是便于给for_each()传入对象的静态方法()，取代print()方法。因为需要重载的print()是动态绑定，不是静态方法。此时使用WordBall()即可显示出游戏1 的单词图形。</p><pre><code class="java">void WordBall::operator()(WordBall w)//用来替代print成员函数，便于使用for_each算法&#123;    setcolor(BLACK);    IMAGE cat;    loadimage(&amp;cat, _T(&quot;..\\cat1.jpg&quot;), 75, 50, true);    putimage(w.x, w.y, &amp;cat);    setbkmode(TRANSPARENT);    const char* c = (w.word).c_str();    int movesteps = 0;    if (w.word.size() &lt;= 6)movesteps = 12;    outtextxy(w.x + movesteps, w.y + 25, c);&#125;</code></pre></li></ul><h3 id="3-3-2-运算符重载实现的静态多态"><a href="#3-3-2-运算符重载实现的静态多态" class="headerlink" title="3.3.2 运算符重载实现的静态多态"></a>3.3.2 运算符重载实现的静态多态</h3><pre><code class="java">bool Word::operator==(Word a)&#123;    if (word == a.word&amp;&amp;meaning == a.meaning)        return true;    else return false;&#125;</code></pre><pre><code class="java">bool operator==(WordBall a, WordBall b)&#123;    if (a.getWord() == b.getWord() &amp;&amp; a.getMeaning() == b.getMeaning())        return true;    else return false;&#125;</code></pre><ul><li>父类Word和子类WordBall都实现了运算符==的重载，实现了运算符重载的静态多态，用于比较两个元素是否equal。</li></ul><h3 id="3-3-3-遵从多态的优化建议"><a href="#3-3-3-遵从多态的优化建议" class="headerlink" title="3.3.3 遵从多态的优化建议"></a>3.3.3 遵从多态的优化建议</h3><ul><li><p>Basket类中的print(string item)方法中存在以下结构：</p><pre><code class="java">if (item == &quot;basket&quot;) &#123; //… &#125;else (item == &quot;bread&quot;)&#123; //… &#125;</code></pre><p>用于实现游戏1和游戏3中用户分别移动控制的“篮子”对象和“面包”对象。此处可以使用多态来优化掉if-else的结构，Basket类和Bread类都继承自Item类，重写各自的print()方法。</p></li></ul><h1 id="四、其他关键语法"><a href="#四、其他关键语法" class="headerlink" title="四、其他关键语法"></a>四、其他关键语法</h1><h2 id="4-1-static"><a href="#4-1-static" class="headerlink" title="4.1 static"></a>4.1 static</h2><ul><li>WordBall中有static int count的类的静态成员，用于计数在场的WordBall的球数。在构造函数中++，在析构函数中–。</li></ul><pre><code class="java">int WordBall::count = 0;//静态数据成员，控制在场球数WordBall::WordBall(Word a, int xx, double sspeed) :Word(a.word, a.meaning), Ball(xx, 10), speed(sspeed)&#123;    count++;&#125;</code></pre><pre><code class="java">class WordBall :public Word, public Ball&#123;private:    double speed;public:    WordBall() :Word(), Ball() &#123;&#125;;    WordBall(Word a, int xx, double sspeed);    WordBall(const WordBall&amp; wb) :Word(wb), Ball(wb), speed(wb.speed)&#123; count++; &#125;    ~WordBall() &#123; count--; &#125;    static int count;    void falldown(int time) &#123; y += speed * time; &#125;    friend bool operator==(WordBall a, WordBall b);    void operator()(WordBall w);&#125;;</code></pre><h2 id="4-2-重写拷贝构造"><a href="#4-2-重写拷贝构造" class="headerlink" title="4.2 重写拷贝构造"></a>4.2 重写拷贝构造</h2><ul><li><p>可以观察到，在operator()、operator==函数中均存在WordBall类型的参数，此处为passed-by-value，则会使用WordBall的拷贝构造。</p></li><li><p>如果此时不给WordBall重写构造函数，即为浅拷贝，会造成在operator()、operator==函数执行完毕后对函数内创建的WordBall调取析构函数，导致默认拷贝构造时count没有++，但是析构时count–。</p></li><li><p>所以此时为了维护static count变量，需要重写拷贝构造，让发生拷贝构造时count也++。</p></li><li><p>重写拷贝构造时，子类拷贝构造函数不会自动调用父类的拷贝构造函数，即需要在<code>WordBall(const WordBall&amp; wb) :Word(wb), Ball(wb), speed(wb.speed)&#123; count++; &#125;</code>指明调用父类拷贝构造，否则会执行初始构造。</p></li></ul><h2 id="4-3-运算符重载：静态多态"><a href="#4-3-运算符重载：静态多态" class="headerlink" title="4.3 运算符重载：静态多态"></a>4.3 运算符重载：<strong>静态</strong>多态</h2><pre><code class="java">void WordBall::operator()(WordBall w)//用来替代print成员函数，便于使用for_each算法&#123;    setcolor(BLACK);    IMAGE cat;    loadimage(&amp;cat, _T(&quot;..\\cat1.jpg&quot;), 75, 50, true);    putimage(w.x, w.y, &amp;cat);    setbkmode(TRANSPARENT);    const char* c = (w.word).c_str();    int movesteps = 0;    if (w.word.size() &lt;= 6)movesteps = 12;    outtextxy(w.x + movesteps, w.y + 25, c);&#125;</code></pre><ul><li><p>此运算符重载的作用是实现print()功能。而选择运算符重载而非重写父类print()方法的原因如下：</p></li><li><p>在main()函数中调用了<code>for_each(present_balls.begin(), present_balls.end(), WordBall());</code>用来遍历打印WordBall。</p></li><li><p>从for_each()函数原型可以看出：<code>void for_each(T* begin, T* end, const Func&amp; f)</code>第三个参数需要一个静态方法引用。</p></li><li><p>而重写父类的虚方法print()是动态绑定，需要使用对象信息来完成，不是静态方法。</p></li><li><p>而运算符重载是静态多态，地址早绑定，在编译阶段确定函数地址，所以可以作为for_each()的第三个静态方法参数。</p></li></ul><h2 id="4-4-new与delete配合使用"><a href="#4-4-new与delete配合使用" class="headerlink" title="4.4 new与delete配合使用"></a>4.4 new与delete配合使用</h2><pre><code class="java">WordBurger::WordBurger(Word nword):Word(nword)&#123;    srand(int(time(0)));    for (int i = 0, n = 1; i &lt; word.size(); i++, n++)    &#123;        if (i == word.size() - 1)n = 0;//bread_end        letterlayers.push_back(new LetterBallB(word[i], rand() % 800, 0, n));    &#125;&#125;WordBurger::~WordBurger()&#123;    for (list&lt;LetterBall*&gt;::iterator iter = letterlayers.begin(); iter != letterlayers.end(); iter++)        delete *iter;&#125;</code></pre><ul><li>构造函数中的list&lt;LetterBall*&gt;letterlayers 使用new创建对象，在析构函数中使用迭代器iter进行delete操作。</li></ul><h2 id="4-5-深复制"><a href="#4-5-深复制" class="headerlink" title="4.5 深复制"></a>4.5 深复制</h2><pre><code class="java">WordPiece::WordPiece(const WordPiece&amp; wp)&#123;    for (int i = 0; i &lt; letterballs.size(); i++)        letterballs.push_back(new LetterBallA(*dynamic_cast&lt;LetterBallA*&gt;(wp.letterballs[i])));&#125;</code></pre><ul><li>由于WordPiece的构造函数中也使用了new作为vector&lt;LetterBall*&gt;letterballs集合，所以重写拷贝构造时需要进行深复制。</li></ul><h2 id="4-6-passed-by-reference"><a href="#4-6-passed-by-reference" class="headerlink" title="4.6 passed-by-reference"></a>4.6 passed-by-reference</h2><pre><code class="java">void wordmean_separate(string &amp;wordmean, string&amp; nword, string&amp; nmeaning)&#123;    //...split the line to word and meaning    nword = wordmean.substr(word_begin, word_end - word_begin + 1);    nmeaning = wordmean.substr(meaning_begin, wordmean.size() - meaning_begin + 1);&#125;</code></pre><ul><li>把一行有单词和中文的数据separate后返回截取得来的nword和nmeaing，此时需要传入String&amp;引用。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OO-UML类图自动生成</title>
      <link href="/2022/03/20/OO-UML/"/>
      <url>/2022/03/20/OO-UML/</url>
      
        <content type="html"><![CDATA[<h2 id="PlantUML-graphviz-自动生成"><a href="#PlantUML-graphviz-自动生成" class="headerlink" title="PlantUML + graphviz 自动生成"></a>PlantUML + graphviz 自动生成</h2><blockquote><p>个人觉得这个画出来的整体风格是最漂亮的</p><p>并且一键生成也很省心，<strong>包里的类图</strong>也可以画出来</p><p>也不需要专业版IDEA</p></blockquote><span id="more"></span><img src="/2022/03/20/OO-UML/1.png" class="" title="pic1"><ul><li><p>idea安装<code>PlantUML integration</code>、<code>PlantUML Parser</code>两个插件</p></li><li><p>下载<strong>graphviz</strong>：<a href="http://www.graphviz.org/download/%EF%BC%8C%E9%80%89%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84%E6%AF%94%E5%A6%82%60[graphviz-5.0.1">http://www.graphviz.org/download/，选一个合适的比如`[graphviz-5.0.1</a> (64-bit) EXE installer]`这个。好习惯放在<strong>全英</strong>目录下</p></li><li><p>在idea里配置该工具</p><ul><li>在<code>File -&gt; Setting</code>搜索<code>PlantUML</code>，打开这个窗口。建议<strong>搜索</strong>，因为在专业版（<code>Languages &amp; Framworks -&gt; PlantUML</code>）和非专业版（<code>Other Settings -&gt; PlantUML</code>）的目录好像不一样。</li><li>在<code>Graphviz dot excutable</code>一栏选上<code>Graphviz/bin/dot.exe</code>这个文件</li><li>点ok</li></ul></li><li><p>在左边文件目录，想要的包或者文件右键<code>PlantUML Parser</code>就可以自动生成PlantUML的类图代码和渲染的uml类图了</p></li><li><p>直接导出图片会非常不清晰，或者图片不全。解决办法：</p><ul><li>下载 plantuml.jar ：<a href="https://github.com/plantuml/plantuml/releases%EF%BC%8C%E6%AF%94%E5%A6%82%60[plantuml-1.2022.7.jar]%60%EF%BC%8C%E6%94%BE%E5%9C%A8%E5%90%88%E9%80%82%E7%9B%AE%E5%BD%95%E3%80%82%EF%BC%88github%E6%89%93%E5%BC%80/%E4%B8%8B%E8%BD%BD%E6%85%A2%EF%BC%9Ahttps://mmmusel.github.io/2022/03/20/OO-UML/#/github%E5%8A%A0%E9%80%9F%EF%BC%9A%EF%BC%89">https://github.com/plantuml/plantuml/releases，比如`[plantuml-1.2022.7.jar]`，放在合适目录。（github打开/下载慢：https://mmmusel.github.io/2022/03/20/OO-UML/#/github%E5%8A%A0%E9%80%9F%EF%BC%9A）</a></li><li>需要提前配置过 Java 环境变量。</li><li><code>Win + R -&gt; cmd</code> 打开命令行窗口，切换到 <code>plantuml.jar </code>的目录下。</li><li>输入命令 <code>java -DPLANTUML_LIMIT_SIZE=8192 -jar plantuml.jar umlpic.puml</code>。（umlpic.puml在java项目里生成，把它拖到 <code>plantuml.jar </code>目录下）</li><li><code>-DPLANTUML_LIMIT_SIZE</code> 参数是设置图像的宽高，需要设置对应的大小即可。</li><li>如果导出中文乱码：<code>java -DPLANTUML_LIMIT_SIZE=8192 -jar plantuml.jar -charset UTF-8 unlpic.puml</code></li><li>如果图像很大会存在内存问题。需要将参数 <code>- Xml1024m </code>添加到 Java 虚拟机</li></ul></li></ul><h2 id="IntelliJ-IDEA-专业版-自动生成"><a href="#IntelliJ-IDEA-专业版-自动生成" class="headerlink" title="IntelliJ IDEA 专业版 自动生成"></a>IntelliJ IDEA 专业版 自动生成</h2><img src="/2022/03/20/OO-UML/2.png" class="" title="pic1"><ul><li><p>没有专业版可以申请教育版：<a href="https://mmmusel.github.io/2022/03/20/OO-UML/#/IDEA%E6%95%99%E8%82%B2%E7%89%88">https://mmmusel.github.io/2022/03/20/OO-UML/#/IDEA%E6%95%99%E8%82%B2%E7%89%88</a></p></li><li><p><code>File -&gt; Setting -&gt; Tools -&gt; Diagrams</code>，把 <code>Java Class Diagrams</code>下面的勾全打上</p></li><li><p>左边目录右键包或者类，<code>Diagrams -&gt; 两个</code>都可以</p></li></ul><blockquote><p>有几个问题：</p><ol><li>解析包时，如果子目录有包，里面的类不能生成uml</li><li>类之间的关系连线较少</li></ol></blockquote><h2 id="starUML-自动生成"><a href="#starUML-自动生成" class="headerlink" title="starUML 自动生成"></a>starUML 自动生成</h2><img src="/2022/03/20/OO-UML/3.png" class="" title="pic1"><blockquote><p>真难用，建议不用，u4让我更烦starUML了。软件都卸了，找张摆烂图放一下</p></blockquote><ul><li><code>Tools -&gt; Exension manager </code>搜索下载<code>java</code>插件</li><li>重启starUML</li><li><code>Tools-&gt;java-&gt;Reverse Code</code> 选src文件夹，然后右边就会自动生成类的<strong>黄色</strong>框框</li><li><strong>黄色</strong>框框代表的类图直接拖进画布就可以自己排版然后连线表示类的关系了</li></ul><blockquote><p>有几个比较大的问题：</p><ol><li>不能保证所有的类都被解析出uml来，有的拖进画布是一个空的方块….或许可以试试删几个文件之类的再<code>Reverse Code</code>一次，说不定就有了（</li><li>类之间的关系需要自己连</li></ol></blockquote><h2 id="其他手动画图工具"><a href="#其他手动画图工具" class="headerlink" title="其他手动画图工具"></a>其他手动画图工具</h2><ul><li><code>PlantUML integration</code>：这个插件也支持自己写<code>PlantUML</code>风格的代码来设计类图，入口<code>File -&gt; New -&gt; PlantUML File</code></li><li>Mermaid：也是写代码生成类图</li><li>我最喜欢的drawio：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a> 下个本地版比网页好用一些。OS博客的图都是这个画的</li><li>processon：<a href="https://www.processon.com/">https://www.processon.com/</a> 这个跟上面那个差不多 好处是中文界面 缺点是容量限制。OO u1u2博客的图都是这个画的。后来u3u4的代码结构基本被官方包固定了，就拿plantUML自动生成了下</li></ul><h2 id="github加速："><a href="#github加速：" class="headerlink" title="github加速："></a>github加速：</h2><p><strong>dev-sidecar</strong>：<a href="https://gitee.com/interesting-goods/dev-sidecar?_from=gitee_search">https://gitee.com/interesting-goods/dev-sidecar?_from=gitee_search</a></p><ul><li><p>可能需要登录</p></li><li><p>链接如果失效，在gitee搜<code>dev-sidecar</code>就行</p></li></ul><h2 id="IDEA教育版"><a href="#IDEA教育版" class="headerlink" title="IDEA教育版"></a>IDEA教育版</h2><p><a href="https://zhuanlan.zhihu.com/p/378185042">https://zhuanlan.zhihu.com/p/378185042</a></p><p>有的学校邮箱可以直接申请：<a href="https://www.jetbrains.com/zh-cn/community/education/#students">https://www.jetbrains.com/zh-cn/community/education/#students</a></p><hr><p>参考：</p><ul><li><p>感谢npy呐💕 <a href="https://saltyfishyjk.github.io/">https://saltyfishyjk.github.io/</a></p></li><li><p><a href="https://blog.csdn.net/haodanlan4/article/details/121424968?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-121424968-blog-103826457.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-121424968-blog-103826457.pc_relevant_default&amp;utm_relevant_index=6">https://blog.csdn.net/haodanlan4/article/details/121424968?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3-121424968-blog-103826457.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3-121424968-blog-103826457.pc_relevant_default&amp;utm_relevant_index=6</a></p></li><li><p><a href="https://my.oschina.net/zhangyongjun/blog/4634239">https://my.oschina.net/zhangyongjun/blog/4634239</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab0</title>
      <link href="/2022/03/15/OS-lab0-summary/"/>
      <url>/2022/03/15/OS-lab0-summary/</url>
      
        <content type="html"><![CDATA[<p>操作系统 Lab0：git与shell</p><span id="more"></span><h1 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h1><h2 id="thinking-0-1"><a href="#thinking-0-1" class="headerlink" title="thinking 0.1"></a>thinking 0.1</h2><img src="/2022/03/15/OS-lab0-summary/0.png" class="" title="pic1"><img src="/2022/03/15/OS-lab0-summary/1.png" class="" title="pic1"><ul><li>不一样，第一次add前时README.md属于尚未跟踪文件；第二次修改后的文件属于工作区未暂存以备提交的变更。  </li><li>不同的原因：未跟踪文件不存在于.git对象库中，而修改后未提交的文件存在一份修改前的文件在.git的对象库。</li></ul><h2 id="thinking-0-2"><a href="#thinking-0-2" class="headerlink" title="thinking 0.2"></a>thinking 0.2</h2><p>1.add the file :<br><code>$ git add</code> <code>$ git commit</code><br>2.stage the file :<br><code>$ git add</code><br>3.commit :<br><code>$ git commit</code></p><h2 id="thinking-0-3"><a href="#thinking-0-3" class="headerlink" title="thinking 0.3"></a>thinking 0.3</h2><p>1.恢复工作区的printf.c :<br><code>$ git checkout -- printf.c</code><br>2.<code>$ git rm --cached printf.c</code>后，恢复暂存区文件：  </p><pre><code>$ git reset HEAD printf.c $ git checkout -- printf.c</code></pre><p>3.删除暂存区文件,同时保留本地：<br><code>git rm --cached Tucao.txt</code>  </p><h2 id="thinking-0-4"><a href="#thinking-0-4" class="headerlink" title="thinking 0.4"></a>thinking 0.4</h2><h3 id="命令与结果"><a href="#命令与结果" class="headerlink" title="命令与结果"></a>命令与结果</h3><ul><li>找到提交说明为1的哈希值，使用 git reset –hard <Hash-code> ，再使用git log，2和3的版本库消失了。</li><li>找到记录下的提交说明为3的哈希值，git reset –hard &lt;Hash-code&gt; ，再使用git log，123版本库均存在，但恢复的2和3的内容均回退为1的内容。<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3>git reset –hard &lt;Hash-code&gt;的版本回退问题：</li><li>HEAD类似指针，各提交版本类似链表。</li><li><code>git reset</code>回退到某个版本，只回退了commit信息，不会更改对象库内存储的文件对象.</li><li><code>git reset --hard</code>无法恢复，指在本地的源码变为回退版本库的内容，撤销的commit的更改被抹除。</li><li>实际上后退的版本库的文件对象仍存在于对象库中，<code>--hard</code>无法恢复指的是文件内容被改写，即被回退到的版本库的文件内容覆盖。</li></ul><h2 id="thinking-0-5"><a href="#thinking-0-5" class="headerlink" title="thinking 0.5"></a>thinking 0.5</h2><h3 id="1-1克隆时所有分支均被克隆。-正确"><a href="#1-1克隆时所有分支均被克隆。-正确" class="headerlink" title="1.1克隆时所有分支均被克隆。(正确)"></a>1.1克隆时所有分支均被克隆。(正确)</h3><ul><li>首先，git clone时若未使用git clone -b说明HEAD指向的分支，默认HEAD为master</li><li>第一次git clone时，HEAD指向master，此时git clone共12个文件</li><li>其后未对master进行修改，只对test1 test2分支进行修改</li><li>再次git clone -b master时，git clone共16个文件，说明<strong>克隆时所有分支均被克隆</strong><img src="/2022/03/15/OS-lab0-summary/2.png" class="" title="pic1"><h3 id="1-2只有HEAD指向的分支被检出。-正确"><a href="#1-2只有HEAD指向的分支被检出。-正确" class="headerlink" title="1.2只有HEAD指向的分支被检出。(正确)"></a>1.2只有HEAD指向的分支被检出。(正确)</h3></li><li>git clone -b master，git branch后只有master分支</li><li>git clone -b test1，git branch后只有test1分支<img src="/2022/03/15/OS-lab0-summary/3.png" class="" title="pic1"><h3 id="2-克隆出的工作区中执行-git-log、git-status、git-checkout、git-commit等操作不会去访问远程版本库。-正确"><a href="#2-克隆出的工作区中执行-git-log、git-status、git-checkout、git-commit等操作不会去访问远程版本库。-正确" class="headerlink" title="2.克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。(正确)"></a>2.克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。(正确)</h3></li><li>这四项命令均针对于clone时的<strong>版本快照</strong>，不会与远程库同步</li><li>只有git pull后才会实现本地依照更新的远程库进行更新的步骤</li><li>具体实现为：git clone后，在另外的本地库进行对远程库的修改，再回到刚刚git clone的本地库中执行git log等命令时，不会同步远程库的更新</li></ul><img src="/2022/03/15/OS-lab0-summary/4.png" class="" title="pic1"><img src="/2022/03/15/OS-lab0-summary/5.png" class="" title="pic1"><h3 id="3-克隆时只有远程版本库HEAD指向的分支被克隆。-错误，见1-1"><a href="#3-克隆时只有远程版本库HEAD指向的分支被克隆。-错误，见1-1" class="headerlink" title="3.克隆时只有远程版本库HEAD指向的分支被克隆。(错误，见1.1)"></a>3.克隆时只有远程版本库HEAD指向的分支被克隆。(错误，见1.1)</h3><h3 id="4-克隆后工作区的默认分支处于master分支。-见1-2"><a href="#4-克隆后工作区的默认分支处于master分支。-见1-2" class="headerlink" title="4.克隆后工作区的默认分支处于master分支。(见1.2)"></a>4.克隆后工作区的默认分支处于master分支。(见1.2)</h3><ul><li>若使用git clone，工作区默认分支处于master分支</li><li>若使用git clone -b branch，工作区默认分支处于branch分支</li></ul><h2 id="thinking-0-6"><a href="#thinking-0-6" class="headerlink" title="thinking 0.6"></a>thinking 0.6</h2><img src="/2022/03/15/OS-lab0-summary/6.png" class="" title="pic1"><ul><li><code>echo third &gt; output.txt</code> &gt; 覆盖</li><li><code>echo forth &gt;&gt; output.txt</code> &gt;&gt; 追加</li></ul><h2 id="thinking-0-7"><a href="#thinking-0-7" class="headerlink" title="thinking 0.7"></a>thinking 0.7</h2><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><pre><code class="shell">echo &#39;echo Shell Start...&#39; &gt; testecho &#39;echo set a = 1&#39; &gt;&gt;  testecho &#39;a=1&#39; &gt;&gt; testecho &#39;echo set b = 2&#39; &gt;&gt;  testecho &#39;b=2&#39; &gt;&gt; testecho &#39;echo set c = a+b&#39; &gt;&gt;testecho &#39;c=$[$a+$b]&#39; &gt;&gt;testecho &#39;echo c = $c&#39; &gt;&gt;testecho &#39;echo save c to ./file1&#39; &gt;&gt;testecho &#39;echo $c&gt;file1&#39; &gt;&gt;testecho &#39;echo save b to ./file2&#39; &gt;&gt; testecho &#39;echo $b&gt;file2&#39; &gt;&gt; testecho &#39;echo save a to ./file3&#39; &gt;&gt; testecho &#39;echo $a&gt;file3&#39; &gt;&gt; testecho &#39;echo save file1 file2 file3 to file4&#39; &gt;&gt; testecho &#39;cat file1&gt;file4&#39; &gt;&gt; testecho &#39;cat file2&gt;&gt;file4&#39; &gt;&gt; testecho &#39;cat file3&gt;&gt;file4&#39; &gt;&gt; testecho &#39;echo save file4 to ./result&#39; &gt;&gt; testecho &#39;cat file4&gt;&gt;result&#39; &gt;&gt;test</code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><pre><code class="shell">Shell Start...set a = 1set b = 2set c = a+bc = 3save c to ./file1save b to ./file2save a to ./file3save file1 file2 file3 to file4save file4 to ./result</code></pre><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><blockquote><p>3<br>2<br>1</p></blockquote><h3 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h3><ul><li>save可以将变量和文件的内容重定向至文件</li></ul><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><pre><code class="shell">echo echo Shell Startecho &#39;echo Shell Start&#39;# 显示echo Shell Startecho `echo Shell Start`# 显示``反引号内命令的执行结果Shell Start</code></pre><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><ul><li>echo命令无引号时，识别首尾的”echo …无变量无转义字符串… &gt; file”模式，重定向原字符串到文件，且无转移无变量；终端无输出</li><li>echo命令有单引号时，会把单引号的内容以无转义无变量的形式输出</li><li>echo命令有反引号时，会把反引号的内容作为命令执行，把命令的输出结果使用echo输出<h4 id="testbash-sh"><a href="#testbash-sh" class="headerlink" title="testbash.sh"></a>testbash.sh</h4>```shell<br>echo Shell Start…<br>echo set a = 1<br>a=1<br>echo set b = 2<br>b=2<br>echo set c = a+b<br>c=$[$a+$b]<br>echo c = $c<br>rm file1<br>echo echo $c&gt;file1<br>echo ‘echo $c&gt;&gt;file1’<br>echo <code>echo \$c&gt;&gt;file1</code></li></ul><p>echo echo $c&gt;file1<br>echo echo $c&gt;file1<br>echo echo \$c&gt;file1</p><h1 id="file1"><a href="#file1" class="headerlink" title="file1"></a>file1</h1><h1 id="echo-3"><a href="#echo-3" class="headerlink" title="echo 3"></a>echo 3</h1><h1 id="echo-c"><a href="#echo-c" class="headerlink" title="echo $c"></a>echo $c</h1><h1 id="echo-3-1"><a href="#echo-3-1" class="headerlink" title="echo \3"></a>echo \3</h1><hr><p>echo ‘echo $c&gt;&gt;file1’</p><h1 id="单引号：除了单引号，全部为字面意义"><a href="#单引号：除了单引号，全部为字面意义" class="headerlink" title="单引号：除了单引号，全部为字面意义"></a>单引号：除了单引号，全部为字面意义</h1><p>//变量引用、算术运算和子命令，都失效了<br>//所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（$），然后再对里层的单引号转义。<br>//更合理的方法是改在双引号之中使用单引号。<br>//echo $’it&#39;s’</p><hr><p>echo “echo $c&gt;&gt;file1”<br>echo “echo $c&gt;&gt;file1”<br>echo “echo \$c&gt;&gt;file1”</p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><h1 id="echo-3-gt-gt-file1"><a href="#echo-3-gt-gt-file1" class="headerlink" title="echo 3&gt;&gt;file1"></a>echo 3&gt;&gt;file1</h1><h1 id="echo-c-gt-gt-file1"><a href="#echo-c-gt-gt-file1" class="headerlink" title="echo $c&gt;&gt;file1"></a>echo $c&gt;&gt;file1</h1><h1 id="echo-3-gt-gt-file1-1"><a href="#echo-3-gt-gt-file1-1" class="headerlink" title="echo \3&gt;&gt;file1"></a>echo \3&gt;&gt;file1</h1><p>//三个特殊字符除外：美元符号（$）、反引号（`）和反斜杠（\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。<br>//美元符号用来引用变量，反引号则是执行子命令。<br>//换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。<br>//双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面</p><pre><code></code></pre><p>musel@musel-virtual-machine:~$ echo it’s</p><blockquote><p>s’<br>its<br>s</p></blockquote><pre><code>#### file1&gt; echo $c echo echo \$c&gt;file1 的输出  &gt; 3 echo \`echo \$c&gt;&gt;file1` 的输出#### out&gt; Shell Start...&gt; set a = 1&gt; set b = 2&gt; set c = a+b&gt; c = 3&gt; **echo \$c&gt;&gt;file1**   &gt; \# echo &#39;echo \$c&gt;&gt;file1&#39; 的输出&gt;   &gt; \# echo \`echo \$c&gt;&gt;file1` 输出一个回车# 二、实验难点## 1.sed命令的-n 和 -i模式 ——显示与修改的区别### 不使用 -i 参数时，&#39;d&#39;&#39;s&#39;相关的删除、替换等工作都是对于终端显示或重定向的，不修改源文件- `sed &#39;3p&#39; txt` 首先，sed的命令是按行遍历的，则此条命令在遍历输出txt时，会额外在遍历到第三行时输出第三行- `sed -n &#39;3p&#39; txt` 在遍历到第三行时输出第三行，输出仅一行- `sed &#39;3d&#39; txt` 输出源文件，不输出第三行- `sed -n &#39;3d&#39; txt` -n此时只输出操作行，操作行又被删去，所以无输出### 使用 -i 参数，对源文件修改- `sed -i &#39;s/str1/str2/g&#39; txt` 修改，无显示- `sed -n &#39;s/str1/str2/g&#39; txt` 无显示- `sed &#39;s/str1/str2/g&#39; txt` 显示替换后的文件- `sed &#39;/str/d&#39; txt` 不显示包含str的行- `sed -n &#39;/str/p&#39; txt` 显示包含str的行- `sed -n &#39;/aaa/p&#39; txt | sed &#39;s/aaa/bbb/g&#39;` 显示替换后的行## 2.gcc链接库文件 两种命令的区别- `-include filename`功能相当于在代码中使用`#include&lt;filename&gt;`,代码中不能出现`#include&lt;filename&gt;`- 对于代码中出现`#include&lt;filename&gt;`的情况，需要使用`-Ipath`链接库## 3.单引号与双引号的区别- 单引号无法引用变量，仅作为字符串解析- 双引号可以引用变量- `sed -i &#39;s/str1/str2/g&#39; txt`，如果str1的位置是`$1`**参数传递**，需要改成**双引号**## 4.makefile用法- 只使用外部Makefile```makefilefibo: code/main.c code/fibo.c # 依赖文件        gcc -c code/main.c code/fibo.c -I./include # 仅列出头文件所在目录即可        mv fibo.o ./code/fibo.o # -c只编译不链接        mv main.o ./code/main.o # 在当前makefile文件目录下生成        gcc -o fibo code/main.o code/fibo.o -I./includeclean:         rm ./code/fibo.o        rm ./code/main.o        </code></pre><ul><li>外层调用内层Makefile<br>外层：<pre><code class="makefile">new:./code/main.c ./code/main.c       cd ./code &amp;&amp; make # 同时执行两条命令clean:       cd ./code &amp;&amp; make clean</code></pre>内层：<pre><code class="makefile">new:main.c fibo.c      gcc -c main.c fibo.c -I../include      gcc main.o fibo.o -o ../fiboclean:      rm main.o      rm fibo.o</code></pre></li></ul><h1 id="三、体会与感想"><a href="#三、体会与感想" class="headerlink" title="三、体会与感想"></a>三、体会与感想</h1><ol><li>linux指令以及众多工具的命令过于简洁与灵活，部分资料仅有各种参数的说明而没有<strong>使用实例</strong>的情况下，较难理解掌握，链接资料读起来也难度不一，经常出现一行代码修改多次仍达不到想要的效果，或对于使用什么样的指令和参数无从下手。  </li><li>在虚拟机和git的环境下多尝试使用命令行实践，而不是字面意义上试图看懂各种复杂命令与参数，是上手更快的一种方式。</li><li>thinking的引导是很有启发的，在<strong>使用实例</strong>的复现和探索中，对于git和命令行的掌握更加深入。</li></ol><h1 id="四、指导书反馈"><a href="#四、指导书反馈" class="headerlink" title="四、指导书反馈"></a>四、指导书反馈</h1><ul><li>关于指导书’课程&gt;初识操作系统&gt;Git 专栏–轻松维护和提交代码&gt;Git文件状态’中，下图类似输入命令与文件状态的状态机，更为清晰。  </li><li>原图中出现的’add the file’(实际代表<code>git add  &amp; git commit</code>)容易与<code>git add</code>造成理解上的混淆  </li></ul><img src="/2022/03/15/OS-lab0-summary/7.png" class="" title="pic1"><ul><li>未跟踪<ul><li>  表示没有跟踪(add)某个文件的变化，使用git add即可跟踪文件</li><li>  <strong>工作区文件，未添加对象，易失</strong></li></ul></li><li>未修改  <ul><li>表示某文件在跟踪后一直没有改动过或者改动已经被提交</li><li>  <strong>工作区与对象库文件一致，且暂存区和版本库的目录树均指向此文件</strong></li></ul></li><li>已修改  <ul><li>表示修改了某个文件,但还没有加入(add)到暂存区中</li><li><strong>工作区和对象库不一致，暂存区和版本库的目录树均指向此对象库文件</strong></li></ul></li><li>已暂存  <ul><li>表示把已修改的文件放在下次提交(commit)时要保存的清单中</li><li><strong>第一次add时</strong>：对象库文件与工作区文件一致，暂存区指向对象库中此文件，版本库目录树无此文件指向</li><li><strong>后续add修改版本时</strong>：对象库存在工作区修改前后的两版，工作区为新版文件，暂存区指向对象库中的新版文件，版本库目录树指向对象库中旧版文件<h1 id="五、残留难点"><a href="#五、残留难点" class="headerlink" title="五、残留难点"></a>五、残留难点</h1></li></ul></li></ul><ol><li>makefile与gcc结合实现多文件链接编译中，对于makefile可以如何更加灵活地使用非常模糊。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell</title>
      <link href="/2022/03/12/shell/"/>
      <url>/2022/03/12/shell/</url>
      
        <content type="html"><![CDATA[<p>shell脚本基础</p><span id="more"></span><h1 id="shell脚本运行方式"><a href="#shell脚本运行方式" class="headerlink" title="shell脚本运行方式"></a>shell脚本运行方式</h1><h2 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序"></a>可执行程序</h2><ul><li>头文件 <code>·#!/bin/bash</code>,保证我们的脚本默认会使用bash。<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</li><li>添加权限 <code> chmod +x my.sh</code></li><li>传递参数：$n就代表第几个参数，而$0也就是命令</li><li>执行命令 <code>./my2.sh msg</code><ul><li>一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。<h2 id="解释器参数"><a href="#解释器参数" class="headerlink" title="解释器参数"></a>解释器参数</h2></li></ul></li><li><code>/bin/sh test.sh</code></li><li>不需要在第一行指定解释器信息</li></ul><h1 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h1><h2 id="显式赋值"><a href="#显式赋值" class="headerlink" title="显式赋值"></a>显式赋值</h2><ul><li><strong>定义变量</strong>时，不加<code>$</code></li><li>变量与赋值<code>=</code>间无空格</li><li>不能使用bash关键字。help命令查看</li><li><code>readonly</code>只读变量</li><li><code>unset</code>命令可以删除变量，不能删除只读变量</li><li>可二次赋值<pre><code class="shell">your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><h2 id="语句赋值"><a href="#语句赋值" class="headerlink" title="语句赋值"></a>语句赋值</h2><pre><code>for file in `ls /etc`for file in $(ls /etc)</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2></li><li>加<code>$</code></li><li><code>&#123;&#125;</code>识别变量边界;<code>echo &quot;I am good at $&#123;skill&#125;Script&quot;</code></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>单引号：<ul><li>字符串中的变量无效</li><li>不能出现单个的单引号，不能转义</li><li>可成对出现，作为字符串拼接</li></ul></li><li><strong>双引号</strong>可以出现<strong>变量和转义字符</strong><pre><code class="shell">your_name=&quot;runoob&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot; greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;# 均输出hello, runoob !</code></pre>```</li><li>字符串长度<ul><li>$</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Pre-Cause SR EPC BadVaddr</title>
      <link href="/2022/03/11/%E3%80%8AIDT%20R30xx%20Family%E3%80%8BChapter3/"/>
      <url>/2022/03/11/%E3%80%8AIDT%20R30xx%20Family%E3%80%8BChapter3/</url>
      
        <content type="html"><![CDATA[<p>《IDT R30xx Family Software Reference Manual》 Chapter 3 翻译</p><span id="more"></span><h1 id="Cause"><a href="#Cause" class="headerlink" title="Cause"></a>Cause</h1><p>查询Cause寄存器以决定异常类型并调用哪一种异常处理进程。</p><h2 id="BD-31-分支延迟"><a href="#BD-31-分支延迟" class="headerlink" title="BD [31] 分支延迟"></a>BD [31] 分支延迟</h2><ul><li>置位表示EPC没有指向实际异常指令，指向直接前序分支指令。</li><li>异常重进点为分支指令后的延迟槽时，EPC指向分支指令。这对重新执行分支是无害的，但是如果CPU从异常中返回分支延迟指令，则没有跳转分支，且异常会破坏中断的程序。</li><li><blockquote><p>软件唯一可能注意BD位的时间是：如果它必须分析‘冒犯’指令(如果BD = 1，则该指令位于EPC + 4 )。如果需要对指令进行仿真(例如在没有FPA的设备中使用浮点指令)，就会出现这种情况；或放置在分支延迟槽中的断点)。</p></blockquote><h2 id="CE-29-28-协处理器错误"><a href="#CE-29-28-协处理器错误" class="headerlink" title="CE [29:28] 协处理器错误"></a>CE [29:28] 协处理器错误</h2></li><li>如果异常是因为 协处理器指令是针对SR中CUx位未启用的CP，那么CE就有来自该指令的协处理器编号。<h2 id="IP-15-8-中断待决断"><a href="#IP-15-8-中断待决断" class="headerlink" title="IP [15:8] 中断待决断"></a>IP [15:8] 中断待决断</h2></li><li>显示当前生效的中断(但可能在实际表征异常的情况下被掩盖)。</li><li>这些位在六个硬件层次上都遵循CPU的输入。</li><li>位9和位8是可读/可写的，保存最后写入的值。</li><li>当8位中的任何一个被<strong>合适的IM位使能</strong>以及SR中全局中断使能标志IEc激活时，都会引起中断。</li><li>IP与其他Cause寄存器字段存在微妙不同：它并不表明异常发生时发生了什么，而是表明现在正在发生什么。<h2 id="ExcCode-6-2"><a href="#ExcCode-6-2" class="headerlink" title="ExcCode [6:2]"></a>ExcCode [6:2]</h2></li></ul><table><thead><tr><th>ExcCode Value</th><th>注记符</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>Int</td><td>中断</td></tr><tr><td>1</td><td>Mod</td><td>TLB修改</td></tr><tr><td>2</td><td>TLBL</td><td>TLB load</td></tr><tr><td>3</td><td>TLBS</td><td>TLB store</td></tr><tr><td>4</td><td>AdEL</td><td>load/I-fetch时，用户态下地址超出kuseg或在非对齐地址读字/半字</td></tr><tr><td>5</td><td>AdES</td><td>store时，用户态下地址超出kuseg或在非对齐地址读字/半字</td></tr><tr><td>6</td><td>IBE</td><td>取指令总线错误。外部硬件已经预示着某种错误；合适的异常处理是系统依赖。R30xx家族CPU不能在一个存储上采取总线错误；写缓冲区会使这样的异常‘不精确’。</td></tr><tr><td>7</td><td>DBE</td><td>load数据总线错误。外部硬件已经预示着某种错误；合适的异常处理是系统依赖。R30xx家族CPU不能在一个存储上采取总线错误；写缓冲区会使这样的异常‘不精确’。</td></tr><tr><td>8</td><td>Syscall</td><td>系统指令无条件生成</td></tr><tr><td>9</td><td>Bp</td><td>断点指令</td></tr><tr><td>10</td><td>RI</td><td>未定义指令</td></tr><tr><td>11</td><td>CpU</td><td>协处理器不可用</td></tr><tr><td>12</td><td>Ov</td><td>算术溢出。无符号计算如addu不会导致异常</td></tr><tr><td>13-31</td><td>未定义或在后续版本中定义</td><td></td></tr></tbody></table><h1 id="EPC"><a href="#EPC" class="headerlink" title="EPC"></a>EPC</h1><ul><li>异常的32位返回地址。引起(或遭受)异常的指令位于EPC。</li><li>Cause中BD置位时，EPC指向前序分支指令。</li></ul><h1 id="BadVaddr"><a href="#BadVaddr" class="headerlink" title="BadVaddr"></a>BadVaddr</h1><ul><li>存放32位导致异常的不合法的引用地址。</li><li>设置在任何MMU相关的异常上，由用户程序试图访问kuseg以外的地址，或者如果某个地址对引用的基准大小错误对齐。</li><li><blockquote><p>在其他任何异常后，此寄存器是未定义的。<br>特别要注意，它不是在一次总线错误后设置的。</p></blockquote></li></ul><h1 id="SR：存储MIPS-CPU的各种模式"><a href="#SR：存储MIPS-CPU的各种模式" class="headerlink" title="SR：存储MIPS CPU的各种模式"></a>SR：存储MIPS CPU的各种模式</h1><blockquote><p>注：以下标题格式为：[位名称] [在寄存器中的位数] [作用]</p></blockquote><h2 id="CU3-CU2-31-30-CP3CP2使用权"><a href="#CU3-CU2-31-30-CP3CP2使用权" class="headerlink" title="CU3,CU2 [31:30] CP3CP2使用权"></a>CU3,CU2 [31:30] CP3CP2使用权</h2><ul><li>软件使用BrCond[3:2]用于轮询的输入引脚 或 者加速异常解码。<h2 id="CU1-29-CP1使用权，能否使用FPA浮点协处理器"><a href="#CU1-29-CP1使用权，能否使用FPA浮点协处理器" class="headerlink" title="CU1 [29] CP1使用权，能否使用FPA浮点协处理器"></a>CU1 [29] CP1使用权，能否使用FPA浮点协处理器</h2><ul><li>置零时，内核态与用户态下运行FPA指令都会导致异常。</li><li>可用于停用空闲FPA。</li><li>如果使用BrCond[1]用于轮询的输入，没有FPA的CU1也会被置位。<h2 id="CU0-28-CP0使用权"><a href="#CU0-28-CP0使用权" class="headerlink" title="CU0 [28] CP0使用权"></a>CU0 [28] CP0使用权</h2></li><li>用户态使用nominally-priviledged指令(少)</li><li>CP0内核态保持可使用状态，无视CU0位。<h2 id="RE-25-用户态时反转大小端即字节顺序"><a href="#RE-25-用户态时反转大小端即字节顺序" class="headerlink" title="RE [25] 用户态时反转大小端即字节顺序"></a>RE [25] 用户态时反转大小端即字节顺序</h2></li><li>保证大小端系统间的移植性。</li><li>嵌入式系统实现反转字节序需要大量软件工作。<h2 id="BEV-22-引导异常向量"><a href="#BEV-22-引导异常向量" class="headerlink" title="BEV [22] 引导异常向量"></a>BEV [22] 引导异常向量</h2></li><li>置位：CPU使用ROM kseg2异常入口点。</li><li>通常置零</li><li>将异常向量重新定位到RAM地址，加快访问速度，允许使用”用户提供”的异常服务例程。<h2 id="TS-21-置位时关闭TLB"><a href="#TS-21-置位时关闭TLB" class="headerlink" title="TS [21] 置位时关闭TLB"></a>TS [21] 置位时关闭TLB</h2></li><li>程序地址同时匹配两个TLB条目</li><li>长时间此状态时损坏芯片</li><li>TLB关闭是永久的，只能被硬件复位清除。</li><li>软件依此判断硬件是否支持TLB<h2 id="PE-20-如果发生缓存奇偶错误，则置位"><a href="#PE-20-如果发生缓存奇偶错误，则置位" class="headerlink" title="PE [20] 如果发生缓存奇偶错误，则置位"></a>PE [20] 如果发生缓存奇偶错误，则置位</h2></li></ul></li><li>这个条件不会导致异常，真正只对诊断有用。</li><li>MIPS架构具有缓存诊断功能，因为早期版本的CPU使用外部缓存，这为验证特定系统的时序提供了一种方法。</li><li>对于这些实现，缓存奇偶错误位是必不可少的设计调试工具。</li><li>单片缓存不需要这个特性，R3071、R3081<h2 id="CM-19-显示用隔离D-cache执行的最后一次load操作的结果"><a href="#CM-19-显示用隔离D-cache执行的最后一次load操作的结果" class="headerlink" title="CM [19] 显示用隔离D-cache执行的最后一次load操作的结果"></a>CM [19] 显示用隔离D-cache执行的最后一次load操作的结果</h2><blockquote><p>CM是指如果缓存中确实包含了地址存储器位置的数据(即使缓存没有被隔离，缓存中的负载也会被击中)。</p></blockquote><h2 id="PZ-18-置位时缓存奇偶位写0并且不被检查"><a href="#PZ-18-置位时缓存奇偶位写0并且不被检查" class="headerlink" title="PZ [18] 置位时缓存奇偶位写0并且不被检查"></a>PZ [18] 置位时缓存奇偶位写0并且不被检查</h2></li><li>对早期需要外部RAM缓存的R3000A系统有价值。<h2 id="SwC-IsC-17-16-对内存管理和诊断的内存模式位"><a href="#SwC-IsC-17-16-对内存管理和诊断的内存模式位" class="headerlink" title="SwC IsC [17][16]对内存管理和诊断的内存模式位"></a>SwC IsC [17][16]对内存管理和诊断的内存模式位</h2><h2 id="SwC-17-交换缓存"><a href="#SwC-17-交换缓存" class="headerlink" title="SwC [17] 交换缓存"></a>SwC [17] 交换缓存</h2></li><li>所有load和store只能访问数据缓存，不访问内存。</li><li>此模式下局部字store(lb)使缓存条目无效</li><li>总线中不会出现未缓存的数据访问</li><li>此位不被reset初始化，故启动程式软件必须确保此位在依赖外部数据引用之前被正确初始化<h2 id="IsC-16-隔离缓存"><a href="#IsC-16-隔离缓存" class="headerlink" title="IsC [16] 隔离缓存"></a>IsC [16] 隔离缓存</h2></li><li>反转I-缓存和D-缓存功能，所以软件能够访问并使指令高速缓存条目无效<h2 id="IM-15-8-中断掩码-定义中断源，作为允许异常的标志"><a href="#IM-15-8-中断掩码-定义中断源，作为允许异常的标志" class="headerlink" title="IM [15:8] 中断掩码 定义中断源，作为允许异常的标志"></a>IM [15:8] 中断掩码 定义中断源，作为允许异常的标志</h2></li><li>六种中断源是外部引脚<ul><li>其中之一会被FPA使用，虽然与其他同属一个芯片，但逻辑层面是外在的</li><li>其余两种是Cause寄存器中软件写的中断位。</li></ul></li><li>CPU不提供中断优先级。硬件处理所有中断时一视同仁。[见异常处理章节]<h2 id="KUc-IEc-1-0-计算机保护位"><a href="#KUc-IEc-1-0-计算机保护位" class="headerlink" title="KUc IEc [1][0]计算机保护位"></a>KUc IEc [1][0]计算机保护位</h2><h2 id="KUc-1-内核态置位"><a href="#KUc-1-内核态置位" class="headerlink" title="KUc [1] 内核态置位"></a>KUc [1] 内核态置位</h2></li><li>内核状态下，软件可以在整个程序地址空间内得到并使用特权指令(CP0)。用户模式限制软件在<strong>kuseg</strong>地址空间内，运行权限指令时会被拒绝。违反此项规则会导致异常。<h2 id="IEc-0-置位允许计算机接受中断"><a href="#IEc-0-置位允许计算机接受中断" class="headerlink" title="IEc [0] 置位允许计算机接受中断"></a>IEc [0] 置位允许计算机接受中断</h2><h2 id="KUp-IEp-3-2"><a href="#KUp-IEp-3-2" class="headerlink" title="KUp IEp [3][2]"></a>KUp IEp [3][2]</h2></li><li>在异常时，硬件接受 KUc IEc 的值并保存在 KUp IEp。</li><li>同时修改KUc IEc为1和0。此时内核态下拒绝接受中断。</li><li>rfe指令可以被用于复制KUp IEp返还到KUc IEc。<h2 id="KUo-IEo-5-4"><a href="#KUo-IEo-5-4" class="headerlink" title="KUo IEo [5][4]"></a>KUo IEo [5][4]</h2></li><li>异常时KUp IEp在此处保存。</li><li>六个KU/IE位被一个三位深度，两位位宽的栈操作。</li><li>堆栈遇到异常时push，遇到ref指令pop。</li><li>这很早地在异常处理过程中 提供了从异常中干净恢复的机会 以至于第一个异常还未在SR中完成保存。</li><li>此类操作可以被完成的情况受限，仅用于允许用户TLB充填短一些的代码。[见内存管理章节]</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/03/11/git/"/>
      <url>/2022/03/11/git/</url>
      
        <content type="html"><![CDATA[<img src="/2022/03/11/git/2.png" class="" title="pic2"><span id="more"></span><h1 id="对象与目录的关系"><a href="#对象与目录的关系" class="headerlink" title="对象与目录的关系"></a>对象与目录的关系</h1><img src="/2022/03/11/git/1.png" class="" title="pic1"><ul><li><code>git add</code><ul><li> <strong>暂存区的目录树</strong>被更新</li><li> 同时工作区修改或新增的<strong>文件内容</strong>被写入到<strong>对象库</strong>中的一个<strong>新的对象</strong>中</li></ul></li><li><code>git commit</code><ul><li>将暂存区的<strong>目录树写到版本库</strong>（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树(?副本还是指针)</li></ul></li><li><code>git rm --cached &lt;file&gt;</code><ul><li>会直接从暂存区删除文件，工作区则不做出改变。</li></ul></li><li><code>git reset HEAD</code><ul><li><strong>暂存区的目录树</strong>会被<strong>master 分支指向的目录树</strong>所替换，但是<strong>工作区不受影响</strong>。</li></ul></li><li><code>git checkout -- &lt;file&gt;</code><ul><li>会用暂存区目录树指定的文件替换工作区的文件。</li><li>这个操作很危险，会<strong>清除工作区中未添加到暂存区的改动</strong>。</li></ul></li><li><code>git checkout HEAD &lt;file&gt;</code><ul><li>会用 HEAD 指向的 master 分支中的指定文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li><li><blockquote><p>版本库丢失目前文件的索引？文件仍可回退；工作区文件被替换，且未加入对象库，无法回退</p></blockquote></li><li>–hard 是 reset 命令唯一的危险用法，它也是 git 会真正地销毁数据的 几个操作之一。其他任何形式的 reset 调用都可以轻松撤消，但是 –hard 选项不能，因 为它强制覆盖了工作目录中的文件。若该文件还未提交，git 会覆盖它从而导致无法恢复。</li></ul></li></ul><h1 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h1><img src="/2022/03/11/git/2.png" class="" title="pic2"><ul><li><p>首先对于任何一个文件, 在 Git 内都只有四种状态: 未跟踪 (untracked)、未修改 (unmodified)、已修改 (modified)、已暂存 (staged)</p></li><li><p>未跟踪</p><ul><li>  表示没有跟踪(add)某个文件的变化，使用git add即可跟踪文件</li><li>  <strong>工作区文件，未添加对象，易失</strong></li></ul></li><li><p>未修改  </p><ul><li>表示某文件在跟踪后一直没有改动过或者改动已经被提交</li><li>  <strong>工作区与对象库文件一致，且暂存区和版本库的目录树均指向此文件</strong></li></ul></li><li><p>已修改  </p><ul><li>表示修改了某个文件,但还没有加入(add)到暂存区中</li><li><strong>工作区和对象库不一致，暂存区和版本库的目录树均指向此对象库文件</strong></li></ul></li><li><p>已暂存  </p><ul><li>表示把已修改的文件放在下次提交(commit)时要保存的清单中</li><li>第一次add时：对象库文件与工作区文件一致，暂存区指向对象库中此文件，版本库目录树无此文件指向</li><li>后续add修改版本时：对象库存在工作区修改前后的两版，工作区为新版文件，暂存区指向对象库中的新版文件，版本库目录树指向对象库中旧版文件</li></ul></li></ul><h1 id="转换形式"><a href="#转换形式" class="headerlink" title="转换形式"></a>转换形式</h1><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged</p><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2022/02/16/CSS/"/>
      <url>/2022/02/16/CSS/</url>
      
        <content type="html"><![CDATA[<p>CSS基础</p><span id="more"></span><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>内嵌式：写在&lt;style&gt;双标签，选择器查找标签。  </li></ul><pre><code class="css">&lt;style&gt;    div&#123;        color:red;        font-size:30px;        background-color:green;        width:400px;        hright:300px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><ul><li>外联式：写在单独.css，通过link标签在网页中引入<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</code></li><li>css写在标签的style属性，配合js使用<br><code>&lt;div style=&quot;color:green;&quot;&gt;内容&lt;/div&gt;;</code></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>标签选择器选择一类标签。</li><li>类选择器&lt;div&gt;<ul><li>一个标签可以多个类名，空格隔开</li><li>类名由数字字母下划线中划线组成，可以重复<pre><code class="css">&lt;head&gt;.one&#123;    /**/&#125;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;one&quot;&gt;内容&lt;/p&gt;&lt;div class=&quot;one&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;</code></pre></li></ul></li><li>id选择器<ul><li>#定义</li><li>所有标签都有且仅有一个id属性，id在一个页面唯一，一个id选择器只能选中一个标签值，配合js属性</li></ul></li><li>通配符选择器<ul><li>*{}定义</li><li>修改页面边距</li></ul></li></ul><blockquote><p>CSS层叠样式表，设置相同样式时按最后一次渲染</p></blockquote><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><ul><li>font-size:使用谷歌工具检查工具</li><li>font-weight:<ul><li>关键字：一般normal bold</li><li>纯数字：100~900整百</li></ul></li><li>font-style:normal/italic</li><li>font-family:微软雅黑，黑体，sans-serif //未安装微软雅黑使用黑体或任意非衬线字体</li><li>复合属性font:style weight size family<ul><li>只能省略前两个</li><li>单独的样式写在连写下方</li></ul></li></ul><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><ul><li>文本缩进text-indent:数字+px/em字大小</li><li>文本对齐text-align:left,center,right<ul><li>文本(h1)；span,a,input,img标签</li><li>属性加给父级标签内&lt;&gt;&lt;&gt;</li></ul></li><li>文本修饰text-decoration:underline(下划线);line-through(删除线);overline(上划线);none(a标签清除装饰线);</li><li>行高line-height：px/倍数<ul><li>font:style weight size/lineheight family</li></ul></li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><table><thead><tr><th align="left">颜色表示方式</th><th align="left">表示含义</th><th align="left">属性值</th></tr></thead><tbody><tr><td align="left">关键词</td><td align="left">预设颜色</td><td align="left">red</td></tr><tr><td align="left">rgb表示法</td><td align="left">红绿蓝，每项取值0~255</td><td align="left">rgb(0,255,255)</td></tr><tr><td align="left">rgba表示法</td><td align="left">a表示透明度，0~1</td><td align="left"></td></tr><tr><td align="left">十六进制表示法</td><td align="left">#红绿蓝</td><td align="left">#ff0000</td></tr></tbody></table><h2 id="code1"><a href="#code1" class="headerlink" title="code1"></a>code1</h2><pre><code class="css">&lt;html&gt;&lt;head&gt;&lt;style&gt;    div&#123;        margin:0 auto;/*div整体居中*/        /*text-align:center:此标签内部的所有内容居中*/    &#125;    h1&#123;        text-align:center;/*h1标题整体居中*/    &#125;    /*后面还有其他p段落，所以p副标题的居中不采用标签选择器，用类选择器*/    .center&#123;        text-align:center;    &#125;    .color1&#123;        color:#808080;    &#125;    .color2&#123;        color:#87ceeb;        font-weight:700;    &#125;    a&#123;        text-decoration:none;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;h1&gt;标题&lt;/h1&gt;        &lt;p class=&quot;center&quot;&gt;            &lt;span class=&quot;color1&quot;&gt;副标题1.1&lt;/span&gt;            &lt;span class=&quot;color2&quot;&gt;副标题1.2&lt;/span&gt;            &lt;a href=&quot; &quot;&gt;收藏本文&lt;/a&gt;        &lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul><li>后代选择器：<code>父选择器 后代选择器</code>(儿子、孙子…)</li><li>子代选择器：<code>父选择器&gt;子代选择器</code></li><li>并集选择器：<code>选择器1，选择器2，选择器n</code>(换行隔开 )</li><li>交集选择器：同时满足多个选择器的标签。选择器之间没有间隔符分隔，标签选择器必须写在类选择器前</li><li>hover伪类选择器：<code>选择器:hover&#123;css&#125;</code>鼠标悬停在元素的状态。</li></ul><h2 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法"></a>emmet语法</h2><p>//TODO</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>background-color:</li><li>background-image:url(./images/1.jpg);</li><li>background-repeat背景平铺:repeat/norepeat/repeat-x/repeat-y</li><li>background-position<ul><li>left/center/right ; top/center/bottom</li><li>+-数字px</li></ul></li><li>background推荐复合顺序：color image repeat position<blockquote><p>重要图片img，装饰性图片background</p></blockquote></li></ul><h2 id="显示模式"><a href="#显示模式" class="headerlink" title="显示模式"></a>显示模式</h2><ul><li>块级：独占一行、宽度默认父级标题、可以设置宽高。如&lt;div&gt;</li><li>行内：不换行、设置宽高不生效、宽高和内容一致。如&lt;a&gt;&lt;span&gt;</li><li>行内块：一行可以显示多个，可以设置宽高。如&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt;&lt;image&gt;<br><em><strong>！解析行内块或行内标签时，如果换行会产生空格</strong></em></li><li>元素显示模式转换display:block;inline-block;in-line<blockquote><p>标签嵌套原则：</p><ul><li>块级元素作为大容器，可以嵌套文本、块级元素，行内块，行内元素。</li><li>p不能嵌套div,p,h元素</li><li>a标签内部可以嵌套除a外任意元素</li></ul></blockquote></li></ul><h2 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h2><ul><li>继承性<ul><li>子元素默认继承父元素样式，可继承文字控制属性(color,font,text,line-height;height不生效)</li><li>继承失效：a标签的color;h标签的font-size</li></ul></li><li>层叠性：<strong>选择器优先级相同</strong><ul><li>不同样式叠加；相同样式覆盖。</li></ul></li><li>优先级<ul><li>继承&lt;通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;！important</li><li>覆盖范围越大，优先级越低</li><li>important权重最高，继承权重最低，但important不继承<pre><code class="css">&lt;head&gt;&lt;style&gt;    #box&#123;        color:orange;    &#125;    .box&#123;        color:blue;    &#125;    div&#123;        color:green !important;/*开发不建议使用*/    &#125;    body&#123;        color:red;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot; id=&quot;box&quot; style=&quot;color:pink&quot;&gt;priority&lt;/div&gt;&lt;/body&gt;</code></pre></li><li>权重叠加计算：复合选择器</li><li>（行内样式，id选择器，类选择器，标签选择器）<pre><code class="css">&lt;head&gt;&lt;style&gt;    /* (0,1,0,1) */    div #one&#123;        color:orange;    &#125;    /* (0,0,2,0) */    .father .son&#123;        color:blue;    &#125;    /* (0,0,1,1) */    .father p&#123;        color:green     &#125;    /* (0,0,0,2) */    div p&#123;        color:red;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt;priority&lt;/div&gt;&lt;/body&gt;</code></pre></li></ul></li></ul><h2 id="code2"><a href="#code2" class="headerlink" title="code2"></a>code2</h2><pre><code class="css">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        a&#123;            text-decoration: none;            width: 300px;            height: 50px;background-color: red;            display: inline-block;            /*a显示模式是行内，不能设置宽高，需要display转换*/            color:#fff;            text-align: center;            line-height: 50px;        &#125;        a:hover&#123;            background-color: orange;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;&quot;&gt;导航1&lt;/a&gt;    &lt;a href=&quot;&quot;&gt;导航2&lt;/a&gt;    &lt;a href=&quot;&quot;&gt;导航3&lt;/a&gt;    &lt;a href=&quot;&quot;&gt;导航4&lt;/a&gt;    &lt;a href=&quot;&quot;&gt;导航5&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><ul><li><p>border边框线  </p><ul><li><code>border:10px solid/dashed/dotted red</code>,不分先后顺序 </li><li>快捷键bd+tab</li><li>单方向边框：<code>border-left/top/bottom:</code></li></ul></li><li><p>padding内边距：边框和内容</p><ul><li><code>padding:top right bottom left</code> 顺时针<br><code>padding:top right&amp;left bottom</code><br><code>padding:top&amp;bottom right&amp;left</code>  </li></ul></li><li><p>margin外边距：盒子外边距，边框与边框间</p><ul><li>合并现象：垂直布局的块级元素，上下margin合并，取最大值</li><li>塌陷现象：互相嵌套的块级元素，子元素的margin-top会作用在父级元素上，导致父级元素一起下移</li></ul><blockquote><ul><li>解决办法：</li><li>父元素设置border-top或者padding-top,分隔父子元素的margin-top  </li><li>父元素设置overflow:hidden</li><li>转换成行内块元素</li><li>设置浮动  </li></ul></blockquote><ul><li>行内标签的margin/padding不改变垂直位置</li></ul></li></ul><h2 id="code3"><a href="#code3" class="headerlink" title="code3"></a>code3</h2><pre><code class="css">/* 从外到内：先宽高背景色，内容，内容位置，文字细节 */&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box &#123;            height: 40px;            border-top: 3px solid #ff8500;            border-bottom: 1px solid #edeef0;        &#125;        .box a&#123;            width: 80px;            height: 40px;            display: inline-block;            text-align: center;            line-height: 40;            font-size: 12px;            color:#4c4c4c;            text-decoration: none;        &#125;        .box a:hover &#123;            background-color: #edeef0;            color:#ff8400;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;a href=&quot;&quot;&gt;导航1&lt;/a&gt;        &lt;a href=&quot;&quot;&gt;导航2&lt;/a&gt;        &lt;a href=&quot;&quot;&gt;导航3&lt;/a&gt;        &lt;a href=&quot;&quot;&gt;导航4&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><ul><li>减少对类的依赖，根据HTML的结构关系找元素，保持代码整洁</li><li><code>label:first/last-child&#123;&#125;</code><br><code>label:nth-child(n)&#123;&#125;</code><br><code>label:nth-last-child(n)&#123;&#125;</code>  </li><li>n数字：n从1开始</li><li>n公式：n从0开始  <ul><li>偶数：2n/even  </li><li>奇数：2n+1/2n-1/odd  </li><li>前5个：-n+5  </li><li>从第5个往后：n+5  </li></ul></li></ul><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><ul><li>CSS模拟的标签效果<code>(父级元素)::before/after&#123;&#125;</code></li><li>默认行内元素，宽高不生效</li><li>必须加<code>content:&#39;&#39;</code>,否则不生效</li></ul><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><ul><li>作用：图文环绕/div盒子环绕</li><li>特点：浮动元素脱离标准位置，不占位置；浮动比标准流高半个级别，覆盖标准流的元素；浮动的标签顶端对齐；具备行内块效果；浮动盒子无法margin:0 auto水平居中</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ul><li><p>设置父级元素高度</p><ul><li>缺点：有些布局不能设置父级元素高度，如可变长度内容填充</li></ul></li><li><p>额外标签：在父级元素内容的最后添加块级元素，块级元素设置<code>clear:both</code></p><pre><code class="css">/* 子级浮动，父级未设置高度，可在父级内容添加 */&lt;head&gt;  &lt;style&gt;      .clearfix &#123;          clea:both;          /* 清除左右两侧浮动的影响 */      &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div&gt;      /* float1 */      /* float2 */      &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;standardStream&quot;&gt;standardStream&lt;/div&gt;&lt;body&gt;</code></pre></li><li><p>单伪元素清除法</p><pre><code class="css">/* 父级类&lt;div class=&quot;class_n clearfix&gt; */.clearfix::after &#123;  content:&#39;&#39;;  display:block;  clear:both;  /* 隐藏伪元素 保持低版本兼容性*/  height:0;  visibility:hidden;&#125;</code></pre></li><li><p>双伪元素清除法</p><pre><code class="css">.clearfix::before,/*解决外边距塌陷问题父子标签，都是块级，子级加margin会影响父级的位置*/.clearfix::after &#123;  content:&#39;&#39;;  display:tavle;&#125;.clearfix::after &#123;  clear:both;&#125;</code></pre></li><li><p>父元素设置overflow<br>优缺点。。。。。。。。。。。</p></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="网页常见布局形式"><a href="#网页常见布局形式" class="headerlink" title="网页常见布局形式"></a>网页常见布局形式</h3><ul><li>标准流：<ul><li>块级元素独占一行：垂直布局</li><li>行内元素/行内块元素一行显示多个：水平布局</li></ul></li><li>浮动：<ul><li>可以让原本垂直布局的块级元素变成水平布局</li></ul></li><li>定位：<ul><li>元素自由地摆放在网页的任意位置</li><li>盒子间的层叠情况：定位后元素层级最高，可以叠在其他盒子上面</li><li>盒子始终固定在屏幕的某个位置，如导航栏</li></ul></li></ul><h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><blockquote><p>position:static/relative/absolute/fixed<br>设置偏移值left/top:<br>同级定位，下压上;z-index设置</p></blockquote><ul><li>相对定位：<ul><li>相对自己原来的位置移动，原有占位不变(没有脱离标准流控制)</li></ul></li><li>绝对定位：<ul><li>如果有已经定位的父级，以就近定位父级为参照物；否则浏览器窗口为参照物。</li><li>脱离标准流，不占位</li><li>不能实现margin auto居中<pre><code class="css">/* 居中显示 */position:absolute;left:50%;margin-left:-150px/*水平距离一半*//*translate(-50%,0);*/</code></pre></li><li>变成行内块的显示模式:加宽度高度生效，如果没有宽度也没有内容，盒子的宽度尺寸是0</li><li>子绝父相：子级绝对定位，父级相对定位</li></ul></li><li>固定定位<ul><li>脱标，相对于浏览器窗口</li><li>行内块特点</li></ul></li></ul><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><ul><li>浏览器处理行内和行内块默认按基线对齐导致</li><li>baseline;top;bottom;middle;</li><li><pre><code class="css">/* 文本框和图片基线对齐 */input&#123;    height:50px;    box-sizing:boder-box;    vertical-align:middle;&#125;</code></pre></li><li><pre><code class="css">/* 父级div由文字内容撑开：图片取消基线对齐的两种处理模式 */img&#123;    vertical-align:middle;    display:block;&#125;</code></pre></li><li><pre><code class="css">/* 图片垂直 水平居中 */.father&#123;    width:600px;  /* 图片垂直居中 */    height:600px;    background-color:pink;    line-height:600px;  /* 图片垂直居中 */    /* 图片水平居中：处理行内和行内块按文字 */    text-align:center;&#125;img&#123;    vertical-align:middle;  /* 图片垂直居中 */&#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2022/02/14/HTML/"/>
      <url>/2022/02/14/HTML/</url>
      
        <content type="html"><![CDATA[<p>HTML基础</p><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="Web标准：各个浏览器显示效果相同"><a href="#Web标准：各个浏览器显示效果相同" class="headerlink" title="Web标准：各个浏览器显示效果相同"></a>Web标准：各个浏览器显示效果相同</h2><table><thead><tr><th align="left">语言</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">HTML</td><td align="left">文字、图片等<strong>页面元素</strong></td></tr><tr><td align="left">CSS</td><td align="left">网页元素的外观和位置等<strong>页面样式</strong></td></tr><tr><td align="left">JS</td><td align="left">页面的动态和交互效果</td></tr></tbody></table><h2 id="页面固定结构"><a href="#页面固定结构" class="headerlink" title="页面固定结构"></a>页面固定结构</h2><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;     &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><table><thead><tr><th align="left">标签</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">b/strong</td><td align="left">加粗</td></tr><tr><td align="left">u/ins</td><td align="left">下划线</td></tr><tr><td align="left">i/em</td><td align="left">倾斜</td></tr><tr><td align="left">s/del</td><td align="left">删除线</td></tr><tr><td align="left">h1</td><td align="left">一级标题</td></tr><tr><td align="left">br</td><td align="left">回车</td></tr><tr><td align="left">hr</td><td align="left">分割线</td></tr><tr><td align="left">p</td><td align="left">分段</td></tr></tbody></table><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><code>&lt;img src=&quot;&lt;./&gt;文件名+后缀名&quot; alt=&quot;图片显示失败的替换文本&quot; title=&quot;鼠标悬停的提示文本&quot;&gt; width=&quot;200&quot; heigth=&quot;100&quot;</code>   </p><ul><li>空格隔开，属性之间没有顺序之分  </li><li>heigth width只设置一个，等比例缩放；同时设置两个，改变比例  </li><li>相对路径：下级文件夹/文件名+后缀名；../返回上一级</li></ul><h2 id="音频视频"><a href="#音频视频" class="headerlink" title="音频视频"></a>音频视频</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">src</td><td align="left">路径</td></tr><tr><td align="left">controls</td><td align="left">显示播放的控件</td></tr><tr><td align="left">autoplay</td><td align="left">自动播放，部分浏览器不支持；谷歌浏览器配合muted实现静音播放</td></tr><tr><td align="left">loop</td><td align="left">循环播放</td></tr></tbody></table><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><code>&lt;a href=&quot;https://www.baidu.com/&quot;&gt;跳转字符&lt;/a&gt;</code><br><code>&lt;a href=&quot;路径&quot;&gt;跳转字符&lt;/a&gt;</code><br><code>&lt;a href=&quot;#&quot;&gt;跳转字符&lt;/a&gt;</code> 空链接  </p><ul><li><strong>targrt</strong>：<code>_self</code>覆盖；<code>_blank</code>新建。</li></ul><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表ul-有序列表ol"><a href="#无序列表ul-有序列表ol" class="headerlink" title="无序列表ul 有序列表ol"></a>无序列表ul 有序列表ol</h2><pre><code class="html">&lt;ul&gt;    &lt;li&gt;&lt;!--ul只能包含&lt;li&gt;标签--&gt;&lt;/li&gt;    &lt;li&gt;&lt;!--&lt;li&gt;标签可以包含任意内容--&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><pre><code class="html">&lt;dd&gt; &lt;!--dl标签只能包含dd/dt--&gt;    &lt;dt&gt;        &lt;dd&gt;&lt;!--dd默认有缩进--&gt;&lt;/dd&gt;    &lt;/dt&gt;&lt;/dd&gt;</code></pre><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code class="html">&lt;table border=&quot;1&quot; width=&quot;500&quot;&gt;    &lt;caption&gt;&lt;strong&gt;加粗标题&lt;/caption&gt;&lt;/strong&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;第一列&lt;/td&gt;            &lt;th&gt;第二列&lt;/td&gt;            &lt;th&gt;第三列&lt;/td&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;/tbody&gt;        &lt;tr&gt;            &lt;td&gt;(1,1)&lt;/td&gt;            &lt;td&gt;(1,2)&lt;/td&gt;            &lt;td&gt;(1,3)&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td&gt;(2,1)&lt;/td&gt;            &lt;td&gt;(2,2)&lt;/td&gt;            &lt;td&gt;(2,3)&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;</code></pre><table><thead><tr><th align="left">table属性</th><th align="left">效果(推荐CSS)</th></tr></thead><tbody><tr><td align="left">border</td><td align="left">边框宽度</td></tr><tr><td align="left">width</td><td align="left"></td></tr><tr><td align="left">heigth</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">标签</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">th</td><td align="left">tr内部，替换td，列标题默认居中加粗</td></tr><tr><td align="left">caption</td><td align="left">表格标题，table内部</td></tr></tbody></table><blockquote><p>表格结构标签，包裹hr，可省略<br>thead,tbody,tfoot</p></blockquote><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><ul><li>左上原则确定保留单元格，删除其他</li><li>跨行合并rowspan,跨列合并colspan<br>`<td rowspan="2">内容</td></li><li>不同结构标签不能合并</li></ul><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="input单标签"><a href="#input单标签" class="headerlink" title="input单标签"></a>input单标签</h2><table><thead><tr><th align="left">type属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">输入单行文本</td></tr><tr><td align="left">password</td><td align="left">密码</td></tr><tr><td align="left">radio</td><td align="left">单选框</td></tr><tr><td align="left">checkbox</td><td align="left">多选框</td></tr><tr><td align="left">file</td><td align="left">文件选择</td></tr><tr><td align="left">submit</td><td align="left">提交按钮</td></tr><tr><td align="left">reset</td><td align="left">重置按钮</td></tr><tr><td align="left">button</td><td align="left">普通按钮，配合js添加功能</td></tr></tbody></table><pre><code class="html">&lt;!-- 占位符placeholder --&gt;密码：&lt;input type=&quot;text&quot; placeholder=&quot;内容&quot;&gt;&lt;!-- 复选框（多选一）name --&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女&lt;!-- 默认选择checked --&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女&lt;!-- 上传多个文件multiple --&gt;选择文件：&lt;input type=&quot;file&quot; multiple&gt;&lt;!-- button相关按钮需要表单域form --&gt;&lt;!-- button相关按钮文字内容value --&gt;&lt;form action=&gt;    &lt;input type=&quot;button&quot; value=&quot;&quot;&gt;&lt;/form&gt;</code></pre><h2 id="button双标签"><a href="#button双标签" class="headerlink" title="button双标签"></a>button双标签</h2><p><code>&lt;button type=&quot;reset&quot;&gt;&lt;/button&gt;</code></p><h2 id="select下拉菜单双标签"><a href="#select下拉菜单双标签" class="headerlink" title="select下拉菜单双标签"></a>select下拉菜单双标签</h2><pre><code class="html">&lt;select&gt;    &lt;!-- 默认选择selected --&gt;    &lt;option selected&gt;内容1&lt;/option&gt;    &lt;option&gt;内容2&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="textarea文本域双标签"><a href="#textarea文本域双标签" class="headerlink" title="textarea文本域双标签"></a>textarea文本域双标签</h2><p>cols:文本域可见宽度<br>rows:文本域可见行数<br>右下角可以拖拽大小，推荐CSS设置</p><h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><ul><li>label把内容裹起来，表单标签添加id属性，label标签的for属性设置为对应的id属性值 </li><li>用label标签把内容和表单一起包裹，label的for属性删除即可 <pre><code class="html">性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked id=&quot;x&quot;&gt; &lt;label for=&quot;x&quot;&gt;男&lt;/label&gt;&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女&lt;/label&gt;</code></pre></li></ul><h1 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h1><h2 id="无语义双标签"><a href="#无语义双标签" class="headerlink" title="无语义双标签"></a>无语义双标签</h2><p>div:一行显示一个<br>span:一行显示多个</p><h2 id="有语义双标签"><a href="#有语义双标签" class="headerlink" title="有语义双标签"></a>有语义双标签</h2><p>HTML5，有语义的布局标签供手机端开发者使用<br>header 头部;nav 导航;footer 底部;aside 侧边栏;section 区块;article 文章;  </p><h2 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h2><p>空格<code>&amp;nbsp;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/27/hello-world/"/>
      <url>/2022/01/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World，Hexo！</p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
