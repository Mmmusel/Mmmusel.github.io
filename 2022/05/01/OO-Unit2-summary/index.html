<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>BUAA-OO-Unit2 | Musel's blog</title><meta name="keywords" content="OO"><meta name="author" content="Musel"><meta name="copyright" content="Musel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、电梯的调度策略1.1 状态转移图  1.2 纵向电梯的LOOK算法LOOK算法实现 与真实的电梯大致相同的策略，即维护电梯当前运行方向dir，更远层无请求(各楼层的call请求&amp;电梯中乘客的目的地请求)时才转向。   为了在实现捎带策略的同时将电梯和调度器功能解耦，电梯应当①具有“短视性”，即并不知道自己的目的楼层，而是仅根据从调度器获取上行、下行的boolean值。在此条件下电梯实现">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OO-Unit2">
<meta property="og:url" content="https://mmmusel.github.io/2022/05/01/OO-Unit2-summary/index.html">
<meta property="og:site_name" content="Musel&#39;s blog">
<meta property="og:description" content="一、电梯的调度策略1.1 状态转移图  1.2 纵向电梯的LOOK算法LOOK算法实现 与真实的电梯大致相同的策略，即维护电梯当前运行方向dir，更远层无请求(各楼层的call请求&amp;电梯中乘客的目的地请求)时才转向。   为了在实现捎带策略的同时将电梯和调度器功能解耦，电梯应当①具有“短视性”，即并不知道自己的目的楼层，而是仅根据从调度器获取上行、下行的boolean值。在此条件下电梯实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-05-01T04:46:53.000Z">
<meta property="article:modified_time" content="2022-05-02T12:04:27.190Z">
<meta property="article:author" content="Musel">
<meta property="article:tag" content="OO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mmmusel.github.io/2022/05/01/OO-Unit2-summary/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/',
      css: '/'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OO-Unit2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-02 20:04:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/photo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Home/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Musel's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Home/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/Link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">BUAA-OO-Unit2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-05-01T04:46:53.000Z" title="发表于 2022-05-01 12:46:53">2022-05-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OO-Unit2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、电梯的调度策略"><a href="#一、电梯的调度策略" class="headerlink" title="一、电梯的调度策略"></a>一、电梯的调度策略</h1><h2 id="1-1-状态转移图"><a href="#1-1-状态转移图" class="headerlink" title="1.1 状态转移图"></a>1.1 状态转移图</h2><img src="/2022/05/01/OO-Unit2-summary/5.png" class="" title="pic1">

<h2 id="1-2-纵向电梯的LOOK算法"><a href="#1-2-纵向电梯的LOOK算法" class="headerlink" title="1.2 纵向电梯的LOOK算法"></a>1.2 纵向电梯的LOOK算法</h2><h3 id="LOOK算法实现"><a href="#LOOK算法实现" class="headerlink" title="LOOK算法实现"></a>LOOK算法实现</h3><ul>
<li>与真实的电梯大致相同的策略，即维护电梯当前运行方向dir，更远层无请求(各楼层的call请求&amp;电梯中乘客的目的地请求)时才转向。  </li>
<li>为了在实现捎带策略的同时将电梯和调度器功能解耦，电梯应当①具有“短视性”，即并不知道自己的目的楼层，而是仅根据从调度器获取上行、下行的boolean值。在此条件下电梯实现以层间运行时间为最小单位实时更新可稍带目标层。②屏蔽外部各楼层的call请求：按运行方向运行一层后，询问调度器是否应该开门。  </li>
</ul>
<h3 id="LOOK算法相较ALS的优势"><a href="#LOOK算法相较ALS的优势" class="headerlink" title="LOOK算法相较ALS的优势"></a>LOOK算法相较ALS的优势</h3><ul>
<li><p>打破了ALS算法可能出现的<strong>“局部性原理”</strong>。  </p>
</li>
<li><p>即ALS算法在将电梯内部乘客全部送达后形成空梯时，会选择最先到达的请求作为主请求。两种策略下对于<strong>中间楼层的捎带表现一致</strong>，但是ALS策略下<strong>低层和高层请求</strong>因为<strong>难于被捎带而堆积</strong>，直到被安排为主请求时才会运行到低层或高层。此类请求容易堆积在末尾才进行集中处理，导致电梯出现因为一个远端请求<strong>空转</strong>(<strong>无捎带</strong>，远端请求的vip专梯)的效率问题。</p>
</li>
<li><p>LOOK算法更像是<strong>就近远端捎带</strong>，在将电梯内部乘客全部送达后形成空梯时会沿此方向去处理远端请求，避免了底层和高层请求因为难于捎带而堆积后的空转问题，效率较好。  </p>
</li>
</ul>
<h2 id="1-3-横向电梯"><a href="#1-3-横向电梯" class="headerlink" title="1.3 横向电梯"></a>1.3 横向电梯</h2><h3 id="就近策略"><a href="#就近策略" class="headerlink" title="就近策略"></a>就近策略</h3><ul>
<li><p>不再需要LOOK算法  </p>
<p>LOOK算法的优势在于处理纵向梯难于到达的高底层问题，而横向电梯由于下面两个原因不需要LOOK算法。  </p>
<p>①横向电梯仅5个座    </p>
<p>②横向电梯可环状运行，即打破纵向电梯1层与10层的时间差    </p>
</li>
<li><p>就近策略的实现<br>①判定请求的方向时按<strong>最短运行路径</strong>  </p>
<p>②同方向捎带  </p>
<p>③空梯时选择<strong>距离最近</strong>的请求作为主请求  </p>
</li>
<li><p>就近策略的电梯利用率比较高，因为总运行路径最短，比较适合横向电梯出现大量请求的情况下使用，比较适合hw7。缺点是开关门的次数比按同方向运行的横向电梯多，顾客等待电梯转到自己方向的时间比较长。不过由于hw6拖后腿的是纵向电梯，所以请求少的时候这种策略也不会很耽误事。  </p>
</li>
</ul>
<h2 id="1-4-性能分析"><a href="#1-4-性能分析" class="headerlink" title="1.4 性能分析"></a>1.4 性能分析</h2><ul>
<li>hw5实现LOOK算法后性能分98，发现的问题是：调度器在<strong>是否应该开门</strong>时没有考虑<strong>已满员</strong>的情况，导致出现满员时在请求层开门，电梯发现满员不接客，出现空开关门的情况 :(</li>
<li>所以在hw6重构了纵向电梯优化掉了开关门问题，然而性能分只有96 :( 观察输出后发现主要问题不在调度器的调度策略上，而是重构以后的LOOK算法出了问题：虽然<strong>捎带</strong>要满足<strong>同方向</strong>才可捎带，但是LOOK算法的<strong>远端请求</strong>可以为任意方向。有几个强测85的点观察输出后发现是因为远端请求被一刀切成同方向，导致<strong>反方向的请求没有被LOOK到</strong>不会远端捎带，退化成ALS的主请求造成堆积。  </li>
<li>个人感觉比较影响hw6性能分的一些85的点的问题并不在调度器策略，对于后两次作业来说，在hw5把LOOK算法实现好就可以保证比较可观的性能分，比起写复杂的调度器算法更符合二八法则 :)</li>
</ul>
<h1 id="二、调度器"><a href="#二、调度器" class="headerlink" title="二、调度器"></a>二、调度器</h1><h2 id="2-1-调度器设计"><a href="#2-1-调度器设计" class="headerlink" title="2.1 调度器设计"></a>2.1 调度器设计</h2><h3 id="2-1-1-电梯调度器使用掩码表示楼层请求，取代遍历"><a href="#2-1-1-电梯调度器使用掩码表示楼层请求，取代遍历" class="headerlink" title="2.1.1 电梯调度器使用掩码表示楼层请求，取代遍历"></a>2.1.1 电梯调度器使用掩码表示楼层请求，取代遍历</h3><ul>
<li>FLOOR[1]为<code>10&#39;b1</code>，FLOOR[3]为二进制<code>10&#39;b100</code></li>
<li><del>后来Experiment4才知道可以用Bitset</del></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] FLOOR = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        FLOOR[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;h &lt; <span class="number">12</span>;h++) &#123;</span><br><span class="line">            FLOOR[h] = <span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>掩码表示楼层请求，取代遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> inElv;<span class="comment">//电梯中所有人的目的地</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> upCall;<span class="comment">//上行请求发出层</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> downCall;<span class="comment">//下行请求发出层</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> inElv | upCall | downCall;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否开门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isToOpen</span><span class="params">(<span class="type">boolean</span> dir,<span class="type">int</span> nowFloor)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> order;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowCall</span> <span class="operator">=</span> ((dir) ? upCall : downCall);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((inElv &amp; FLOOR[nowFloor]) &gt; <span class="number">0</span>) &#123; order =  <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((nowCall &amp; FLOOR[nowFloor]) &gt; <span class="number">0</span>) &amp;&amp; (inNum &lt; capacity)) &#123; order = <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; order = <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断远端是否有请求 即判断是否换向，无需遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">furtherNoReq</span><span class="params">(<span class="type">boolean</span> dir,<span class="type">int</span> nowFloor)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> noReq;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> inElv | upCall | downCall;</span><br><span class="line">        <span class="keyword">if</span> (dir) &#123;</span><br><span class="line">            noReq = (!(status &gt;= FLOOR[nowFloor + <span class="number">1</span>]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            noReq = ((status &amp; (FLOOR[nowFloor] - <span class="number">1</span>)) == <span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> noReq;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-座调度器分配纵向电梯的调度策略"><a href="#2-1-2-座调度器分配纵向电梯的调度策略" class="headerlink" title="2.1.2 座调度器分配纵向电梯的调度策略"></a>2.1.2 座调度器分配纵向电梯的调度策略</h3><p>①优先分配空梯</p>
<p>②LOOK算法能捎带的电梯：处在电梯运行方向的远端+加入该请求后此次此方向的可稍带请求不会因此请求的加入导致满员而无法捎带</p>
<p>上行时的判断<strong>捎带后不满员</strong>的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护当前方向的upNum[i]：i层将要进入电梯的人数</span></span><br><span class="line"><span class="comment">//维护当前方向的outNum[i]：i层将要下电梯的人数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">people</span> <span class="operator">=</span> inElvNum;<span class="comment">//当前电梯人数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> floor;i &lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">    people = people + upNum[i] - outNum[i];</span><br><span class="line">    <span class="keyword">if</span> (people &gt; capacity) &#123;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">notifyAll();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>③无可稍带的电梯，则<strong>上行</strong>请求分配给当前<strong>未处理请求数最少</strong>的<strong>下行</strong>电梯(换向后可处理此请求)；<strong>下行</strong>请求分配给当前<strong>未处理请求数最少</strong>的<strong>上行</strong>电梯</p>
<h3 id="2-1-3-层调度器分配横向电梯的调度策略"><a href="#2-1-3-层调度器分配横向电梯的调度策略" class="headerlink" title="2.1.3 层调度器分配横向电梯的调度策略"></a>2.1.3 层调度器分配横向电梯的调度策略</h3><ul>
<li>当前未到达请求数最少的电梯调度器</li>
</ul>
<h3 id="2-1-4-hw7的请求拆分策略"><a href="#2-1-4-hw7的请求拆分策略" class="headerlink" title="2.1.4 hw7的请求拆分策略"></a>2.1.4 hw7的请求拆分策略</h3><ul>
<li>分成五类：纵向直达、横向直达、横+纵、纵+横、纵+横+纵。分别在<code>ProRequest</code>中标记好下一站目的地，投入对应层/座的调度器。</li>
<li>允许在某一层<strong>乘坐两次横向电梯</strong>扩展横向电梯的可达性：由于横向电梯只有五个座比较容易连通，且为了横向梯的可达性而去一层或其他层中转的纵向时间代价比较大，所以采取<code>Arraylist&lt;NextBuilding&gt;</code>存储横向电梯的两次换乘，以达到尽量<strong>缩减去其他层中转的纵向电梯的代价</strong>。</li>
</ul>
<h3 id="2-1-5-调度器的性能分析"><a href="#2-1-5-调度器的性能分析" class="headerlink" title="2.1.5 调度器的性能分析"></a>2.1.5 调度器的性能分析</h3><ul>
<li>hw6强测96，主要是LOOK算法没有优化好。</li>
<li>LOOK算法修正后hw7强测98，我认为在调度器的调度策略上还是比较好地符合了二八定律的 :)</li>
</ul>
<h2 id="2-2-UML协作图与三次作业的迭代"><a href="#2-2-UML协作图与三次作业的迭代" class="headerlink" title="2.2 UML协作图与三次作业的迭代"></a>2.2 UML协作图与三次作业的迭代</h2><ul>
<li><p>输入线程、层\座的调度器线程、电梯线程三类线程之间的协作关系由<strong>两类调度器</strong><code>BuildingScheduler``ElevatorScheduler</code>负责<strong>中转请求</strong>、<strong>信息交互</strong>和<strong>计算调度</strong>。后续将结合UML类图具体说明。</p>
</li>
<li><p>下图为协作方面的迭代设计。</p>
</li>
</ul>
<img src="/2022/05/01/OO-Unit2-summary/4.png" class="" title="pic1">

<h2 id="2-3-协作模式与调度器功能"><a href="#2-3-协作模式与调度器功能" class="headerlink" title="2.3 协作模式与调度器功能"></a>2.3 协作模式与调度器功能</h2><h3 id="hw5-UML类图"><a href="#hw5-UML类图" class="headerlink" title="hw5 UML类图"></a>hw5 UML类图</h3><img src="/2022/05/01/OO-Unit2-summary/1.png" class="" title="pic1">

<h3 id="hw5-生产者消费者模式"><a href="#hw5-生产者消费者模式" class="headerlink" title="hw5 - 生产者消费者模式"></a>hw5 - 生产者消费者模式</h3><ul>
<li><p>仅有输入线程、电梯线程和每个电梯的调度器。</p>
</li>
<li><p>中转请求：</p>
<ul>
<li>调度器负责接受来自输入线程的请求，把当前楼层的请求发放给电梯。使用生产者消费者模式。</li>
</ul>
</li>
<li><p>信息交互：</p>
<ul>
<li><p>调度器作为电梯线程的决策类，综合当前的各层请求和电梯状态，计算电梯的下一步行为。包括：本层是否开门、是否进入等待请求的阻塞状态、是否换向。</p>
</li>
<li><p>调度器接受输入线程的终止信号，传递给电梯线程，作为线程结束标志。</p>
</li>
</ul>
</li>
</ul>
<h3 id="hw6-UML类图"><a href="#hw6-UML类图" class="headerlink" title="hw6 UML类图"></a>hw6 UML类图</h3><img src="/2022/05/01/OO-Unit2-summary/2.png" class="" title="pic1">

<h3 id="hw6-两级调度器"><a href="#hw6-两级调度器" class="headerlink" title="hw6 - 两级调度器"></a>hw6 - 两级调度器</h3><ul>
<li><p>迭代：增加层/座的调度器<code>BuildingScheduler</code>和调度线程<code>SchedulerThread</code>。</p>
</li>
<li><p>中转请求：调度器负责接受来自输入线程的请求，调度线程把请求发放给本层/座特定电梯的调度器。使用生产者消费者模式。</p>
</li>
<li><p>计算调度：调度器综合本层/座的各电梯状态，按调度策略<code>choose()</code>选择派遣请求的电梯。</p>
</li>
<li><p>信息交互：调度器接受输入线程的终止信号，将其传递给电梯调度器后，作为调度线程结束标志。</p>
</li>
</ul>
<h3 id="hw7-UML类图"><a href="#hw7-UML类图" class="headerlink" title="hw7 UML类图"></a>hw7 UML类图</h3><img src="/2022/05/01/OO-Unit2-summary/3.png" class="" title="pic1">

<h3 id="hw7-流水线模式"><a href="#hw7-流水线模式" class="headerlink" title="hw7 - 流水线模式"></a>hw7 - 流水线模式</h3><ul>
<li><p>迭代：请求分阶段存储；增加<code>RequestCounter</code>作为流水是否结束的计数器。</p>
</li>
<li><p>中转请求：未完成请求由电梯线程更新下一流水阶段的目的地，并把请求发放给本层/座调度器。</p>
</li>
<li><p>信息交互：完成请求计数器加1.</p>
</li>
</ul>
<h2 id="2-4-调度器的可扩展性"><a href="#2-4-调度器的可扩展性" class="headerlink" title="2.4 调度器的可扩展性"></a>2.4 调度器的可扩展性</h2><p>我认为本单元选择调度器是一种结构清晰、扩展性好的办法。</p>
<ul>
<li>层/座的调度器<code>BuildingScheduler</code>和调度线程<code>SchedulerThread</code><ul>
<li>不论对于楼层和楼座，其基本行为保持一致，都可直接使用，复用性强。</li>
<li>如果想更换调度策略，只需重载choose()方法即可。</li>
<li>由于电梯的调度器实现了<code>Sche</code>接口，本级调度器存储的电梯名单为<code>elvList : ArrayList&lt;Sche&gt;</code>类型，所以不仅仅可以作为某层或某座的调度器，还可作为包含特定横向电梯+特定纵向电梯的调度器，例如服务于一类二次元主题的横纵电梯，乘客愿意步行爬楼前往此类电梯的可搭乘地进行观光乘坐电梯，即二次元乘客的专属调度器。</li>
</ul>
</li>
<li>不同类的电梯调度器实现<code>Sche</code>接口，方便与上层调度器交互。开始时由于横向电梯和纵向电梯的策略和实现差异较大，所以选择了接口而非继承。画出UML图以后觉得使用抽象类或许更加简洁。</li>
<li>两级调度器模式在hw7并未很大改动，只是增加了电梯线程把未完成请求发给层/座调度器的工序。两级调度器的扩展性较好。</li>
</ul>
<h1 id="三、同步块的设置和锁的选择"><a href="#三、同步块的设置和锁的选择" class="headerlink" title="三、同步块的设置和锁的选择"></a>三、同步块的设置和锁的选择</h1><h2 id="3-1-输出安全"><a href="#3-1-输出安全" class="headerlink" title="3.1 输出安全"></a>3.1 输出安全</h2><ul>
<li><p>输出类中采取单例模式，实现加锁的静态方法。</p>
</li>
<li><p>采用<strong>生产者消费者模式</strong>并<strong>不能</strong>完美地解决<strong>电梯作业</strong>的输出安全的问题：原因为例如[0.0]在输出队列添加OPEN请求，[0.4]在输出队列添加CLOSE请求，此时并不一定保证输出线程两次take()并println()的时间间隔严格≥0.4s.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        TimableOutput.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-共享对象"><a href="#3-2-共享对象" class="headerlink" title="3.2 共享对象"></a>3.2 共享对象</h2><ul>
<li>Scheduler类包含的共享对象为<strong>本电梯</strong>的请求队列<code>Arraylist&lt;PersonRequest&gt; requests</code>，所有读写此请求队列的方法均在Scheduler中实现。</li>
<li>即把共享对象和需要加锁的方法全部封装进Scheduler.</li>
</ul>
<h1 id="四、bug分析"><a href="#四、bug分析" class="headerlink" title="四、bug分析"></a>四、bug分析</h1><blockquote>
<p>分析自己程序的bug分析未通过的公测用例和被互测发现的bug：问题特征和修复办法  </p>
</blockquote>
<ul>
<li>本单元强测互测没有Bug。</li>
<li>hw5中测时遇到了轮询cpu超时的问题，后来经过排查是在[电梯线程里关门后]进入[依赖下一步请求实现的换向逻辑]时忘记wait()，导致电梯关门后进入空闲时跳过了此次换向逻辑而进入下一个循环的起始处wait().这导致了空闲后再有新请求进入时，电梯按上次循环时遗留下的方向继续运行，而缺少了电梯换向的逻辑导致从1层运行到0层。解决办法是电梯的每一个步骤后都添加wait()。</li>
<li>由于我在电梯每个步骤前都有换向逻辑，所以这种轮询出现情况只会在运行到1层且需要换向时空闲的这种特殊的情况下出现，所以轮询的bug在随机生成样例时比较难复现。手动造边界数据+循环起始处println()对于轮询更为有效。</li>
</ul>
<h1 id="五、hack策略"><a href="#五、hack策略" class="headerlink" title="五、hack策略"></a>五、hack策略</h1><blockquote>
<p>分析自己发现别人程序bug所采用的策略<br>列出自己所采取的测试策略及有效性<br>分析自己采用了什么策略来发现线程安全相关的问题<br>分析本单元的测试策略与第一单元测试策略的差异之处  </p>
</blockquote>
<ul>
<li>主要采用自动评测机的方式。不过这种评测方式有一定随机性，本地评测的bug有时难复现。hw5和hw6的评测机并没有发现bug。hw7的评测机本地运行发现了bug但是没有提交成功。评测机主要用于正确性测试，适合作业前期自测正确性。</li>
<li>另一种hack策略时针对特定线程安全的bug手动造数据，比如hw5时的线程输出安全问题，hw7时不可达的横线电梯出现的轮询问题。hw7时hack到一个横向电梯轮询的Bug。手动hack策略覆盖范围不如自动评测，但是效率和命中率较好。</li>
<li>本单元相较第一单元的策略差异是，例如超时和轮询的bug比较难通过评测机显现，所以更需要针对特殊情况手动造数据。</li>
</ul>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><blockquote>
<p>从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</p>
</blockquote>
<ul>
<li><p>从线程安全的角度：</p>
<ul>
<li><strong>死锁</strong>的bug比较好排查和避免，出现率并不高；</li>
<li><strong>共享对象</strong>使用sychronized和notifyAll()保证临界区的访问和修改是一种简单且省心的办法；本次作业稍有遗憾的是受限于时间并没有实现读写锁。</li>
<li><strong>线程的结束条件</strong>需要依据具体情况判断，比如hw5和hw6的结束条件只需要考虑<code>输入结束 &amp;&amp; 调度器中无请求 &amp;&amp; 电梯为空</code>；由于hw7出现请求中转的情况，所以在<code>输入结束</code>这个条件上不再只是输入线程读到<code>null</code>，而是使用类似Experiment4.2代码中的Counter静态实例，当所有请求均运送完毕后才视作输入结束，各级调度器逐级发放isEnd信号。</li>
<li><strong>轮询</strong>的Bug出现率比较高，且仅在特殊条件下出现而较难排查，需要合理地布局while循环终止地条件和wait()的位置。尤其是在LOOK算法需要频繁依据<strong>当前请求</strong>而实现转向逻辑的电梯中，需要更加细心地应对各种换向和空闲等情况。</li>
</ul>
</li>
<li><p>层次化设计：</p>
<ul>
<li>两级调度器更适合完成hw7的多换乘请求，各层级间传递请求易于实现。</li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OO/">OO</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script src="/" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/03/OS-lab3-summary/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OS-Lab3</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/14/OS-lab2-summary/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-Lab2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/24/OO-Unit1-summary/" title="BUAA-OO-Unit1"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">BUAA-OO-Unit1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%94%B5%E6%A2%AF%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">一、电梯的调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE"><span class="toc-text">1.1 状态转移图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%B5%E5%90%91%E7%94%B5%E6%A2%AF%E7%9A%84LOOK%E7%AE%97%E6%B3%95"><span class="toc-text">1.2 纵向电梯的LOOK算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LOOK%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">LOOK算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOOK%E7%AE%97%E6%B3%95%E7%9B%B8%E8%BE%83ALS%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">LOOK算法相较ALS的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%A8%AA%E5%90%91%E7%94%B5%E6%A2%AF"><span class="toc-text">1.3 横向电梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E8%BF%91%E7%AD%96%E7%95%A5"><span class="toc-text">就近策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">1.4 性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">二、调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%B0%83%E5%BA%A6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.1 调度器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8E%A9%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%A5%BC%E5%B1%82%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%8F%96%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-text">2.1.1 电梯调度器使用掩码表示楼层请求，取代遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%86%E9%85%8D%E7%BA%B5%E5%90%91%E7%94%B5%E6%A2%AF%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">2.1.2 座调度器分配纵向电梯的调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%B1%82%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%86%E9%85%8D%E6%A8%AA%E5%90%91%E7%94%B5%E6%A2%AF%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">2.1.3 层调度器分配横向电梯的调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-hw7%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5"><span class="toc-text">2.1.4 hw7的请求拆分策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2.1.5 调度器的性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-UML%E5%8D%8F%E4%BD%9C%E5%9B%BE%E4%B8%8E%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%9A%84%E8%BF%AD%E4%BB%A3"><span class="toc-text">2.2 UML协作图与三次作业的迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">2.3 协作模式与调度器功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hw5-UML%E7%B1%BB%E5%9B%BE"><span class="toc-text">hw5 UML类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hw5-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">hw5 - 生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hw6-UML%E7%B1%BB%E5%9B%BE"><span class="toc-text">hw6 UML类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hw6-%E4%B8%A4%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">hw6 - 两级调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hw7-UML%E7%B1%BB%E5%9B%BE"><span class="toc-text">hw7 UML类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hw7-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A8%A1%E5%BC%8F"><span class="toc-text">hw7 - 流水线模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-text">2.4 调度器的可扩展性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%90%8C%E6%AD%A5%E5%9D%97%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%94%81%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">三、同步块的设置和锁的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%BE%93%E5%87%BA%E5%AE%89%E5%85%A8"><span class="toc-text">3.1 输出安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2 共享对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81bug%E5%88%86%E6%9E%90"><span class="toc-text">四、bug分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81hack%E7%AD%96%E7%95%A5"><span class="toc-text">五、hack策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A"><span class="toc-text">六、心得体会</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Musel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="/" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>